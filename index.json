[{"categories":["SRE"],"content":"前言 這邊是我自己想寫的廢話，可以 skip 不看。 基本上現在處於一種 Chaos 的狀態吧，一邊點著 coding 的技能，另一邊又不願意放開 system \u0026 networking administration(management) 的技能樹，有一陣子去看了 SRE 的書籍，坦白說可能也不是很適合自己，但仍以學習新知識的角度來學習這項技能(或是知識)。 參考書籍 Google 已經提供，我有附在後面的參考資料。 基本上會是以 Site Reliability Engineering 這本書來作筆記。(其實是有想起來這本書看了一半，就乾脆把書看完吧) ","date":"2022-08-30","objectID":"/posts/infra/sre_1/:1:0","tags":["Infra","SRE"],"title":"Site Reliability Engineering - Introduction","uri":"/posts/infra/sre_1/"},{"categories":["SRE"],"content":"Tradition 公司透過系統來提供服務，而這些系統並不會自動運作，歷史上來看會需要雇用系統管理員(Administrator, Admin)來運行或維護系統(IT,MIS)，Admin的任務基本上是做部屬，讓系統之間能協同工作並提供服務，還有在問題發生時進行處理(Update, troubleshooting …)，由於技能樹點的不同，基本上在大部分的公司中，軟體或服務開發人員，與系統管理員，會分為兩個團隊。 目前在系統管理上，有許多現成的工具，並且網路上也有許多例子可以做學習，我們不必花費太多時間在重造輪子上。 然而當系統成長時，管理的成本也逐漸提高。例如原先手動一次就可以完成的事項，在系統成長後需要做到 100 次，甚至 1000 次。或是團隊之間對服務的看法不同，這經常發生在開發團隊與管理團隊之間。這是會影響團隊之間是合作或是分裂的成本。 開發團隊想推出新功能，管理團隊想要穩定服務(誰知道你的新功能會不會出包) 安全性，可靠性，服務是否在這次更新後正常運作，有沒有 bug，會不會造成其他功能 crash ? 我自己的經驗真的是這樣，兩個團隊的目標不一樣，我在管理團隊中就是不太想去做 patch update，只希望服務能夠穩定提供，甚至是這台伺服器就都不要去動他。但在開發團隊時，又很想趕快做出新功能後，進行更新並提供給使用者做使用。(工讀時兩個團隊都待過。) 但不可能都不推出新功能阿，只是，為了服務的可靠性，管理團隊會使用許多方式來檢查、驗證或測試新的功能是否有問題，或是會造成其他問題的可能。 開發團隊也可以透過發布更少的 patch、flag flips、incremental updates 與 cherrypicks 來減緩或降低這些事情發生的次數。 Info 即使兩個團隊的價值觀不盡相同，但大家都是為了提供更好且穩定的服務，請盡量不要因為目標不同而真的吵起來… ","date":"2022-08-30","objectID":"/posts/infra/sre_1/:2:0","tags":["Infra","SRE"],"title":"Site Reliability Engineering - Introduction","uri":"/posts/infra/sre_1/"},{"categories":["SRE"],"content":"In Google 基本上在 Google 內部是透過軟體工程師建立系統來運行由系統管理員手動執行的工作。 這個 SRE 團隊一半是軟體工程師，一半是具備 SRE 技能的工程師，SRE技能基本上是 Linux internals 與 networking(TCP/IP)(但也會軟體工程)。 基本上是以軟體工程的方式，來處理系統管理的問題，盡可能的使用軟體設計實現自動化以降低手動執行的工作，甚至是獲得自動化的系統，這個系統能夠自動運行並自我修復。 限定 50% 的時間會用在管理，另外的時間會用於實際開發，一來是可以參與主要工程，了解這次的開發是為了甚麼，是如何運作的，有沒有能再更好的地方，當知道系統怎麼維運時，在進行開發上就會知道那些地方是要注意的，並且這些經驗可以與開發團隊分享，達到提升整體的技能之目的。 偷渡個 SRE 的技能書 (面試用書)，但請記得，軟體開發還是主要技能。 Algorithms and data structures : arrays, stacks, linked lists, binary trees, graphs, recursion Book: Cracking the Coding Interview, 6th Edition, ISBN 0984782869 System design : Book: System Design Interview – An insider’s guide, 2nd Edition, ISBN 979-8664653403 Linux internals : Book: Advanced Programming in the UNIX Environment, 3rd Edition, ISBN 0321637739 TCP/IP : Book: TCP/IP Illustrated, Volume 1: The Protocols, ISBN 0321336313 ","date":"2022-08-30","objectID":"/posts/infra/sre_1/:3:0","tags":["Infra","SRE"],"title":"Site Reliability Engineering - Introduction","uri":"/posts/infra/sre_1/"},{"categories":["SRE"],"content":"SRE 宗旨 負責並專注在服務的可用性、延遲、性能、效率、變更管理、監控、緊急事項回應與容量規劃。 不僅僅是專注在系統服務環境，還包含開發團隊、測試團隊與使用者等。 ","date":"2022-08-30","objectID":"/posts/infra/sre_1/:4:0","tags":["Infra","SRE"],"title":"Site Reliability Engineering - Introduction","uri":"/posts/infra/sre_1/"},{"categories":["SRE"],"content":"參考資料 SRE-Books ","date":"2022-08-30","objectID":"/posts/infra/sre_1/:5:0","tags":["Infra","SRE"],"title":"Site Reliability Engineering - Introduction","uri":"/posts/infra/sre_1/"},{"categories":["Troubleshooting"],"content":"簡單提一下網路緩慢時的處理方式與工具。 ","date":"2022-07-28","objectID":"/posts/infra/troubleshooting_3/:0:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--Slowly","uri":"/posts/infra/troubleshooting_3/"},{"categories":["Troubleshooting"],"content":"前言 自己在處理網路緩慢的問題經驗並不多，但基本上自己會先往幾個方向去思考問題點在哪： 高延遲（High Latency），想一想我們前面提到 3 way handshake 時，假設一來一往，每一個步驟都要花 1000ms，建立一個連線要 3 秒鐘，這樣當然會慢啦。 使用較小的 MSS，意味著在同樣的時間內所輸的資料較少，這樣也會感覺慢慢的。 太多人使用，壅塞了！ 其他我可能沒想到的原因。 因為緩慢可能會有很多原因，可以透過一些工具來幫助自己釐清這些問題。 以下會對這些工具做一些簡單的介紹。 mtr tcpdump, wireshark iperf ","date":"2022-07-28","objectID":"/posts/infra/troubleshooting_3/:1:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--Slowly","uri":"/posts/infra/troubleshooting_3/"},{"categories":["Troubleshooting"],"content":"mtr mtr 就是把 traceroute(tracert) 跟 ping 組合起來，主要是用來觀察 latancy 或是 packet loss% 的工具。 其實就很像 traceroute，但 mtr 顯示的資訊更豐富，並會計算所有 hop 回應的百分比與回應時間。 $ mtr 8.8.8.8 那他會帶你進入一個介面做觀察，按 q 可以離開。 第一次看到 mtr 大概是這樣子\" 第一次看到 mtr 大概是這樣子 主要可以觀察到 packet 的遺失率，如果說有幾個不連續的幾個 node 掉了幾個封包，其實是不會造成太大的影響，但如果是某一個 node 後所有的 node 都有封包遺失，那一個 node 則會對整個傳輸造成影響，也就會讓使用者感受到緩慢，可以推測那個 node 上有問題。 另外可以觀察 icmp 封包的傳輸延遲，雖然 traceroute 也做得到，但 mtr 他提供的資訊比較多啦。 Last : 最後一次的延遲數值 Avg : 平均的延遲數值 Best : 最佳的延遲數值（最短） Wrst : 最糟的延遲數值（最長） StDev : 標準偏差（Standard Deviation），愈大代表這個 node 愈不穩定。 以上圖的例子來說，第二個點的延遲就有點糟且不太穩定。 另外可以加入一些參數做不同的使用： ## -n 可以強制以 IP address 顯示所有 node $ mtr -n 8.8.8.8 前面我們提到 tcptraceroute，那在 mtr 上可以使用 tcp 或 udp 嗎？ 可以的 !! 有時候也需要觀察 tcp 或 udp 資料在這段網路上的傳輸品質。 $ mtr --tcp 8.8.8.8 $ mtr --udp 8.8.8.8 我想改變封包的 size 可以嗎？ -s 會幫助你！ 可以透過更改封包的大小來觀察網路使用狀況。 $ mtr -s [PACKETSIZE] 8.8.8.8 最後，可以透過 -r 這個參數做紀錄。 ### 預設會送 10 次做觀察。 $ mtr -r 8.8.8.8 \u003e [filename] ### 透過 -c 調整次數，這樣他就會送 100 次。 $ mtr -r -c 100 8.8.8.8 \u003e [filename] ### 這樣他就會在背景送 1000 次，然後你可以去喝咖啡。 $ mtr -r -c 1000 8.8.8.8 \u003e [filename] \u0026 ","date":"2022-07-28","objectID":"/posts/infra/troubleshooting_3/:2:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--Slowly","uri":"/posts/infra/troubleshooting_3/"},{"categories":["Troubleshooting"],"content":"tcpdump, Wireshark tcpdump 是一個功能強大的，而且也是使用最廣泛的 sniffer 與分析工具，用來捕捉或過濾在特定介面上接收或傳輸的 TCP/IP packet。 基本上在多數的環境中都可以使用，並且可以將捕捉的結果儲存為 .pcap 格式，可以透過 Wireshark 做更進一步的分析。 坦白說，tcpdump 也是會在網路無法連線時使用到，像是 ssl 無法建立，或是 VLAN tag 設定錯之類的情形，我會把它放在這是因為，我自己在看 MSS 時會用到。MMS 的大小會影響傳輸效能。或觀察封包的往來時間。 Wireshark 也具有相同的功能，並提供圖形化介面做更容易的使用。 這邊只會介紹 tcpdump，基本上，環境預設是不會有這個工具，所以我們要先自行安裝。 # macOS(OSX) $ brew install tcpdump # Debian, Ubuntu $ sudo apt-get install tcpdump 首先，我們可以選擇指定的介面捕捉封包。透過 -i 這個參數可以指定介面。 $ tcpdump -i eth0 16:59:22.920016 IP 172.20.10.4.50011 \u003e a104-115-254-134.deploy.static.akamaitechnologies.com.https: Flags [.], ack 213539838, win 2048, length 0 16:59:22.920017 IP 172.20.10.4.50007 \u003e a173-222-181-125.deploy.static.akamaitechnologies.com.https: Flags [.], ack 2165220779, win 2048, length 0 16:59:22.920017 IP 172.20.10.4.50003 \u003e 137.155.120.34.bc.googleusercontent.com.https: Flags [.], ack 281486443, win 2048, length 0 那我們要如何知道，有哪些介面可以監聽呢？ifconfig tcpdump 提供 -D 這個參數，讓我們可以知道可以使用哪些介面。 $ tcpdump -D 1.en0 [Up, Running, Wireless, Associated] 2.p2p0 [Up, Running, Wireless, Not associated] 3.awdl0 [Up, Running, Wireless, Associated] 4.llw0 [Up, Running, Wireless, Associated] 5.utun0 [Up, Running] 6.utun1 [Up, Running] 7.lo0 [Up, Running, Loopback] 8.en1 [Up, Running, Disconnected] 9.en2 [Up, Running, Disconnected] 10.gif0 [none] 11.stf0 [none] 12.XHC20 [none] 13.bridge0 [none, Disconnected] 14.en4 [none, Disconnected] 並可以透過 -n 再進一步，只捕獲這個介面上 IP 的封包。 $ tcpdump -n -i en0 另外還可以透過 -XX 這個參數，顯示封包的數據內容，並以 HEX 與 ASCII 格式顯示。 $ tcpdump -XX -i en0 17:04:15.996062 IP6 2001-b400-e35d-11b9-e87c-0c6e-2d6e-27bf.emome-ip6.hinet.net.50145 \u003e 2403:300:a41:b02::7.https: Flags [P.], seq 3353679317:3353679348, ack 252170061, win 2048, options [nop,nop,TS val 2584095760 ecr 718123086], length 31 0x0000: feaa 8116 f864 80e6 501d eed8 86dd 602b .....d..P.....`+ 0x0010: 0700 003f 0640 2001 b400 e35d 11b9 e87c ...?.@.....]...| 0x0020: 0c6e 2d6e 27bf 2403 0300 0a41 0b02 0000 .n-n'.$....A.... 0x0030: 0000 0000 0007 c3e1 01bb c7e5 15d5 0f07 ................ 0x0040: cf4d 8018 0800 0bba 0000 0101 080a 9a06 .M.............. 0x0050: 2c10 2acd b04e 1503 0300 1a00 0000 0000 ,.*..N.......... 0x0060: 0000 022b 2353 39dc 701e eb0a d4f2 219e ...+#S9.p.....!. 0x0070: 6eca 679d 37 n.g.7 前面提到，可以將這些紀錄儲存為 .pcap 格式，只需要透過 -w 即可使用。 $ tcpdump -w myFileName.pcap -i en0 既然可以寫入，那應該也可以讀取吧？ 沒錯，透過 -r 這個參數可以讀取 .pcap 檔案。 $ tcpdump -r myFileName.pcap 接下來是一些更細部的參數，可以讓我們根據情境做調整： # 只抓 TCP $ tcpdump -i en0 tcp # 只抓某個 port number $ tcpdump -i en0 port 22 # 只抓來源 IP 為 8.8.8.8 的 $ tcpdump -i en0 src 8.8.8.8 # 只抓目的 IP 為 168.95.1.1 的 $ tcpdump -i en0 src 168.95.1.1 因為這篇文章，主要是工具的使用，更細一步的分析，往後有時間會再撰寫吧。 ","date":"2022-07-28","objectID":"/posts/infra/troubleshooting_3/:3:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--Slowly","uri":"/posts/infra/troubleshooting_3/"},{"categories":["Troubleshooting"],"content":"iperf iperf 是一種測量網路上最大頻寬的工具，可以調整 timing, buffer 與 protocol(TCP, UDP, ICMP …)，並產生頻寬與損耗等相關報告。 一般來說，使用 iperf 要有兩個端點(node)，透過兩個端點進行測量。(Server, Client) # Server $ iperf3 -s # Client $ iperf3 -c [Server IP address] 可…可是我只有一台電腦，那也可以透過公開的 iperf server 做測試。連結 不過我自己用了幾個，都是在忙碌中… 比較常用的參數有 -p, -u 與 -t 等。 $ iperf -p 8888 -c [server] # 改 port number $ iperf -u 8888 -c [server] # 改用 UDP，預設是 TCP $ iperf -t 60 -c [server] # 更改傳輸的總時間 但這個工具我會建議用在做單個點的驗證，因為多個點時，使用 iperf 只會容易知道整體鏈路情況，但實際哪個點或哪幾個點有問題，可能還是要用 mtr 或類似的工具做補助。 ","date":"2022-07-28","objectID":"/posts/infra/troubleshooting_3/:4:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--Slowly","uri":"/posts/infra/troubleshooting_3/"},{"categories":["Troubleshooting"],"content":"參考資料 mtr tcpdump wireshark iperf 各個工具的 -h, --help 指令，man 的說明。 ","date":"2022-07-28","objectID":"/posts/infra/troubleshooting_3/:5:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--Slowly","uri":"/posts/infra/troubleshooting_3/"},{"categories":["Troubleshooting"],"content":"這篇會簡單提一下自己在網路正常卻無法存取服務時，自己會使用的工具與使用方式。 ","date":"2022-06-17","objectID":"/posts/infra/troubleshooting_2/:0:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/infra/troubleshooting_2/"},{"categories":["Troubleshooting"],"content":"前言 上一篇文章基本上是自己在找網路中斷的問題時會用到的工具，但許多時候網路是正常的，問題點則是在伺服器或服務上。 我通常會看服務是否有啟用，並根據相對應的服務做後續的處理，下面是我在這種情境中，我經常用到的工具。 netstat(ss) nmap nc ","date":"2022-06-17","objectID":"/posts/infra/troubleshooting_2/:1:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/infra/troubleshooting_2/"},{"categories":["Troubleshooting"],"content":"netstat 基本上許多作業系統都已預設安裝 netstat 這個工具，用來顯示目前網路連結的狀態 (connetion)。 -s : 會顯示統計數據。可以在後面加上 t(tcp)或是u(udp) 對於協定做進一步的查詢。 $ netstat -st IcmpMsg: InType0: 33 InType11: 319 OutType3: 7 OutType8: 352 Tcp: 50 active connection openings 14 passive connection openings 0 failed connection attempts 1 connection resets received 19 connections established 7193 segments received 7100 segments sent out 0 segments retransmitted 0 bad segments received 2 resets sent UdpLite: TcpExt: 39 TCP sockets finished time wait in fast timer 31 delayed acks sent 1818 packet headers predicted 2219 acknowledgments not containing data payload received 1497 predicted acknowledgments TCPBacklogCoalesce: 11 TCPRcvCoalesce: 293 TCPAutoCorking: 28 TCPOrigDataSent: 1900 TCPKeepAlive: 1830 TCPDelivered: 1950 IpExt: InOctets: 1865047 OutOctets: 207989 InNoECTPkts: 2521 -r : 可以顯示目前的路由表(routing table)。也可以透過 route 指令去顯示。(依據作業系統可能會是 route PRINT 或 route -n) $ netstat -r Kernel IP routing table Destination Gateway Genmask Flags MSS Window irtt Iface default 10.0.2.2 0.0.0.0 UG 0 0 0 enp0s3 10.0.2.0 0.0.0.0 255.255.255.0 U 0 0 0 enp0s3 -p : 可以觀察到是哪個 process 在存取。在 Windows 上的會是選擇觀察哪種協定(TCP, UDP)。 netstat 還有許多參數可以使用，請依據自己遇到的情境挑選適合的參數。 ","date":"2022-06-17","objectID":"/posts/infra/troubleshooting_2/:2:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/infra/troubleshooting_2/"},{"categories":["Troubleshooting"],"content":"ss 基本上他就是 netstat 的加強版，基本上參數的使用也跟 netstat 差不多，個人覺得 ss 比較好用，看起來比較舒服一點，但 netstat 通常會是預設安裝，而 ss 則不是。 ss 目前在 iproute2 中，要使用請安裝 iproute2 : $ sudo apt-get install iproute2 ","date":"2022-06-17","objectID":"/posts/infra/troubleshooting_2/:2:1","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/infra/troubleshooting_2/"},{"categories":["Troubleshooting"],"content":"TCP states 請你暫時忍耐一下，關閉夜間模式 ! 如同聖經般的 TCP 狀態圖。\" 如同聖經般的 TCP 狀態圖。 之所以會放這張圖是因為，有時候是 Service 在設計上時有問題，又或者是遇到服務被攻擊而造成的 breakdown，此時可以透過狀態來分析並進行後一步的處理。 好比說我在 Server 上看到許多 SYN_RECV 狀態，可能代表在 3-way handshake 上遇到問題，Server 收到了 Client 發送的 SYN packet，於是 Server 的狀態為 SYN_RECV 並回傳一個 SYN+ACK 的封包並等待對方回傳 ACK，然而一直沒收到就保持在這個狀態許久。 通常遇到這種情形，可以先懷疑是 TCP SYN FLOOD 攻擊。 ","date":"2022-06-17","objectID":"/posts/infra/troubleshooting_2/:2:2","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/infra/troubleshooting_2/"},{"categories":["Troubleshooting"],"content":"nmap 坦白說他是掃描 port 的工具，是自己以前在接觸 cyber security 時所學到的。 我會提到 nmap 是因為他可以讓我快速知道遠端機器是否存活，服務是否有掛上。 除此之外，nmap 也很常使用在網路安全上，並可以透過 script 和微調設定，掃瞄系統並檢查常見的漏洞，或是找到在常用的伺服器上具有的致命設定。(Web, Database and Mail … etc) 有點扯太遠了，我還是拿來看 port 有沒有開即可 … Warning 請不要對某個特定目標用 nmap 執行大量的 scan，你有可能因此被 block。 # 最常使用的 scan command. $ nmap -sS example.com # UDP Scan $ nmap -sU example.com # 針對某幾個 port number 做 Scan $ nmap -sS -p 80,443 8.8.8.8 Starting Nmap 7.80 ( https://nmap.org ) at 2022-06-16 19:34 HST Nmap scan report for dns.google (8.8.8.8) Host is up (0.0014s latency). PORT STATE SERVICE 80/tcp filtered http 443/tcp open https Nmap done: 1 IP address (1 host up) scanned in 1.23 seconds ","date":"2022-06-17","objectID":"/posts/infra/troubleshooting_2/:3:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/infra/troubleshooting_2/"},{"categories":["Troubleshooting"],"content":"nc (netcat) 一個很強但我不太會用的工具。(功能太多) 會簡單提一下我比較常用的功能: 確認 Port 是否有開啟： $ nc -v example.com 80 Warning: inverse host lookup failed for 93.184.216.34: Unknown host example.com [93.184.216.34] 80 (http) open 如果沒有開啟則會得到這個結果： $ nc -v example.com 2022 nc: connect to 192.168.233.208 2022 (tcp) failed: Connection refused ### 也有可能像到進黑洞，下完指令後就卡在那邊\u003e\u003c ### 這時要看你的目標的防火牆或是相關的規則，進而導致有不同的結果。 也因此 nc 可以用來做 port scanning ! 不過這不代表可以取代 nmap，我覺得工具各有優缺點，像我做 scanning 應該還是會用 nmap。 Warning 再一次提醒，請不要對某個特定目標執行大量的 scan，你有可能被 block。 # nc -vnz [parameter] [Target IP address] [port range] # e.g. $ nc -vz -w 1 8.8.8.8 2000-3000 ## -w 是 timeout。 ## 這樣會是測 TCP 的，如果想要測 UDP ，就給他個 U 吧 !! # e.g. $ nc -vzu 8.8.8.8 2000-3000 如果你能同時控制兩台電腦，nc 也很常被用來傳輸檔案， 這邊要注意一下優先順序， Receiver 要先開啟後再由 Transmitter 傳輸。 (冰箱沒有打開，要怎麼把大象放進去???) ## Receiver $ nc -l -p 3333 \u003e name.file ## Transmitter $ nc [receiver IP address] 3333 \u003c name.file 自己比較常常用來把系統的日誌檔扔到自己的電腦，做一些分析~~(抱歉我的 grep, awk, sed 沒學好)~~ 或許用 scp 與其他的 command 會比較快一點，但多學一個方式也不是壞處。 可以偷偷把 Linux 上的 shadow 跟 passwd 拿出去然後做一些壞壞的事情(? 也可以連線到服務，做簡單的測試： $ nc example.com 80 GET / HTTP/1.1 # 這一行是要自己 key in 的。 # 但如果要測網頁，我會建議你用 curl, wget 或是我們常用的 browser 會比較快速也比較方便一點。 ","date":"2022-06-17","objectID":"/posts/infra/troubleshooting_2/:4:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/infra/troubleshooting_2/"},{"categories":["Troubleshooting"],"content":"小結論 在確定網路正常，但使用者仍無法連線至服務的情況下，我會使用上述的工具，快速檢查伺服器端的上的 service port 是否正常開啟，若不是正常開啟，又會是甚麼原因造成的。 並根據不同的服務，進一步使用不同的工具來做故障排除。 像是 DNS 就再用 dig 看一下紀錄是否正常，Web 就用 curl, wget 等。 當然，還有很多原因會造成網路正常但服務無法存取，至少希望能透過這些工具進一步的判斷故障點在何處，或是大概的範圍。 最後，nmap 與 netcat(nc)都是很有力的工具，甚至可以單獨為一本書，在參考資料我會提到相關書籍可以參考。 ","date":"2022-06-17","objectID":"/posts/infra/troubleshooting_2/:5:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/infra/troubleshooting_2/"},{"categories":["Troubleshooting"],"content":"參考資料 Windows-commands: netstat manpages-ss, Debian testing Nmap Network Exploration and Security Auditing Cookbook Netcat Power Tools ","date":"2022-06-17","objectID":"/posts/infra/troubleshooting_2/:6:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/infra/troubleshooting_2/"},{"categories":["Troubleshooting"],"content":"基本上分享自己在進行網路中斷的故障排除時，經常使用到的工具與使用方式。 ","date":"2022-06-11","objectID":"/posts/infra/troubleshooting_1/:0:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/infra/troubleshooting_1/"},{"categories":["Troubleshooting"],"content":"前言 在網路中斷或是緩慢時，總需要有人去處理，緩慢還可以用 Google 大法協助，不過個人認為緩慢比中斷還要難排除。 這篇會先單純以網路斷線為主題撰寫，分享幾個自己常用的工具。 (只要修好網路斷線，剩下的問題就拿去問 Google !!!) ifconfig, ipconfig, ip addr ping traceroute(tracert), tcptraceroute dig, nslookup mtr netstat nmap nc curl, wget tcpdump, wireshark 這邊基本上會先說明一些工具，來驗證兩地之間的網路是正常連線，還沒考慮到應用層與緩慢的問題。 關於應用層與緩慢的問題，會在後續的文章中加以說明。 ","date":"2022-06-11","objectID":"/posts/infra/troubleshooting_1/:1:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/infra/troubleshooting_1/"},{"categories":["Troubleshooting"],"content":"ifconfig (ip addr, ipconfig on Windows) 我一直以來都是喜歡用 ifconfig ，或是在 Windows 上使用 ipconfig，因為這兩個指令相近，自然而然就會在 Windows 上使用 ifconfig （不要笑） 後來 Debian 改版之後，不再預安裝 net-tools，所以改用 ip addr 這個指令。 Windows 上的 ipconfig 會建議再加上 -all 一次獲得更多資訊。 基本上這些指令都可以看網路卡的 IP 資訊，有時是 DHCP Server 故障沒有取到 IP address，或是 IP address 設錯等問題，改一下就排除了。 ","date":"2022-06-11","objectID":"/posts/infra/troubleshooting_1/:2:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/infra/troubleshooting_1/"},{"categories":["Troubleshooting"],"content":"ping ping 應該是最常被用到的工具之一，我相信很多人做過這件事： $ ping 8.8.8.8 如果我們的 DNS 正常，也可以透過 FQDN 進行： $ ping aws.amazon.com PING dr49lng3n1n2s.cloudfront.net (143.204.75.75): 56 data bytes 64 bytes from 143.204.75.75: icmp_seq=0 ttl=233 time=49.306 ms 64 bytes from 143.204.75.75: icmp_seq=1 ttl=233 time=561.229 ms 64 bytes from 143.204.75.75: icmp_seq=2 ttl=233 time=53.671 ms 64 bytes from 143.204.75.75: icmp_seq=3 ttl=233 time=68.874 ms 64 bytes from 143.204.75.75: icmp_seq=4 ttl=233 time=49.972 ms 至於為什麼變成是 PING dr49lng3n1n2s.cloudfront.net 呢，CNAME什麼的下回解析 我自己比較加上的參數應該是 -c or -m，畢竟使用 ping 通常只是用來驗證網路是否有連線而已。 $ ping -c 10 1.1.1.1 # 對 1.1.1.1 進行 10 次 icmp 封包的傳送並等待回覆。 $ ping -m 10 1.1.1.1 # 將 ttl 改為 10 後進行 10 次 icmp 封包的傳送並等待回覆。 我自己是用 ping 的法則大概是這樣的順序，基本上就是由 Client 慢慢到 Server： ping localhost ping [host IP address] ping [Gateway IP address] ping [Server IP Address] 但沒有一定的方法，我覺得依據個人喜歡的方式使用即可，畢竟我們的目標是故障排除而不是在那邊計較先後順序。 ","date":"2022-06-11","objectID":"/posts/infra/troubleshooting_1/:3:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/infra/troubleshooting_1/"},{"categories":["Troubleshooting"],"content":"traceroute (tracert on Windows) 透過更改 ttl 的方式，去 trace 網路路徑的工具，可以讓我們較容易知道網路到哪個 node 時出問題： $ traceroute 8.8.8.8 traceroute to 8.8.8.8 (8.8.8.8), 64 hops max, 52 byte packets 1 172.20.10.1 (172.20.10.1) 1.182 ms 0.606 ms 0.580 ms 2 * * * 3 * * * 4 * * * 5 tpdb-3312.hinet.net (210.65.126.98) 38.918 ms 19.277 ms 25.854 ms 6 tpdb-3031.hinet.net (220.128.1.254) 25.584 ms tpdb-3031.hinet.net (220.128.1.114) 17.709 ms tpdb-3031.hinet.net (220.128.1.254) 23.210 ms 7 220-128-9-121.hinet-ip.hinet.net (220.128.9.121) 21.327 ms * 57.736 ms 8 tpdt-3302.hinet.net (220.128.12.61) 29.946 ms pcpd-4102.hinet.net (220.128.13.109) 28.238 ms 220-128-13-169.hinet-ip.hinet.net (220.128.13.169) 20.401 ms 9 72.14.202.178 (72.14.202.178) 19.526 ms 72.14.209.178 (72.14.209.178) 34.970 ms 142.250.169.122 (142.250.169.122) 26.003 ms 10 * * * 11 dns.google (8.8.8.8) 24.621 ms 19.687 ms 209.85.245.64 (209.85.245.64) 21.766 ms ","date":"2022-06-11","objectID":"/posts/infra/troubleshooting_1/:4:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/infra/troubleshooting_1/"},{"categories":["Troubleshooting"],"content":"tcptraceroute 相較於 traceroute 使用 icmp，這是使用 tcp 去進行 trace 的工具。 因為在現代網路上，防火牆通常會阻擋 icmp 的封包進入， 然而我們在瀏覽網頁或是發送信件時，防火牆大都會讓 tcp 封包進入，為了進行 3-way handshake 進行後續的連線建立，client 首先會發送 SYN 封包。 而 tcptraceroute 就是透過這個 TCP-SYN 封包進行 trace 而實現。讓你可以做更深入的測試? 通常你的電腦內不會有這個工具，必須自己去下載安裝。 使用方式也很簡單，基本上怎麼用 traceroute 就怎麼使用 tcptraceroute。 比較常用的方式是在加上 port number ，針對你遇到的問題，或是你想針對特定的某個服務，去進行 trace。 \u0026 sudo traceroute -p 443 example.com Note 可以自己找個目標，嘗試並比較 traceroute 與 tcptraceroute 的差異。 ","date":"2022-06-11","objectID":"/posts/infra/troubleshooting_1/:4:1","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/infra/troubleshooting_1/"},{"categories":["Troubleshooting"],"content":"dig (nslookup) 這邊會提到 dig 是因為有時候是 DNS 紀錄錯誤，導致 host 一直連到別的 IP address，當然就無法連線囉！！ 基本上我在網路連線中斷排除時，會用這個單純看目標 IP address 看是否正確而已。 其實兩個工具很類似，但我認為 dig 給的資訊量較大，也有較多的功能可以使用，所以這邊只會講 dig。 dig 也不是預先安裝的工具，那要怎麼用？？ (安裝啊) ### macOS $ brew install bind ### Debian (你可能會遇到更新與權限問題) $ apt install dnsutils 裝好了我們就趕快測試一下！！ $ dig example.com ; \u003c\u003c\u003e\u003e DiG 9.10.6 \u003c\u003c\u003e\u003e example.com ;; global options: +cmd ;; Got answer: ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: NOERROR, id: 41551 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: ;example.com. IN A ;; ANSWER SECTION: example.com. 4502 IN A 93.184.216.34 ;; Query time: 20 msec ;; SERVER: 172.20.10.1#53(172.20.10.1) ;; WHEN: Sun Jun 12 21:38:04 CST 2022 ;; MSG SIZE rcvd: 56 我們可以透過 @ 來指定某台 DNS server 做查詢。 $ dig example.com @168.95.1.1 或是指令紀錄的種類去查詢： $ dig gmail.com MX Note 試試看吧！ $ dig example.com +trace ","date":"2022-06-11","objectID":"/posts/infra/troubleshooting_1/:5:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/infra/troubleshooting_1/"},{"categories":["Troubleshooting"],"content":"小結論 這篇的工具大部分是我用來驗證，我的 host 是否能到達我想去的目標。 當我們可以到達目標時，問題大多數會是在 Application Layer 或是 Transport layer 上。 此時就會使用別的工具去做故障排除了。 ","date":"2022-06-11","objectID":"/posts/infra/troubleshooting_1/:6:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/infra/troubleshooting_1/"},{"categories":["Troubleshooting"],"content":"參考資料 tcptraceroute Dig Command in Linux (DNS Lookup) ","date":"2022-06-11","objectID":"/posts/infra/troubleshooting_1/:7:0","tags":["Infra","Troubleshooting"],"title":"故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/infra/troubleshooting_1/"},{"categories":["Infra"],"content":"簡單介紹 ansible。 ","date":"2022-04-19","objectID":"/posts/ansible/ansible_note01/:0:0","tags":["Ansible","Infra"],"title":"Ansible 簡介（introduction）","uri":"/posts/ansible/ansible_note01/"},{"categories":["Infra"],"content":"前言 基本上會看 ansible 是因為以前接觸過，但沒有深入去研究，不過 ansible 仍然為自己想學習的技能之一，故這次想透過這本書做進一步的學習。 這系列的文章應該會更新的很慢，因為手邊還有一些事情要處理，並不像之前更新 Go 系列，有較頻繁的更新頻率。 （ 而且 Go 系列到後面都在亂寫…） 基本上因為雲的高擴展性與容易性（相較容易使用），許多服務逐漸放上雲去運作，包含常見的 Web server、應用程式伺服器與資料庫等，基本上 IT 人員要負責這些服務的運作，監控與紀錄並進一步分析，甚至要安排冗餘，使得故障時，服務能不受大影響。 為了維護這些服務，可以手動處理，但手動設定這些服務非常耗時，而且容易出錯，同樣的事情可能做個三次四次就會覺得煩躁，如果遇到困難的任務或是設定，可能還沒弄好，心情先差到極點。 透過 ansible，我們可以降低配置服務時的時間，降低出錯的機率，並且這是自動化的，只要一開始願意花時間配置 ansible，後面就會多一些時間喝咖啡（但不要灑出來） Note 我們要效能。 看看就好\" 看看就好 ","date":"2022-04-19","objectID":"/posts/ansible/ansible_note01/:1:0","tags":["Ansible","Infra"],"title":"Ansible 簡介（introduction）","uri":"/posts/ansible/ansible_note01/"},{"categories":["Infra"],"content":"簡介 Ansible 通常被稱為 配置管理工具 (configuration management tool)，通常在談論配置管理時，代表我們會替伺服器編寫特定的狀態描述，並以工具使伺服器確實處在該狀態。 Ansible 也能幫助我們進行部署的工作，像是開發時產生的編譯檔，將這個編譯檔部署至伺服器上並運行。 另外也經常用來配置新的伺服器，簡單來說我需要一台安裝好 python 並且已經設定好 vim 參數的虛擬機，可以透過 ansible 協助我們產生這樣的虛擬機。另外也可以配置關於雲的服務等（包括 EC2、Azure、Digital Ocean、Google Compute Engine、Linode 和 Rackspace，以及任何支持 OpenStack API 的雲。） ","date":"2022-04-19","objectID":"/posts/ansible/ansible_note01/:2:0","tags":["Ansible","Infra"],"title":"Ansible 簡介（introduction）","uri":"/posts/ansible/ansible_note01/"},{"categories":["Infra"],"content":"工作原理 舉個例子： 有個使用者需要透過 ansible，在三台 Ubuntu 上安裝 nginx，三台分別稱為 web1, web2 與 web3，使用者編寫了一個名為 webservers.yml 的 Ansible 腳本。在 Ansible 中，腳本稱為 playbook。playbook 描述了要配置的主機（Ansible 稱之為遠端伺服器），以及要在這些主機上執行的任務的有序列表。 webservers.yml 的內容會在後面提到，這邊只是單純說明原理。使用者寫好 webservers.yml 後會透過 ansible-playbook 運行 playbook： $ ansible-playbook webservers.yml 基本上任務會像這樣： - name:Install nginxpackage:name:nginxAnsible 將執行以下操作： 生成安裝 Nginx package 的 Python 腳本 將腳本複製到 web1、web2 和 web3 在 web1、web2 和 web3 上執行腳本 等待腳本在所有主機上完成執行 Tips 注意以下幾點： Ansible 在所有主機上並行運行每個任務。 Ansible 會等到所有主機都完成一個任務，然後再移動到下一個任務。 Ansible 按照您指定的順序運行任務。 ","date":"2022-04-19","objectID":"/posts/ansible/ansible_note01/:3:0","tags":["Ansible","Infra"],"title":"Ansible 簡介（introduction）","uri":"/posts/ansible/ansible_note01/"},{"categories":["Infra"],"content":"優勢 相較於其他配置管理工具， ansible 學習起來較容易些。 ansible 使用 yaml 與 Jinja2 模板，兩者都很容易上手。 yaml 我在使用 github actions 就有經驗了，非常的直觀。 可以透過多種方式檢查 ansible playbook，例如列出所有涉及操作的主機。如果要測試 playbook，可以使用 ansible-playbook --check 來測試，並且有 log 可以觀察誰在哪裡做了什麼。 遠端伺服器也不需要預先安裝許多服務，在 Linux 上只需要安裝 SSH 與 python，而在 Windows 上需要啟用 WinRM。 可以在 Raspberry Pi 或是舊電腦上運作，不需要很好的硬體資源。 有社群可以分享自己的 playbook ，或是參考別人的 playbook。 使用抽象的方式運作： e.g. 使用 shell 建立目錄並設定權限： mkdir -p /etc/skel/.ssh chown root:root /etc/skel/.ssh chmod go-wrx /etc/skel/.ssh 透過 ansible 運作： - name:Create .ssh directory in user skeletonfile:path:/etc/skel/.sshmode:0700owner:rootgroup:rootstate:directory","date":"2022-04-19","objectID":"/posts/ansible/ansible_note01/:4:0","tags":["Ansible","Infra"],"title":"Ansible 簡介（introduction）","uri":"/posts/ansible/ansible_note01/"},{"categories":["Infra"],"content":"需要的基本技能 基本上要熟悉至少一種 Linux ，像是 Ubuntu, CentOS 等，並了解以下技能或資訊： 使用 SSH 連接到遠端設備 Bash ,shell 交互（pipes and redirection） 安裝 package sudo 檢查和設置文件權限 啟動和停止服務(service) 設置環境變數(env) 編寫 script ","date":"2022-04-19","objectID":"/posts/ansible/ansible_note01/:5:0","tags":["Ansible","Infra"],"title":"Ansible 簡介（introduction）","uri":"/posts/ansible/ansible_note01/"},{"categories":["Infra"],"content":"安裝 基本上安裝相當簡單： ## macOS $ brew install ansible 或是使用 pip 進行安裝： ## Unix/Linux/macOS $ python -m pip install --user ansible 雖然 ansible 可以管理 windows，但不能在 windows 上運行 ansible。 ","date":"2022-04-19","objectID":"/posts/ansible/ansible_note01/:6:0","tags":["Ansible","Infra"],"title":"Ansible 簡介（introduction）","uri":"/posts/ansible/ansible_note01/"},{"categories":["Infra"],"content":"inventory 基本上我們會建立一個 inventory 目錄來存放遠端設備的相關資訊。 並依據不同的設備名稱，儲存不同的資訊： ### inventory/webserver.ini [webservers] testserver ansible_port=2222 [webservers:vars] ansible_host = 192.168.0.1 ansible_user = user ansible_private_key_file = /path/of/private_key Note ansible 支援 ssh-agent，所以我們不需要明確指定密鑰。 接著我們就可以進行測試，像是連結到遠端伺服器並使用 ping： $ ansible testserver -i inventory/vagrant.ini -m ping ","date":"2022-04-19","objectID":"/posts/ansible/ansible_note01/:7:0","tags":["Ansible","Infra"],"title":"Ansible 簡介（introduction）","uri":"/posts/ansible/ansible_note01/"},{"categories":["Infra"],"content":"ansible.cfg 然而在上一節最後的部分，那個指令還是太長了，我們還是要記一些參數才能使用。 透過預先設定好的 ansible.cfg，我們在往後使用時可以更加快速。 ansible.cfg 通常會建議與 playbook 放在一起，這樣做版本控制時較好管理。 [defaults] inventory = inventory/webserver.ini host_key_checking = False stdout_callback = yaml callback_enabled = timer 接著我們就可以用這個方式連結到遠端伺服器並使用 ping： $ ansible testserver -m ping ","date":"2022-04-19","objectID":"/posts/ansible/ansible_note01/:8:0","tags":["Ansible","Infra"],"title":"Ansible 簡介（introduction）","uri":"/posts/ansible/ansible_note01/"},{"categories":["Infra"],"content":"一些參數 透過 command，我們可以在遠端設備上執行指令： ### 這樣遠端設備上會執行 uptime $ ansible testserver -m command -a uptime 如果說我們的指令有空格，請使用雙引號傳送整個字串： $ ansible testserver -m command -a \"tail /var/log/syslog\" 如果說這個指令需要 root 權限，請加上 -b $ ansible testserver -m command -b -a \"tail /var/log/syslog\" ","date":"2022-04-19","objectID":"/posts/ansible/ansible_note01/:9:0","tags":["Ansible","Infra"],"title":"Ansible 簡介（introduction）","uri":"/posts/ansible/ansible_note01/"},{"categories":["Infra"],"content":"小結論 基本上介紹了 Ansible 的基本概念，包括它如何與遠端設備連線以及它與其他配置管理工具的不同之處。 剛開始都先確保環境沒問題之後，進行 1 對 1 的連線測試，完成後再進行後續的學習。 ","date":"2022-04-19","objectID":"/posts/ansible/ansible_note01/:10:0","tags":["Ansible","Infra"],"title":"Ansible 簡介（introduction）","uri":"/posts/ansible/ansible_note01/"},{"categories":["Infra"],"content":"參考資料 Ansible: Up and Running: Automating Configuration Management and Deployment the Easy Way (3rd edition) ","date":"2022-04-19","objectID":"/posts/ansible/ansible_note01/:11:0","tags":["Ansible","Infra"],"title":"Ansible 簡介（introduction）","uri":"/posts/ansible/ansible_note01/"},{"categories":["Infra"],"content":"簡單介紹 Github Actions，因為有人看了星期一就憂鬱那篇文章而詢問 Github Actions 的使用，故想說透過這次機會簡單介紹下。 ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:0:0","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"簡介 Github Actions 可以用來自動化、自定義和執行您的軟體開發工作流程。 許多人用來做 CI/CD 使用，透過 Github Actions 進行程式的建構與測試，並進行相關的部署。 在 Github 上，可以透過 push, create issue 或是排程的方式啟動 workflow。 並提供了多種 Runner，依據不同的需求使用不同的 Runner，能夠輕易的在不同的平台上做測試或是建構。 使用上也可以透過 log 觀察運作的情形並進行修改；且提供了 secret 的功能，讓一些需要 token 或是 key 的應用能夠安全的運作。 Github Actions 也有相關的社群，且能夠透過 Marketplace 取得其他開發者設計完成的 Actions，或者是發布自己的 Actions。 簡單來說，Github 給你一個平台，你可以在上面進行 CI/CD。 Warning Github Actions 有使用時間與容量限制，使用上請注意。(Billing for Github Actions) ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:1:0","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"基本使用 ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:2:0","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"建立 workflow 基本上點選專案上方的 Actions，會進入到這個畫面： 修改前的檔案\" 修改前的檔案 Github 會推薦給您一些 Actions，如果有需要的人可以點選做使用，就不必再重造一次輪子，但這次是要做個簡單介紹與使用，這邊我們點選上方的 set up a workflow yourself。會提供一個範例檔案： # This is a basic workflow to help you get started with Actionsname:CI# Controls when the workflow will runon:# Triggers the workflow on push or pull request events but only for the master branchpush:branches:[master ]pull_request:branches:[master ]# Allows you to run this workflow manually from the Actions tabworkflow_dispatch:# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs:# This workflow contains a single job called \"build\"build:# The type of runner that the job will run onruns-on:ubuntu-latest# Steps represent a sequence of tasks that will be executed as part of the jobsteps:# Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it- uses:actions/checkout@v3# Runs a single command using the runners shell- name:Run a one-line scriptrun:echo Hello, world!# Runs a set of commands using the runners shell- name:Run a multi-line scriptrun:|echo Add other actions to build, echo test, and deploy your project.當滿足 push 或是 pull_request 時，都會在 Github actions 內看到相關的資訊與 echo 出來的文字。 基本上我會把這個 main.yml 分成三個部分： name on job name : 代表這個 workflow 的名稱，就單純是個名稱，這個欄位可以省略不寫，省略時會使用 *.yml 的名稱。 on : 控制這個 workflow 如何觸發或是何時要運作。 job : 就是我們希望他能幫我們運作的工作，job 可以依序進行，或是以平行方式同時進行。 除了 name 以外， on 與 jobs 會簡單介紹與使用。 ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:2:1","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"on 觸發方式有很多種，我目前是比較常使用 schedule 與 push 兩種方式。 schedule 通常會搭配 cron 做排程使用，但我自己的經驗是觸發時間不太準確，如果專案很在意觸發時間的請使用其他方式。 push 則是當你推送內容至 branch 時，就會觸發，我編輯 yaml 並測試時是採用這個方式進行測試。 on:push:branches:[\"main\"]schedule:- cron:'0 1 * * 1'Github 有個說明文件提供了可使用的觸發方法：Events that trigger workflows cron 的使用方式，就像你在 Linux 上使用 crontab 是一樣的，這邊提供時間設定的方式參考：crontab guru ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:2:2","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"jobs 由許多個 step 所組成，step 則是實際要運作的指令，job 之間是平行處理，若 job 之間有依賴性，需要透過 need 進行設定。 如下列的程式碼， deploy 需要等待 build 完成後才會進行。 進一步的話可以透過 if 判斷要依賴的 jobs 的狀態再進一步處理。 jobs:build:steps:// steps, steps and steps.deploy:needs:buildif:needs.build.result == 'success'steps:// steps, steps and steps.另外，我們使用的 runner 也是在這邊透過 runs-on 做設定： jobs:build:runs-on:ubuntu-latestruns-on 可以設定要使用 Github 提供的 runner 其中之一，或是自行提供相關設備連線進行使用。 關於更多 runs-on 的使用方式，可以參考官方文件：Hosting your own runners ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:2:3","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"steps 基本上運行 steps 都會先建議用一次 actions/checkout，看設定是否有問題，這邊我們會透過 uses: actions/checkout@v3 做這件事情，uses 可以讓我們使用在 github 上，其他開發者寫好的 action。 Tips 有些 actions 在 actions/checkout@v3 會發生問題，可以採用 actions/checkout@v2 ，或是看用的 actions 是否有釋出新版本來解決這個問題。 或是自行定義，以 github 提供的範本做說明： - name:Run a one-line scriptrun:echo Hello, world!我定義了一個名稱為 Run a one-line script 的 workflow，並讓他執行 echo Hello, world! 這行指令。 當我們透過這種方式定義時，還可以使用一些參數協助設定，像是從 secrets 中取出我們的 secret 並放到環境變數中。(env) - name:Export Variablesenv:BEARER_TOKEN:${{ secrets.TWITTER_BEARER_TOKEN }}或是透過 with 加入更多的變數做使用。 - name:send tweet content for telegram messageuses:appleboy/telegram-action@master# These are environments secrets.with:to:${{ secrets.TELEGRAM_TO }}token:${{ secrets.TELEGRAM_TOKEN }}message:${{ steps.tweet.outputs.result }}更多 workflow 的使用方式，可以參考官方文件：Using workflows ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:3:0","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"Secret 有一些敏感的資訊，不能放在程式碼內，因為會被他人看到進而被做其他利用。 Github 提供了 secret 的功能，讓我們可以存放這些敏感資訊並使用。 進入專案的 setting，並點選左側的 Secret 標籤即可設定。 修改前的檔案\" 修改前的檔案 secret 分成兩種： Environment secrets Repository secrets Environment secrets 主要是給 Github actions 作為環境參數使用，而 Repository secrets 則是給 Repository 做使用。 依據需求建立即可，另外設定好的 secrets 自己要另外儲存一份，因為儲存過後的 secrets 就真的是秘密，看不到了！ ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:4:0","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"參考資料 Github Actions Events that trigger workflows crontab guru Hosting your own runners GitHub Marketplace · Actions to improve your workflow ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:5:0","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Misc"],"content":"簡單分享一下看完 Learning Go 的心得，與未來對該語言的想法。 ","date":"2022-03-30","objectID":"/posts/misc/learning_go_summary/:0:0","tags":["Misc"],"title":"Learning Go 讀後感(Summary)","uri":"/posts/misc/learning_go_summary/"},{"categories":["Misc"],"content":"心得 因為 Hugo 的關係，體會到 Go 的速度非常快，且有一些有名的專案(Docker, K8s, Terraform) 是由 Go 實現的，故才會想花些時間去了解 Golang。 基本上對於 Go 的使用方法有一定的了解，雖然從 interface 就認為有點苦手，但後面的像是 standard library 或是 test 等，基本上還算可以理解。 後續花時間寫自己想做的東西，應該能了解的快一些吧。 ","date":"2022-03-30","objectID":"/posts/misc/learning_go_summary/:1:0","tags":["Misc"],"title":"Learning Go 讀後感(Summary)","uri":"/posts/misc/learning_go_summary/"},{"categories":["Misc"],"content":"未來 在我閱讀這本書，與撰寫筆記的這段期間，Go 釋出了 1.18 的更新，我認為很重要的兩項： 泛型(Generics) 模糊測試(Fuzzing) 書裡面是有 Generics ，原先想說還沒發佈，且我現在是使用 1.15 版，就想說等發佈了再看。之後補上 另外像 Concurrency 與 Context，以及一些欠債要還的資訊(e.g. garbage collector) 都會再補上。 還有我在第八篇說過，後面品質不太好的部分，都會再做補充。如果有空 過一陣子再回來看自己寫的，也會比較容易發現說當初哪裡寫得不太恰當或是錯誤的，再行修改。 不過，會暫時休息，換去網路跑道跑一陣子之後再回來繼續學習。 感謝自己這陣子願意花時間去學習 golang。 所以我就帶自己去吃個小螃蟹(?\" 所以我就帶自己去吃個小螃蟹(? ","date":"2022-03-30","objectID":"/posts/misc/learning_go_summary/:2:0","tags":["Misc"],"title":"Learning Go 讀後感(Summary)","uri":"/posts/misc/learning_go_summary/"},{"categories":["Misc"],"content":"參考資料(Reference) Learning Go (書籍) Go 1.18 is released! ","date":"2022-03-30","objectID":"/posts/misc/learning_go_summary/:3:0","tags":["Misc"],"title":"Learning Go 讀後感(Summary)","uri":"/posts/misc/learning_go_summary/"},{"categories":["Go"],"content":"簡單說明 reflect, unsafe 與 cgo。 ","date":"2022-03-26","objectID":"/posts/go/go_note14/:0:0","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/go_note14/"},{"categories":["Go"],"content":"Reflect Go 是靜態強型態語言，因此類型是 Go 很重要的一個部分。 但有些時候我們會不清楚該資料的型態，或是想設計支援多個類型的函式，Go 提供了 Reflect 讓我們在程式運作中檢查類型，甚至能進一步修改與建立函式、結構的能力。 一個很經典的例子： fmt.Println ","date":"2022-03-26","objectID":"/posts/go/go_note14/:1:0","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/go_note14/"},{"categories":["Go"],"content":"TypeOf 我們可以用 TypeOf 取得類型的名稱，但像 slice 或是 map 等指標類型，會回傳一個空字串 \"\"。 var v int vType := reflect.TypeOf(v) fmt.Println(vType.Name()) // Output int Kind 會回傳類型是由什麼組成的，通常用在 slice 或是 map 等指標類型。 有些類型引用了其他類型，我們可以透過 Elem 找出被引用的類型是什麼： var v int vType := reflect.TypeOf(\u0026v) fmt.Println(vType.Name()) fmt.Println(vType.Kind()) fmt.Println(vType.Elem().Name()) fmt.Println(vType.Elem().Kind()) reflect 也可以反映結構，透過 NumField 取得架構內部的字段個數，並透過 Field 取得架構內的字段，如果架構內有 tag 的話，可以透過 Get 取得 tag 的資訊： type Foo struct { A int `myTag:\"value\"` B string `myTag:\"value2\"` } var f Foo ft := reflect.TypeOf(f) for i := 0; i \u003c ft.NumField(); i++ { curField := ft.Field(i) fmt.Println(curField.Name, curField.Type.Name(), curField.Tag.Get(\"myTag\")) } ","date":"2022-03-26","objectID":"/posts/go/go_note14/:1:1","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/go_note14/"},{"categories":["Go"],"content":"Value 我們可以透過 reflect.ValueOf 實現 reflect.Value: vValue := reflect.ValueOf(v) 透過這個與 Set，我們也可以用來設定變數的數值： i := 10 iv := reflect.ValueOf(\u0026i) ivv := iv.Elem() ivv.SetInt(20) ","date":"2022-03-26","objectID":"/posts/go/go_note14/:1:2","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/go_note14/"},{"categories":["Go"],"content":"New New 透過 Type 返回一個指定類型的 pointer，我們可以透過修改這個 pointer 與使用 Interface 將修改過後的數值給一個變數： package main import ( \"fmt\" \"reflect\" ) func main() { a := 1 intPtr := reflect.New(reflect.TypeOf(a)) intPtr.Elem().SetInt(2) b := intPtr.Elem().Interface().(int) fmt.Println(b) } ","date":"2022-03-26","objectID":"/posts/go/go_note14/:1:3","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/go_note14/"},{"categories":["Go"],"content":"Unsafe unsafe，可以讓我們操作記憶體，反過來說，操作記憶體不安全，所以叫做 unsafe。 為何要使用 unsafe 呢？ 許多 package 內使用過。 大部分是要操作系統而使用。 使用 unsafe 可以有更好的 performance。 基本上有三種函數與一種類型： SizeOf : 回傳變數所使用的記憶體大小 AlignOf : 回傳在記憶體中進行記憶體對齊需要的倍數。 OffsetOf : 回傳兩個變數之間的位址差距。 unsafe.pointer : 任何類型的 pointer 都可以轉換為 unsafe.Pointer ","date":"2022-03-26","objectID":"/posts/go/go_note14/:2:0","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/go_note14/"},{"categories":["Go"],"content":"cgo C 語言已經有很久的歷史，但至今仍是重要的程式語言之一。許多的作業系統是以C/C++實現的，這也意味著許多程式語言都提供了使用 C 的函式庫之方法（FFI）。 Go 語言將這個外部函數介面稱為 cgo。 基本上要先 import \"C\"，這行會讓 Go 編譯前先運行 cgo。cgo 會運行與前面有關的註解。並將 C 的程式碼( .c, .h )放置到同一個目錄中，另外要安裝 C 的編譯器，最後再透過 go build 即可。 package main import \"fmt\" /* #cgo LDFLAGS: -lm #include \u003cstdio.h\u003e #include \u003cmath.h\u003e #include \"mylib.h\" int add(int a, int b) { int sum = a + b; printf(\"a: %d, b: %d, sum %d\\n\", a, b, sum); return sum; } */ import \"C\" func main() { sum := C.add(3, 2) fmt.Println(sum) fmt.Println(C.sqrt(100)) fmt.Println(C.multiply(10, 20)) } 不過因為兩種語言的不同之處，cgo 在使用上有極大機率造成效能降低： Go 會收集 garbage，但 C 不會。 一些以 pointer 傳遞的類型無法在兩種語言之間運作。 部分 C library 不支援(e.g. printf)。 除非是已經有一個很好的 C 函式庫需要使用，不然不建議使用。 ","date":"2022-03-26","objectID":"/posts/go/go_note14/:3:0","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/go_note14/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) StackOverFlow - How do you create a new instance of a struct from its type at run time in Go? ","date":"2022-03-26","objectID":"/posts/go/go_note14/:4:0","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/go_note14/"},{"categories":["Go"],"content":"簡單說明如何進行程式碼測試，介紹檢查代碼覆蓋率與編寫基準測試。 ","date":"2022-03-25","objectID":"/posts/go/go_note13/:0:0","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/go_note13/"},{"categories":["Go"],"content":"Basic 測試分成兩個部分： package : testing tool : go test testing 提供了測試的類型與函數，而 go test 則是將相關工具綁在一起進行測試後產生報告。 另外， Go 的測試與程式碼會放在同一個目錄，或是同一個 package 當中，也因為在同一個 package 中，所以可以測試未導出的變數與函數。 一個簡單的測試，先寫好一個要被測試的函數，並存放在 adder/adder.go 中： package adder func addNumbers(x, y int) int { return x + x } 每個測試都寫在一個以 _test.go 結尾的檔案中。 因此，測試會放在 adder/adder_test.go： package adder import ( \"testing\" ) func Test_Adder(t *testing.T){ result := addNumbers(2,3) if result != 5{ t.Error(\"incorrect result\") } } 測試函數開頭，會以 Test 為開頭，並傳入 *testing.T。 測試函數不會返回任何數值。這個測試中會使用 t.Error 返回錯誤訊息，用法與 fmt.Println 類似。 完成之後使用 go test 進行測試： $ go test PASS ok test_examples/adder 0.006s ","date":"2022-03-25","objectID":"/posts/go/go_note13/:1:0","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/go_note13/"},{"categories":["Go"],"content":"測試失敗 剛剛使用的 t.Error 是報告的其中一個方法，也可使用 t.Errorf 格式化輸出。 另外也可以使用 t.Fatal或是 t.Fatalf，它會在錯誤發生時，中斷測試，而使用 t.Error 則不會。 看自己要怎麼應用測試而使用。 ","date":"2022-03-25","objectID":"/posts/go/go_note13/:1:1","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/go_note13/"},{"categories":["Go"],"content":"TestMain 有時候在測試時，要先設定一些環境或變數再開始進行測試，透過 TestMain 可以讓我們在測試前或測試後做一些事情，像是我要從 database 或是外部撈數據之後，透過這些事情的結果再進行測試。 var testTime time.Time func TestMain(m *testing.M) { fmt.Println(\"Set up stuff for tests here\") testTime = time.Now() exitVal := m.Run() fmt.Println(\"Clean up stuff after tests here\") os.Exit(exitVal) } func TestFirst(t *testing.T) { fmt.Println(\"TestFirst uses stuff set up in TestMain\", testTime) } func TestSecond(t *testing.T) { fmt.Println(\"TestSecond also uses stuff set up in TestMain\", testTime) } 我們建立了一個 TestMain，在裡面初始化了需要使用的變數，完成後使用 Run 去執行 test，這時就會開始進行測試。 要注意一點是，最後必須從 Run 裡面使用 os.Exit 來結束測試。 TestMain 他不會單獨的在測試函式前後執行，另外要注意的是，每個 package 內只能有一個 TestMain。 ","date":"2022-03-25","objectID":"/posts/go/go_note13/:2:0","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/go_note13/"},{"categories":["Go"],"content":"testdata Go 有保留這個目錄名稱，作為存放初始測試資料的目錄，從這個目錄存取檔案時，請使用相對路徑。 ","date":"2022-03-25","objectID":"/posts/go/go_note13/:2:1","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/go_note13/"},{"categories":["Go"],"content":"測試 public api 前面我們提到過，函數的大小寫字首決定他是否為 public，如果我們只想測試 public api，透過下列的方法即可，一樣會以前面的 adder 為例子。 adder.go package adder // public : 字首大寫 func AddNumbers(x, y int) int { return x + x } adder_test.go // Package 的名稱後面加上 _test package adder_test import ( \"testing\" // 導入 adder，使用時注意路徑 \"adder\" ) func Test_Adder(t *testing.T){ result := adder.AddNumbers(2,3) if result != 5{ t.Error(\"incorrect result\") } } ","date":"2022-03-25","objectID":"/posts/go/go_note13/:2:2","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/go_note13/"},{"categories":["Go"],"content":"Code Coverage Code Coverage 可以幫助我們了解，程式中是否有遺漏明顯的地方，雖然覆蓋率 100% 不代表程式運作 100% 正常，但至少可以降低錯誤發生的機率(吧) 透過 go test -v -cover 可以顯示覆蓋率，如果再加上 -coverprofile=[filename] 可以把訊息輸出。 $ go test -v -cover -coverprofile=test.out 輸出後可以用 html 的方式開啟，會告訴你哪邊有被覆蓋，哪邊尚未被覆蓋。 $ go tool cover -html=test.out ","date":"2022-03-25","objectID":"/posts/go/go_note13/:3:0","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/go_note13/"},{"categories":["Go"],"content":"Benchmarks 當我們的程式都沒問題了之後，下一步要測試的可能是程式的快慢，Go 提供了 test_examples/bench 讓我們可以進行一些基準測試： 要以 Benchmark 作為開頭。 接收一個 *testing.B 類型的參數 func BenchmarkSay(b *testing.B){ for i:= 0; i\u003c b.N; i++ { adder.Say(\"Hi\") } } 每個 Go 基準測試都必須有一個從 0 迭代到 b.N，測試框架一遍又一遍地用越來越大的 N 值調用我們的基準函數，直到確定計時結果準確為止。 測試時使用 -bench=. 執行所有的基準測試，再加上 -benchmem 會顯示記憶體的資訊。 如果測試程式中有一般的測試(*testing.T)與基準測試，則會先執行一般的測試再進行基準測試。 $ go test -bench=. -benchmem goos: darwin goarch: amd64 pkg: adder BenchmarkSay-4 2 512890848 ns/op 48 B/op 1 allocs/op PASS ok adder 1.555s BenchmarkSay-4 : 名稱 2 : 測試運行已產生穩定結果的次數 512890848 ns/op : 執行一次測試需要花費的時間 48 B/op : 每次測試使用的記憶體空間 1 allocs/op : 每次測試發生了多少由 heap 分配的次數。 ","date":"2022-03-25","objectID":"/posts/go/go_note13/:4:0","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/go_note13/"},{"categories":["Go"],"content":"Stubs 因為函數之間通常會有依賴關係，在測試中可能會因為某個函數需要前一個動作處理後的結果，才能進行測試，比方說，我需要從 database 取得資料，故我要先與 database 進行連線，但我只是要測試取得資料這個函式而已，能不能不要與 database 進行連線？ 在前面我們提到了 function type 與 interface type，我們可以透過這兩種類型降低測試時的函式依賴。 範例待補 ","date":"2022-03-25","objectID":"/posts/go/go_note13/:5:0","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/go_note13/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) ","date":"2022-03-25","objectID":"/posts/go/go_note13/:6:0","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/go_note13/"},{"categories":["Go"],"content":"本篇文章將簡單介紹 Standard Library 內的幾個較重要的 package，像是io, time, encoding/json, net/http。 ","date":"2022-03-24","objectID":"/posts/go/go_note11/:0:0","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/go_note11/"},{"categories":["Go"],"content":"io io 是個很常被使用的 package，尤其是 io.Reader 與 io.Writer。 看到 er 結尾了嗎？所以他應該是… interface ? type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } Read 會將資料讀入 p，一個 byte 類型的 slice，並傳回讀取的 byte 數量，也就是 n，另外還會返回遇到的錯誤。 Write 則會將 p 輸出並回傳寫入的 byte 數量與遇到的錯誤。 io.reader 表示 data stream 的讀取端，標準函式庫已經有許多包含此 interface 的 implement。當 stream 結束時會返回 io.EOF 的錯誤。 package main import ( \"fmt\" \"io\" \"strings\" ) func main() { r := strings.NewReader(\"Hello, Reader!\") b := make([]byte, 8) for { n, err := r.Read(b) fmt.Printf(\"n = %v err = %v b = %v\\n\", n, err, b) fmt.Printf(\"b[:n] = %q\\n\", b[:n]) if err == io.EOF { break } } } io.writer 則是反過來，把 data 寫進 stream。 package main import ( \"fmt\" \"os\" ) func main() { f, err := os.OpenFile(\"/tmp/123.txt\", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0600) if err != nil { panic(err) } defer f.Close() // Here n, err := f.Write([]byte(\"writing some data into a file\")) if err != nil { panic(err) } fmt.Println(\"wrote %d bytes\", n) } 另外，io 還有一些像是 io.Closer, io.seeker 等 interface。使用上其實都很容易。 ","date":"2022-03-24","objectID":"/posts/go/go_note11/:1:0","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/go_note11/"},{"categories":["Go"],"content":"ioutil ioutil 則實現了更多更方便的函數。 ReadAll : 一次性讀取 io.reader 內的數據。 ReadDir : 讀取目錄底下所有的文件與子資料夾名稱。 ReadFile : 讀取檔案。 WriteFile : 寫入檔案。 還有一些像是 TempDir, TempFile 等函數，有興趣的可以用 go doc ioutil 觀看。 ","date":"2022-03-24","objectID":"/posts/go/go_note11/:1:1","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/go_note11/"},{"categories":["Go"],"content":"time 基本上有兩種類型表示時間： time.Duration time.Time time.Duration 用來表示一段時間，基於 int64 實現的，也可以使用 time.ParseDuration，用字串來表示時間。 例如我寫這篇文章花費了五小時又三十分鐘： cost := 5 * time.Hour + 30 * time.Minute costStr, _ := time.ParseDuration(\"5h30m\") 另外，time.Duration 已經滿足了 fmt.Stringer，所以會返回一個格式化過的字串。 fmt.Println(cost) // Output 5H30M0S time.Time，可以用使用 time.Now 取得現在時間，或是填入想設定的時間 type Time struct{ ... } func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time func Now() Time 最後，Go 是使用 monotonic clock 來跟蹤時間的。 ","date":"2022-03-24","objectID":"/posts/go/go_note11/:2:0","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/go_note11/"},{"categories":["Go"],"content":"Timer and Ticker Timer 基本上就是計時器，通常用在 select 對於多個 channel 的超時，或是一些讀寫行為的超時情形，他是一次性的，這也是與 Ticker 不同的地方，Ticker 是每隔一段時間就進行一次。 type Timer struct{ ... } func AfterFunc(d Duration, f func()) *Timer func NewTimer(d Duration) *Timer type Ticker struct{ ... } func NewTicker(d Duration) *Ticker ","date":"2022-03-24","objectID":"/posts/go/go_note11/:2:1","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/go_note11/"},{"categories":["Go"],"content":"encoding/json RESTful API 讓 json 成為資料傳遞的重要格式，也因此 Go 也支援將 Go 的數據類型轉換成 json，或是由 json 轉換回來。 假設說我們有筆 json 資料： { \"id\":\"12345\", \"date_ordered\":\"2020-05-01T13:01:02Z\", \"customer_id\":\"3\", \"items\":[{\"id\":\"xyz123\",\"name\":\"Thing 1\"},{\"id\":\"abc789\",\"name\":\"Thing 2\"}] } 那我們就需要建立 struct 去對應名稱與類型，進行轉換。 type Order struct { ID string `json:\"id\"` DateOrdered time.Time `json:\"date_ordered\"` CustomerID string `json:\"customer_id\"` Items Item `json:\"items\"` } type Item struct { ID string `json:\"id\"` Name string `json:\"name\"` } 有一些地方要注意的： 名稱前要加上 json 標籤。 要使用反引號刮起來。 如果輸出 json 時，因為某些欄位沒有數值而要忽略某些欄位，請在後方加上 ,omitempty type Item struct { ID string `json:\"id\"` Name string `json:\"name,omitempty\"` } 使用 ,omitempty 要注意到 struct 的 zero value 不是代表空值，所以 ,omitempty 仍然會轉換成 json，如果 struct 內部有 struct 類型的資料，又想在沒資料時忽略該欄位，請在 struct 上使用 pointer。 type Order struct { ID string `json:\"id\"` DateOrdered time.Time `json:\"date_ordered\"` CustomerID string `json:\"customer_id\"` Items *Item `json:\"items\"` } type Item struct { ID string `json:\"id\"` Name string `json:\"name\"` } ","date":"2022-03-24","objectID":"/posts/go/go_note11/:3:0","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/go_note11/"},{"categories":["Go"],"content":"編碼與解碼 透過 json.Unmarshal 與 json.Marshal 進行 json 與 struct 之間的轉換。 json.Unmarshal 可以把 json 字串轉成 struct，而 json.Marshal 可以將 struct 轉成 json。 var o Order err := json.Unmarshal([]byte(data), \u0026o) if err != nil { return err } out, err := json.Marshal(o) 另外也可以透過 json.Decoder 與 json.Encoder ，對檔案進行解碼與編碼，這樣就可以用 io.Reader 與 io.Writer 進行 io 讀取與寫入的操作。 err1 = json.NewEncoder(tmpFile1).Encode(toFile) err2 = json.NewDecoder(tmpFile2).Decode(\u0026fromFile) ","date":"2022-03-24","objectID":"/posts/go/go_note11/:3:1","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/go_note11/"},{"categories":["Go"],"content":"net/http 我覺得 go 提供的一個很棒的 package，它可以讓我們開發 http server 與 client 相關的程式！！ ","date":"2022-03-24","objectID":"/posts/go/go_note11/:4:0","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/go_note11/"},{"categories":["Go"],"content":"Client 我們可以建立一個 http.Client，並透過 http.Request 等方式進行用戶端的需求。如果說沒有 context 要傳送的話，請記得使用 nil。 Method 也有常見的 GET, POST, PATCH 可以使用。 client := \u0026http.Client{ Timeout: 30 * time.Second, } req, err := http.NewRequestWithContext(context.Background(), http.MethodGet, \"https://google.com\", nil) if err != nil { panic(err) } 我們也還可以添加一些關於 header 的資訊，添加後使用 Do 去處理，會得到相對的 response： req.Header.Add(\"X-My-Client\", \"Learning Go\") res, err := client.Do(req) if err != nil { panic(err) } Response 則會有許多資料： status statusCode header body ","date":"2022-03-24","objectID":"/posts/go/go_note11/:4:1","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/go_note11/"},{"categories":["Go"],"content":"Server Server 的用途就是監聽 http 的請求，另外他也支援 tls 與 http/2。好神 package main import ( \"fmt\" \"net/http\" ) func indexHandler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"hello world\") } func main() { http.HandleFunc(\"/\", indexHandler) http.ListenAndServe(\":8080\", nil) } 這樣我們會在 “/” 上面建立一個 indexHandler，當有 Request 時，則會進行 ResponseWriter ，產生 response。 但這樣子只能處理單個 request，因此標準函式庫內有一個請求路由器 (*http.ServeMux)，並透過 http.NewServeMux 實現，透過ServeMux，我們可以傳入路徑與 handler，當 mux 收到對應的請求時，會根據路徑而使用對應的 handler 進行處理。 package main import ( \"net/http\" ) func main() { cat := http.NewServeMux() cat.HandleFunc(\"/voice\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"meow!\\n\")) }) dog := http.NewServeMux() dog.HandleFunc(\"/voice\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"wow!\\n\")) }) mux := http.NewServeMux() mux.Handle(\"/cat/\", http.StripPrefix(\"/cat\", cat)) mux.Handle(\"/dog/\", http.StripPrefix(\"/dog\", dog)) http.ListenAndServe(\":3000\", mux) } ","date":"2022-03-24","objectID":"/posts/go/go_note11/:4:2","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/go_note11/"},{"categories":["Go"],"content":"補充 更多的使用方式，go doc [package name] 或是問 Google，畢竟標準函式庫提供了不少函式可以使用… ","date":"2022-03-24","objectID":"/posts/go/go_note11/:5:0","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/go_note11/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) An Introduction to Handlers and Servemuxes in Go Golang 的 “omitempty” 关键字略解 Golang Reader Example ","date":"2022-03-24","objectID":"/posts/go/go_note11/:6:0","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/go_note11/"},{"categories":["Go"],"content":"本篇文章將簡單介紹 Concurrency，並說明 goroutine, channel 和 select。 ","date":"2022-03-23","objectID":"/posts/go/go_note10/:0:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/go_note10/"},{"categories":["Go"],"content":"Concurrency 可能有聽過 “asynchronous”,“Parallelism” 或是 “threaded”，雖然很像但有點不太一樣。 主要可以解釋成，一個或多個 processes 同時發生的 process，好比說你正在看我的筆記，而其他人正在世界上做自己的事情，這些人同時與您存在。 但我認為一樣的都是，很難正確處理。 ","date":"2022-03-23","objectID":"/posts/go/go_note10/:1:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/go_note10/"},{"categories":["Go"],"content":"什麼時候使用 首先要確定，使用並發會讓效能變好再使用，因為並發並不是並行(Parallelism)，過多的並發只會導致程式難以理解，並發的數量也不會與效能成真正的正比關係。 基本上程式的邏輯是： 獲取數據 計算 輸出結果 基本上要使用並發，取決於數據如何通過程式的步驟流動，有時候多個步驟可以並發，因為他們沒有需要別的步驟執行後才能執行，反過來說，如果步驟是像串聯一般地執行，則不應使用並發。 另外，如果並發運行的程式不會花費太多時間，也不推薦使用並發，因為硬體資源並不是免費的，如果不確定使用並發會不會提升效能，可以透過寫測試的方式驗證。 ","date":"2022-03-23","objectID":"/posts/go/go_note10/:1:1","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/go_note10/"},{"categories":["Go"],"content":"Goroutine Goroutine 是 Go 在運行時管理的輕量化 processes。 當程式啟動時，運行中會建立許多 thread 並運行一個 goroutine 來運行我們所寫的程式。 程式所建立的所有 goroutine（包含一開始的），都會由 go 去調度並分配給 thread，類似我們設計跨 CPU kernel 的程式。 但作業系統已經能做到這件事，為什麼 Go 還要再實現類似的機制呢？ Goroutine 建立的比 thread 還快。 Goroutine 初始化 stack 比 thread stack 還小，代表相同的記憶體空間下可以放更多的 goroutine。 Goroutine 之間切換的速度比 thread 還快，因為 Goroutine 完全發生在 process 內。 Go 有 scheduler 能做最佳化。 ","date":"2022-03-23","objectID":"/posts/go/go_note10/:2:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/go_note10/"},{"categories":["Go"],"content":"如何使用 我們在函數前面輸入 go 就能夠啟動了，只是這個函式的返回值會被忽略。 任何函式都能夠這樣子啟用並發，但通常會在 closure 內執行，這樣會使程式較容易測試與模組化，並使得 API 不具有並發性。 // 我們要並發的函式 func process(val int) int { // do something with val } // 透過一個函式去呼叫 func runThingConcurrently(in \u003c-chan int, out chan\u003c- int) { // closure go func() { for val := range in { result := process(val) out \u003c- result } }() } ","date":"2022-03-23","objectID":"/posts/go/go_note10/:2:1","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/go_note10/"},{"categories":["Go"],"content":"Channel goroutine 透過 channel 進行溝通。 聲明 chan 後透過 make 實現： ch := make(chan int) channel 是參考類型(reference)，與 map, slice一樣，傳遞時是傳遞 channel 的 pointer。 channel 的 zero value 是 nil。 ","date":"2022-03-23","objectID":"/posts/go/go_note10/:3:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/go_note10/"},{"categories":["Go"],"content":"讀取與寫入 透過一個 \u003c-運算符進行讀取與寫入的動作，與C++的 -\u003e 是相反過來的。 a := \u003c-ch // reads a value from ch and assigns it to a ch \u003c- b // write the value in b to ch 另外我們也可以用 for-range 從 channel 中讀取，這種讀取方式，會一直持續到 channel 關閉，或是遇到 break 與 return 才會結束。 for v := range ch { fmt.Println(v) } 每個被寫入 channel 的數值只能被讀取一次。如果有多個 goroutine 從同一個 channel 讀取，寫入 channel 的數值只會被其中一個 goroutine 讀取。 Channel 也可以設定為單向讀取或是單向寫入： var writeOnly chan \u003c- int = ch1 var readOnly \u003c- chan int = ch2 Channel 預設是無緩衝的，每一次寫入了一個開放的無緩衝 channel，都會導致寫入 goroutine 暫停，直到另一個 goroutine 從這個 channel 讀取，反過來說，每一次讀取這個 channel，都會導致讀取 goroutine 暫停，一直到有一個 goroutine 寫入這個 channel，也就是說至少要有兩個 goroutine 才能寫入與讀取 channel。 Go 也有緩衝的 channel，如果在讀取這個 channel 前， channel 的緩衝區已經滿了，則後面的寫入將會暫停寫入，一直到讀取這個 channel 為止。就已經滿了你不給他空間不然你是想怎樣！？ 有緩衝區的 channel 怎麼實現呢？ ch := make(chan int, 10) 最後，大部分的時候會建議使用無緩衝區的 channel。 ","date":"2022-03-23","objectID":"/posts/go/go_note10/:3:1","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/go_note10/"},{"categories":["Go"],"content":"關閉 關閉，就是使用，close。 close(ch) 這樣就能夠關閉 channel，此時再寫入這個 channel 或是再次關閉都會造成 panic，但關閉後的 channel 是可以讀取的，若裡面還有未讀取的值，則會依序返回，如果沒有未讀取的值，則會返回 zero value。 但這樣當我們讀取到 zero value 時，我們要怎麼知道，這個 zero value 是被關閉的 channel 的，還是還沒讀取的值？ 偷看第三篇 v, ok := \u003c-ch ","date":"2022-03-23","objectID":"/posts/go/go_note10/:3:2","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/go_note10/"},{"categories":["Go"],"content":"select select 是並發的控制結構。 透過 select 可以允許 goroutine 讀取或寫入一組多個 channel 中的一個，他用起來很像 switch。 select { case v := \u003c-ch1: fmt.Println(v) case ch2 \u003c- x: fmt.Println(\"wrote\", x) case \u003c-ch3: fmt.Println(\"got value on ch4, but ignored it\") } 如果有多個 case 可以讀取或寫入的話，會發生什麼？ Go 的設計上會隨機選擇一個進行，可以防止飢餓的問題發生，另外也可以預防一種 deadlock 的發生：acquiring locks in an inconsistent order。 因為 select 用來負責讓多個 channel 進行聯繫，因此會用在一個 for-loop 中，這裡也被稱為 for-select 循環，使用 for-select 記得必須要有退出的方法。 for{ select { case v := \u003c-ch1: fmt.Println(v) case ch2 \u003c- x: fmt.Println(\"wrote\", x) case \u003c-ch3: fmt.Println(\"got value on ch4, but ignored it\") } case \u003c-done: return } ","date":"2022-03-23","objectID":"/posts/go/go_note10/:4:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/go_note10/"},{"categories":["Go"],"content":"Remenber 保持 API 沒有並發： 前面也提到了，盡量在 closure 內設計並發，並盡量隱藏，當使用者知道可以使用 API 來執行並發時。摁… 每當您的 goroutine 使用的數值是可能會改變的變量時，請將變量的當前值傳遞給 goroutine。 for _, v := range a { go func(val int) { ch \u003c- val * 2 }(v) } // 下面這個就沒傳值，goroutine內的v會是迴圈結束後的v值 for _, v := range a { go func() { ch \u003c- v * 2 }() } 清理與關閉 goroutine： 如果一個 goroutine 沒有退出，scheduler仍然會定期給它時間，但他可能什麼都不做，這會降低程式的效能。 何時使用緩衝與非緩衝 channel： 當知道已經啟動了多少個 goroutine，想要限制將啟動的 goroutine 的數量，或者想要限制排隊的工作量時，可以使用緩衝 channel。 ","date":"2022-03-23","objectID":"/posts/go/go_note10/:5:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/go_note10/"},{"categories":["Go"],"content":"備註 還有一些像是 Backpressure, sync.Waitgroup, sync.Once 跟 Mutex 的作用與用法想做筆記，但一時之間還想不到該怎麼寫，可能等之後有時間再來補充。 更多關於 Concurrency 的資訊，可以參考 Katherine Cox-Buday 所寫的 Concurrency in Go。（歐萊禮也有這本所以…又是坑） 另外，後續還會有一篇 Context 的筆記，但我會想看完 Concurrency in Go 再來寫筆記分享。 ","date":"2022-03-23","objectID":"/posts/go/go_note10/:6:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/go_note10/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) Concurrency in Go (書籍) Concurrency與Parallelism的不同之處 ","date":"2022-03-23","objectID":"/posts/go/go_note10/:7:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/go_note10/"},{"categories":["Go"],"content":"本篇文章會介紹如何使用 module 與 package 組織程式碼，並如何 import。 ","date":"2022-03-23","objectID":"/posts/go/go_note9/:0:0","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/go_note9/"},{"categories":["Go"],"content":"Repositories, Modules, and Packages Repo 大家應該都很熟悉，版本控制中儲存程式碼的地方。 Modules 像是程式碼或應用程式的根目錄，包括一個或多個 package ，存放在 Repo 中。 如果這個根目錄有 go.mod，則代表這些程式碼的集合為一個 module，這個檔案請由指令去形成： $ go mod init \u003cMODULE_PATH\u003e 裡面則會有 module 的名稱， go 的版本，需要哪些 module 等等的資訊。 ","date":"2022-03-23","objectID":"/posts/go/go_note9/:1:0","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/go_note9/"},{"categories":["Go"],"content":"Import import 可以讓我們使用另一個 package 的 constants, variables, functions 與 types，另外 identifier 是大寫開頭的才能由外部存取，如果是小寫開頭的則只能於內部進行存取，我們很常用的 fmt.Println() 就是一個好例子。 ","date":"2022-03-23","objectID":"/posts/go/go_note9/:2:0","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/go_note9/"},{"categories":["Go"],"content":"Package ","date":"2022-03-23","objectID":"/posts/go/go_note9/:3:0","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/go_note9/"},{"categories":["Go"],"content":"Create Package 透過 package clause 實現，package clause 都會在檔案的第一行，且是非空白的非注釋行。 package test func Plus(a int, b int) int { return a+b } ","date":"2022-03-23","objectID":"/posts/go/go_note9/:3:1","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/go_note9/"},{"categories":["Go"],"content":"Access Package 當我們需要使用自己建立的 package 時，透過前面提到的 import 做使用，如果你不是使用 standard library 內的 package，使用時要注意 package 的 path。 package main import { \"fmt\" \"example/plus\" } func main() { num = test.Plus(1,2) fmt.Println(num) } // Output 3 另外有一些規則要注意： import 是要使用路徑，而不是 import package clause，我自己的話會想說把 package clause 與檔案名稱一致會比較好管理。除了某些情況是不需要一致的。 不要用 main 做 import， main 是程式運作的起點。 不要用一些特別的字元在 path 上。 ","date":"2022-03-23","objectID":"/posts/go/go_note9/:3:2","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/go_note9/"},{"categories":["Go"],"content":"重複 import 有時候會有 import 相同 package clause 的情形發生，例如 crypto/rand 與 math/rand，這樣我們使用 rand 時會有問題。 Go 可以讓我們 import 的 package 有別的名稱，但在維護上可能會有些問題，因為要去了解他是用別名的方式，還是直接 import 進來的。 package main import{ crand \"crypto/rand\" \"math/rand\" } func main(){ // Use crand ... } ","date":"2022-03-23","objectID":"/posts/go/go_note9/:3:3","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/go_note9/"},{"categories":["Go"],"content":"godoc 作為 package 的文件使用，其實就很像在 linux 有疑問時會用 man 或是 -H, --help 一樣。 基本上是程式的註解，沒有特殊的格式與符號。 但有一些規則要注意一下： 將註解放在對象的前面(上一行)，之間並沒有空白行。 以兩個雙斜線開頭，後面要先放對象的名稱。 透過空白行分段。 透過縮排進行註解的格式化。 package clause 則是要以 package clause 作為開頭， function 與 struct 則以名稱開頭即可。 可以實際觀察看看註解要如何撰寫。 $ go doc fmt 另外。在第一篇提到的 golangci-lint 可以幫助找出缺失註解的地方。 ","date":"2022-03-23","objectID":"/posts/go/go_note9/:3:4","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/go_note9/"},{"categories":["Go"],"content":"Modules 透過前面提到的 go mod，我們會得到一個 go.mod 的檔案，裡面可能會紀錄 package 的版本資訊。另外編譯過後，會有一個 go.sum 的檔案，裡面記錄了依賴 package 的 hash。 ","date":"2022-03-23","objectID":"/posts/go/go_note9/:4:0","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/go_note9/"},{"categories":["Go"],"content":"版本控制 我們可以透過 go list ，觀察 module 的版本，並透過 go get 取得較舊的版本。 $ go list -m -versions github.com/learning-go-book/simpletax github.com/learning-go-book/simpletax v1.0.0 v1.1.0 [!] 有v1.0.0 與 v.1.1.0，我想用舊版本... $ go get github.com/learning-go-book/simpletax@v1.0.0 [!] 此時回去看 go.mod 會發現版本已經改變了。 Hint 版本號的規則：major.minor.patch 修復錯誤時，patch 更新，增加新功能時，minor 更新並將 patch 歸零。 ","date":"2022-03-23","objectID":"/posts/go/go_note9/:4:1","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/go_note9/"},{"categories":["Go"],"content":"Vendoring 為了確保從頭到尾都能使用相同的依賴項開發，透過 go mod vendor 可以產生一個目錄，保存所有依賴項的副本。 如果又增加了新的依賴項，或是升級了依賴項，都要再執行一次 go mod vendor，否則會無法編譯。 ","date":"2022-03-23","objectID":"/posts/go/go_note9/:4:2","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/go_note9/"},{"categories":["Go"],"content":"補充 pkg.go.dev 會自動索引開源的 Go project。 ","date":"2022-03-23","objectID":"/posts/go/go_note9/:5:0","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/go_note9/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) ","date":"2022-03-23","objectID":"/posts/go/go_note9/:6:0","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/go_note9/"},{"categories":["Go"],"content":"本篇文章會介紹如何在 Go 中處理錯誤，並簡單提一下 panic 與 recover。 ","date":"2022-03-23","objectID":"/posts/go/go_note8/:0:0","tags":["go","golang"],"title":"Golang - 錯誤(Error)","uri":"/posts/go/go_note8/"},{"categories":["Go"],"content":"前言 基本上這本書已經讀完一半了，給自己個小掌聲！ 但因為近期有些事情要處理，想先把這本書的筆記做完，把這邊的時間給空出來。 如果想說以後再回來寫，依照我的個性應該是會懶得寫… 近期應該會大量生產一堆品質低下的筆記。 (其實本來就沒多好) ","date":"2022-03-23","objectID":"/posts/go/go_note8/:1:0","tags":["go","golang"],"title":"Golang - 錯誤(Error)","uri":"/posts/go/go_note8/"},{"categories":["Go"],"content":"錯誤 Go 會透過 return 一個 error type 的數值，作為函數的最後一個返回值。如果函式正常運作並返回數值，則會返回 nil，如果發生錯誤，當然就會返回錯誤值。 func calcRemainderAndMod(numerator, denominator int) (int, int, error) { if denominator == 0 { return 0, 0, errors.New(\"denominator is 0\") } return numerator / denominator, numerator % denominator, nil } 一些小原則： 錯誤訊息不應該大寫。 不應該以標點符號結尾。 另外， Go 沒有特殊的方法去檢測，是否返回了錯誤，但可以用判斷式去判斷： if err != nil { // TODO } Go 使用返回錯誤的方式設計，而不是使用跳出異常(Exception)，一來是異常處理的方式有時會無法容易掌握，二來是程式碼遇到錯誤時可能不會崩潰，但數值會未正確初始化，修改等。 基本上我們可以使用 error.New() 與 fmt.Errorf() 兩種方式，透過 string 處理簡單的錯誤。 func doubleEven(i int) (int, error) { if i % 2 != 0 { return 0, errors.New(\"only even numbers are processed\") } return i * 2, nil } // OR func doubleEven(i int) (int, error) { if i % 2 != 0 { return 0, fmt.Errorf(\"%d isn't an even number\", i) } return i * 2, nil } ","date":"2022-03-23","objectID":"/posts/go/go_note8/:2:0","tags":["go","golang"],"title":"Golang - 錯誤(Error)","uri":"/posts/go/go_note8/"},{"categories":["Go"],"content":"Sentinel Errors 代表用一個特定值，來表示一個不能進一步處理的做法。 func main() { data := []byte(\"This is not a zip file\") notAZipFile := bytes.NewReader(data) _, err := zip.NewReader(notAZipFile, int64(len(data))) if err == zip.ErrFormat { fmt.Println(\"Told you so\") } } 這個程式代表要讀取 zip 格式，但傳入的參數並不是 zip，因此發生了錯誤，透過一個 ErrFormat代表傳入格式不正確時會發生的錯誤，然而當錯誤太多種時，則需要一個一個去定義錯誤的特定值並比對，撇開麻煩不說，當錯誤比對時，該錯誤沒有在自己定義的比對值，這樣會發生問題。 除了一些極端情況，不然應該會很少用 Sentinel Errors。 ","date":"2022-03-23","objectID":"/posts/go/go_note8/:2:1","tags":["go","golang"],"title":"Golang - 錯誤(Error)","uri":"/posts/go/go_note8/"},{"categories":["Go"],"content":"Error structure error 是一個內置的 interface： type error interface{ Error() string } 所以可以透過這個 interface ，自己定義錯誤訊息： // define status type . type Status int const ( InvalidLogin Status = iota + 1 NotFound ) // define statusErr type. type StatusErr struct { Status Status Message string } func (se StatusErr) Error() string { return se.Message } 這樣就可以透過 StatusErr 定義較多的詳細訊息： func LoginAndGetData(uid, pwd, file string) ([]byte, error) { err := login(uid, pwd) if err != nil { return nil, StatusErr{ Status: InvalidLogin, Message: fmt.Sprintf(\"invalid credentials for user %s\", uid), } } data, err := getData(file) if err != nil { return nil, StatusErr{ Status: NotFound, Message: fmt.Sprintf(\"file %s not found\", file), } } return data, nil } ","date":"2022-03-23","objectID":"/posts/go/go_note8/:2:2","tags":["go","golang"],"title":"Golang - 錯誤(Error)","uri":"/posts/go/go_note8/"},{"categories":["Go"],"content":"Panic and Recover Panic 主要是程式運作時，無法確定接下來應該發生什麼事，就會有 panic 的發生。另外有個內置函數稱為 panic ，可以使用任何類型，通常他會是 string。 func doPanic(msg string){ panic(msg) } 這時候在 CLI 上會顯示一些相關資訊，並執行該函式的延遲函式(defer)，如果他是被其他函式呼叫的，則會往上追蹤，一直到 main 函數為止。 Recover 則是一種處理 panic 的方式，透過 defer 來檢查是否發生了 panic： 這個例子中會發生 panic 而使得程式進入 defer，印出錯誤訊息，但因為 recover 的關係，程式會運作下去。 func div60(i int) { defer func() { if v := recover(); v != nil { fmt.Println(v) } }() fmt.Println(60 / i) } func main() { for _, val := range []int{1, 2, 0, 6} { div60(val) } } 也就是說，recover 會在 panic 發生後讓程式運作下去，很像其他語言的例外處理，但 recover 會不知道為何發生 panic，只會知道發生了 panic 之後應該做的事情。 e.g. 當我打開檔案讀取與寫入，發生 panic 了，透過 recover 會幫我處理像是關閉檔案，或是紀錄下錯誤訊息並繼續運作，而不會因為 panic 發生而導致程式終止。 ","date":"2022-03-23","objectID":"/posts/go/go_note8/:3:0","tags":["go","golang"],"title":"Golang - 錯誤(Error)","uri":"/posts/go/go_note8/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) ","date":"2022-03-23","objectID":"/posts/go/go_note8/:4:0","tags":["go","golang"],"title":"Golang - 錯誤(Error)","uri":"/posts/go/go_note8/"},{"categories":["Go"],"content":"本篇文章會介紹類型、方法和介面。 ","date":"2022-03-15","objectID":"/posts/go/go_note7/:0:0","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/go_note7/"},{"categories":["Go"],"content":"類型(Types) 一種基本上就像我們前面用過的，由開發者自行定義的類型。 type Person struct{ Name string Age int } 另外也可以使用原始類型，甚至是以複合的方式定義類型。 type Score int type Converter func(string)Score type TeamScore map[string]Score 基本上可以在任何的 code block 定義類型，但就只能在該 code block 的範圍內存取，唯一的例外是 exported package block level type。 ","date":"2022-03-15","objectID":"/posts/go/go_note7/:1:0","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/go_note7/"},{"categories":["Go"],"content":"方法(method) ","date":"2022-03-15","objectID":"/posts/go/go_note7/:2:0","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/go_note7/"},{"categories":["Go"],"content":"介紹 聲明方法其實很像聲明函數，只是差在多了一個 receiver specification。 type Person struct{ Name string Age int } func (p Person) String() string { return fmt.Sprintf(\"%s, age %d\", p.Name, p.Age) } receiver 的名稱通常會是該類型的縮寫，通常是該類型的第一個字母。在其他語言中經常是使用 this 或 self。 方法不能重載（overloading），這是 go 語言的特性，或許從其他語言再過來使用時，使用上可能會感到有些限制。 那這是聲明方式，使用方式呢？也很簡單： me := Person { Name : \"Wei\", Age : 26, } output = me.String() ","date":"2022-03-15","objectID":"/posts/go/go_note7/:2:1","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/go_note7/"},{"categories":["Go"],"content":"接收器(receiver) 前面的文章提到過，如果函數使用 pointer 類型的參數，代表這個傳入參數可能會被函式修改，相同的概念一樣在 receiver 上，receiver 有 pointer receiver 與 value receiver 兩種。 決定使用哪種 receiver 可以參考以下規則： 如果這個 method 需要修改 receiver，則必須使用 pointer receiver。 如果這個 method 要處理 nil 的情況，則必須使用 pointer receiver。 如果這個 method 不會修改 receiver，則可以使用 value receiver。 如果這個 type 內的 method 中，有一個以上的 pointer receiver，建議保持一致，讓所有的 method 都使用 pointer receiver。 ","date":"2022-03-15","objectID":"/posts/go/go_note7/:2:2","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/go_note7/"},{"categories":["Go"],"content":"Methods are Function Method 其實就很像前面提到的 Function，我在書中看到一個比較特別的用法是 method expression，直接從 type 中建立一個 function。 type Adder struct { start int } func (a Adder) AddTo(val int) int { return a.start + val } myAdder := Adder{start: 10} // method expression f1 = Adder.AddTo fmt.Println(f1(myAdder, 10)) // print 20 當然，從已經建立的 type 中將 method 取出來用也是可行的。 f2 = myAdder.AddTo fmt.Println(f2(15)) // print 25 Tips 複習一下：Golang 是 Call by Value. ","date":"2022-03-15","objectID":"/posts/go/go_note7/:2:3","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/go_note7/"},{"categories":["Go"],"content":"介面(Interface) interface 定義並描述了某些其他類型必須具有的確切方法。 聲明 Interface 也很簡單。interface 出現在 type 的名稱後方，通常會以 “er” 做為結尾命名。 我們在標準函式庫中，可以看到這個 fmt.Stringer 介面。 type Stringer interface { String() string } Tips 看到 type 了嗎？所以也有一種類型是介面類型(interface type)。 如果某個 type 有精確簽名(exact signature)的 method，就可以說他滿足該 interface， 像下面這個範例，因為他有一個 String() string 的 method。 type Book struct { Title string Author string } func (b Book) String() string { return fmt.Sprintf(\"Book: %s - %s\", b.Title, b.Author) } 下方這個 Count 類型也滿足 fmt.Stringer 介面。 type Count int func (c Count) String() string { return strconv.Itoa(int(c)) } 我們有兩種不同的類型，但他們都滿足 fmt.Stringer 介面。 反過來說，如果知道某個類型滿足 fmt.Stringer 介面，代表他有一個 method 是 String() string。 也就是說，當我們在任何地方看到具有 interface type 的聲明，都可以使用任何類型，只要他滿足該 interface。 這樣子我們不需要在意傳入的類型是什麼，我們需要在意的是該類型有什麼方法。 func Printer(s fmt.Stringer) { log.Println(s.String()) } book := Book{\"I am learing Go\", \"Wei\"} count := Count(1) Printer(book) Printer(count) // output Book: I am learing Go - Wei 1 ","date":"2022-03-15","objectID":"/posts/go/go_note7/:3:0","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/go_note7/"},{"categories":["Go"],"content":"使用 interface 的理由 減少重複或是樣板的程式碼。 為了更容易在單元測試中使用模擬而不是實體類型 作為一種架構工具，有助於強制執行程式碼庫各部分之間的解耦(decoupling)。 第一點有一部分是因為，函式庫內已經幫你實現了許多，就不需要再去實現。 當然，要自己實現 interface 肯定是沒問題的。 這裡附上一些常用到的 interface type 。link 第二點，當產品有時會用到 DB 或是 internet 時，測試就不太好做， 比方說，我只是要測試一個 insert 的功能，但我在測試上我得先建立一個 Database 的測試實例， 但我可以透過建立一個 interface 並模擬 Database 達到我要的目的，在測試上我就不需要使用實際的 Database。 最後也是 interface 最重要的一個特色，解耦。 降低函式庫之間的依賴關係，讓程式依賴於抽象，而不是依賴於實現。 以前面的例子來說，當我更改了 Book ，我不必去顧慮其他的程式，我只需要注意 Book 有沒有一個 method 滿足 interface 即可。 但我將 Printer 的傳入參數更改為 Book 時，一來是我要考量到 Count 需不需要使用 Printer，二來是要考量到修改 Book 會不會影響到 Printer 運作。 不過就是剛開始開發時會比較累一點，畢竟多了一個 interface 要設計。 ","date":"2022-03-15","objectID":"/posts/go/go_note7/:3:1","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/go_note7/"},{"categories":["Go"],"content":"nil nil 也是 interface type 的 zero value。 只是要注意一點，是 interface 的 type 與 value 都是 nil，才會被認為是 nil。 如果 interface 是 nil，使用他的 method 會造成 panic。 但就算 interface 不是 nil，如果 value 是 nil 且沒有處理好該情況，仍然有機會產生 panic。 ","date":"2022-03-15","objectID":"/posts/go/go_note7/:3:2","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/go_note7/"},{"categories":["Go"],"content":"Empty interface 有時候需要一種方式，代表可以儲存任何類型的 value: var i interface{} i = 20 i = \"Hi\" i = struct{ Name string Age int }{\"Wei\", 26} interface{} 可以保存任何類型的值。通常用於處理未知類型的函式， 像我們很常用的 fmt.Println()。 不過使用上要注意，因為會不知道儲存的是什麼類型的數值。而且 Golang 是強型態語言，語言特性說實在的，與 empty interface 有點衝突啦。 ","date":"2022-03-15","objectID":"/posts/go/go_note7/:3:3","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/go_note7/"},{"categories":["Go"],"content":"Type Assertions and Type Switches 若我們把 value 存到 interface{}，則可以透過 Type Assertions 與 Type Switches 觀察是否有特定的具體類型，或是具體類型實現了另一個 interface。 Type Assertions 實現該 interface 的類型，或是命名另一個 interface。 type MyInt int func main() { var i interface{} var mine MyInt = 20 i = mine i2 := i.(MyInt) fmt.Println(i2 + 1) } 此時 i2 的類型是 MyInt。 若我們更改成以下程式碼，會造成 panic，是因為類型不對而導致的錯誤。 i2 := i.(string) fmt.Println(i2) Type switches 則是當 interface{} 可能會儲存多種類型的值時，透過 switch 進行判斷： func doThings(i interface{}) { switch j := i.(type) { case nil: // i is nil, type of j is interface{} case int: // j is of type int case MyInt: // j is of type MyInt case io.Reader: // j is of type io.Reader case string: // j is a string case bool, rune: // i is either a bool or rune, so j is of type interface{} default: // no idea what i is, so j is of type interface{} } } ","date":"2022-03-15","objectID":"/posts/go/go_note7/:3:4","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/go_note7/"},{"categories":["Go"],"content":"Function Interface 前面介紹 type 與 function 時提到，function 也可以是一種類型，因此也可以用在 interface 上，透過 function type 實現 interface。 常見的例子是 http 服務： type Handler interface { ServeHTTP(ResponseWriter, *Request) } type HandlerFunc func(ResponseWriter, *Request) func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) } 透過 HandlerFunc 進行類型轉換，將函式快速轉換為 Handler 的介面類型，使得任何具有簽名的函數func(http.ResponseWriter,*http.Request)都可以用作http.Handler，透過 http.Handler 可以使用 function, method 與 closures 實現 HTTP 服務。 將符合 interface 的函數定義為 type，對這個 type 實現 interface 中的函式，使用的時候只要把自定義的函式做型態轉換就可以使用了。注意一點，原本的類型要相同才可以使用。 ","date":"2022-03-15","objectID":"/posts/go/go_note7/:3:5","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/go_note7/"},{"categories":["Go"],"content":"補充 關於解耦的部分，可以參考 solid 的依賴反轉原則，了解到解耦的優缺點。DIP ","date":"2022-03-15","objectID":"/posts/go/go_note7/:4:0","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/go_note7/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) Golang Interfaces Explained ","date":"2022-03-15","objectID":"/posts/go/go_note7/:5:0","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/go_note7/"},{"categories":["Application"],"content":"本篇文章將說明如何透過 Github Actions、Telegram bot 與 Twitter stream，定時監聽特定的 Tweet 後發送訊息給 User。 因為朋友的關係，知道 Twitter上有一位作家 比村奇石@Strangestone，而他筆下的 月曜日のたわわ 非常的好(?)。比村老師每週一早上都會在 Twitter 更新，故每週一早上都可以透過推特看到新的作品。月曜日のたわわ是我與朋友們週一時的話題，然而若當天忘記開 Twitter，當下會不知道如何與朋友們討論，或是大家直接忘記有月曜日のたわわ可以看。 為了改善這個問題。朋友開發出了 TawawaBot。使用 Telegram bot開發是因為我們主要用 Telegram 聯繫彼此，不過同學是使用 Twitter API v1.1 開發，現在已經有 v2.0 的 API。且同學使用的平台 heroku 最近不知為何，經常會發生問題而使 bot 無法正常執行，月曜日的動力就這樣不見了。 基於下列兩個原因，才有了這個應用的誕生， 第一點是想用 Twitter API v2，因為不知道 v1.1 何時會被棄用而無法運作。 第二點是想使用 Github Actions，一來是我不必另外準備環境，開發完成後，透過 Github Action 就會自動執行；二來是不用一直開啟設備，只要在週一的早上 Action 即可，降低一些資源的使用量。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:0:0","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"建立帳號 前面提到了三個服務，理所當然的要建立三個服務的帳號。 Telegram Twitter Github ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:1:0","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"Telegram bot 基本上當您建立好帳號後，我們要做兩件事情： 透過 BotFather 建立 bot。 取得自己的 UserID，或是群組的 ChatID。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:2:0","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"建立 bot 建立 bot 的方式很簡單，請找 BotFather 使用下面三招： /newbot 輸入 bot 的顯示名稱( name ) 輸入 bot 的 ID，這邊要注意的是必須以 Bot 或是 _bot 做為結尾，建立完成後會給您這個 bot 的 token，請盡量不要給任何人這個 token，當有這個 token 就可以任意存取你的 bot。 建立完成後，應該會看到這樣的訊息。\" 建立完成後，應該會看到這樣的訊息。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:2:1","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"取得 UserID 與 ChatID(group) 取得 UserID 的方式，先向自己剛剛建立的 bot 傳送一個簡單的訊息，然後更改下面的 url 並透過瀏覽器瀏覽，就可以得到 UserID。 # YourBOTToken 改成 剛剛拿到的 token，前後的\u003c\u003e符號要拿掉。 https://api.telegram.org/bot\u003cYourBOTToken\u003e/getUpdates 至於 chatID，則是要先將 bot 邀請到群組內，如果是管理員就直接加入即可，如果不是管理員，請有禮貌地向管理員說明。加入後簡單傳個訊息，並透過上述的方法，就能夠取得 chatID。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:2:2","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"建立 Twitter 開發專案 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:3:0","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"Sign up Twitter Developer Platform 我們先到這裡 Sign up，接著應該會導入您剛剛註冊 Twitter 的資訊。並填寫其他資訊。 關於 What’s your use case? 這個問題，因為我們是要製作 bot ，所以選擇 Making a bot 這個選項即可。 Info 這個選項請不要亂填，若審核沒過，這個帳號以後就不能再申請的樣子。 關於 Will you make Twitter content or derived information available to a government entity or a government affiliated entity? 這個問題，選擇 No 即可。 接著就是開發者的協議與政策，請閱讀過後點選下方的 checkbox。我知道很多人都直接點。 這個步驟結束後，應該就可以建立 project 了。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:3:1","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"建立專案並取得 bearer token 請到 Developer Portal 並建立 Project 與 APP，建立完成後應該會給您 bearer token 與其他的 token，但我們只需要使用 bearer token 即可 如果忘記了，進入 APP 後點選 Key and Tokens 的標籤頁，點選 regenerate 後會重新產生一組 bearer token 給您。 Warning token 務必保存好不要外流，有這個 token 就可以對你的 APP 做一些壞壞的事。 忘記了嗎？點黑底白字的不是點白底黑字的唷\" 忘記了嗎？點黑底白字的不是點白底黑字的唷 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:3:2","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"Github Actions Github Actions 可以用來自動化、自定義和執行您的軟體開發工作流程，許多人用來做 CI/CD使用。 基本上每一個 Job 可以執行 6 小時，透過 twitter stream 來接收比村老師的推文已經足夠了。 另外有 cron 功能，可以安排行程在我們想要的時間執行，不過時間不太準確就是了。（我設定九點執行，實際到了十點多才執行呢～） ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:4:0","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"workflow/main.yml 先在 github 上建立一個專案，待會要設定 Github Actions 進行 schedule 的相關設定。 建立完成後，請到專案的 Actions，點選 “New workflow”，會進入到 Choose a workflow 這個頁面，直接點選下方的 \" set up a workflow yourself “，此時 Github 會自動幫你建立一個新的 main.yml，待會就是要編輯這個檔案，透過 Github Actions 進行排程與相關的工作。 我這邊直接提供我的 main.yml 給各位。 連結 如果有使用我的 main.yml，建議先把下列兩行反註解，這樣每一次 push 時都會即時進行 Action，等確認沒問題再註解即可。 # push: # branches: [ main ]另外，Telegram bot 傳送的部分訊息由該檔案產生，要修改傳送的訊息，請修改這裡與後續 Twitter Stream 使用到的程式碼。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:4:1","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"Secrets and Environments 前面提到的 userID(chatID), telegram bot token 與 twitter bearer token，因為這些 token 直接放到 repo 中，就是赤裸裸地給人家看。 Github 提供了 Secret 功能，Secret 是在 repo 中的加密環境變數，可以在 Github Actions 中做使用而不被其他人知道。 請到專案中的 setting 並點選左方的 Secrets -\u003e Actions，並依照以下名稱建立三個 secrets。 TELEGRAM_TO : Your telegram userId or chatId. TELEGRAM_TOKEN : Your telegram bot token. TWITTER_BEARER_TOKEN : Your twitter bearer_token. Tips 因為 main.yml 我已經寫好的關係，這裡有要求名稱。使用上是可以更改名稱的，只要 main.yml 內的變數與 Repository secrets 有符合即可。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:4:2","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"Twitter Stream Twitter API 會透過 Stream 的方式，即時地把符合規則的 tweet 經過 stream 送給我們。 我直接提供我的的 code。連結 如果有要更改規則，請修改 set_rules() 這個函式內的規則。規則可以參考官方文件。 如果想對推文內容進行進一步的過濾，可以到 get_stream() 內修改成更詳細的規則。 Telegram bot 發送的訊息由這個程式產生，若想要修改的話，請修改 fp.write() 的傳入參數內容即可。 測試時，先建議把規則改成自己的 twitter ID 再上傳程式，確認 Github Actions 正常執行後，再推一篇符合規則的 tweet， Telegram bot 應該就會發送 tweet 的內容。 完成了，期待週一吧！ 如果你看到類似的訊息，代表你的程式正常。\" 如果你看到類似的訊息，代表你的程式正常。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:5:0","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"Reference 我的朋友 : MDSK-UltraIN How to Create telegram bot StackOverflow - Telegram Bot - how to get a group chat id? Twitter developer Documentation Filtered stream Using environments for deployment Encrypted secrets 使用或參考的 packages： MDSK-UltraIN/TawawaBot_forTelegram twitterdev/Twitter-API-v2-sample-code theskumar/python-dotenv appleboy/telegram-action ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:6:0","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Go"],"content":"本篇文章會簡單介紹指標，並學習如何使用指標與記憶體空間，使程式執行上能更有效能。 ","date":"2022-03-07","objectID":"/posts/go/go_note6/:0:0","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/go_note6/"},{"categories":["Go"],"content":"Pointer ","date":"2022-03-07","objectID":"/posts/go/go_note6/:1:0","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/go_note6/"},{"categories":["Go"],"content":"簡介 學習 pointer 的第一條規則 ： 不要害怕 ！！ pointer 是一種 variable，他的內容是儲存另一個 variable 的 address，Address 則是每一個 variable 儲存在一個或多個連續的記憶體位置。 不同類型的 variable 會佔用不同的記憶體空間，像是 bool 只要一個 byte 就能代表 true 或 false，(因為可以獨立尋找 address 的最小空間是 byte)，而 int32 需要 4 個 byte 的儲存空間。 雖然不同類型的 variable 可以佔用不同的記憶體空間，但每個 pointer 無論指向任何類型的 variable，都會是相同的大小。 var x int32 = 10 var y bool = true pointerX := \u0026x pointerY := \u0026y var pointerZ *string pointerX 會是 x 的 address pointerY 會是 y 的 address pointerZ 不會指向任何東西，Value 會是 Zero value。 而 pointer 的 Zero value 是 nil 而不是 0，與 C 語言的 null 不同， nil 不代表 0，故不能將 nil 轉換成 0。 ","date":"2022-03-07","objectID":"/posts/go/go_note6/:1:1","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/go_note6/"},{"categories":["Go"],"content":"運算符 基本上 golang 的 pointer 運算符與 C/C++ 的相似。 \u0026 : address operator，用在變數前的話，會返回該變數的 address。 * : indirection operator，用於指針變數，會返回該 pointer 指向的 value。也被稱為 dereferencing。 x := 5 pointerX := \u0026x y := 5 + *pointerX fmt.Println(y) // 10 dereferencing 要確保 pointer 不是 nil，否則會造成 panic。 var x *int fmt.Println(*x) // panic ","date":"2022-03-07","objectID":"/posts/go/go_note6/:1:2","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/go_note6/"},{"categories":["Go"],"content":"指標類型 其實就是有一種類型叫做指標類型啦。用來表示 pointer，基本上可以基於任何類型。 x := 10 var pointerX *int pointerX = \u0026x 另外透過 new 聲明一個指針變數時，他的初始值會是 0 而不是 nil。 var x = new(int) fmt.Println(*x) // prints 0 ","date":"2022-03-07","objectID":"/posts/go/go_note6/:1:3","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/go_note6/"},{"categories":["Go"],"content":"傳遞(call) ","date":"2022-03-07","objectID":"/posts/go/go_note6/:2:0","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/go_note6/"},{"categories":["Go"],"content":"簡介 當原始值分配給另一個變數或傳遞給 function or method 時，對其他變數所做的任何更改都不會反映在原始值中。 // Java int x = 10; int y = x; y = 20; System.out.println(x); // prints 10 然而在透過類型所建立的 instance，分配給另一個 instance 或傳遞給 function or method 時，又會是不同的結果。 // python class Foo: def __init__(self, x): self.x = x def outer(): f = Foo(10) inner1(f) print(f.x) inner2(f) print(f.x) g = None inner2(g) print(g is None) def inner1(f): f.x = 20 def inner2(f): f = Foo(30) outer() // Output 20 20 True 在許多程式語言中(e.g. Java, Python)，會有以下特性： 如果將 instance 傳遞給函式並更改 field 的值，則這次更改會反映在傳遞進去的 instance。 如果重新分配參數，則更改不會反應在傳遞進去的變數。 如果傳遞 nil/null/None 等參考值，會將傳入參數本身設定為新的數值，而不會影響原先原先的數值。 因為這些語言的 instance 是透過 pointer 實現的，當 instance 傳遞給 function 或是 method 時，被複製的數值是指向該 instance 的 pointer。在 inner1 是指向相同的 address，而在 inner2 則是建立一個新的 instance，會指向不同的 address，因此不會影響到原先傳入的 instance。 基本上在 golang 中，會有一樣的特性，但 golang 不同的是可以對原始類型與架構使用 pointer 或是 value。 ","date":"2022-03-07","objectID":"/posts/go/go_note6/:2:1","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/go_note6/"},{"categories":["Go"],"content":"傳遞 pointer 上篇文章提到，golang 是 call by value，但可以透過將 pointer 傳遞給函式的方式，使原始變數被函式進行修改。只不過有幾點是要注意的。 如果傳遞 nil pointer，則不能將數值修改為非 nil。如果已經將該 pointer 分配了一個數值，則只能 reassign 這個數值。因為 call by value 的關係，會複製一份 pointer 變數，並在函式內處理，而原先的 pointer 當然就不會被函式修改到。 func failedUpdate(g *int) { x := 10 g = \u0026x } func main() { var f *int // f is nil failedUpdate(f) fmt.Println(f) // prints nil } 如果希望 pointer 參數傳入後修改的值在退出函式時仍然存在，不要在函式內建立一個新的變數並透過修改 pointer 來修改，而是透過 pointer 指向要修改的數值並進行修改。 func failedUpdate(px *int) { x2 := 20 px = \u0026x2 } func update(px *int) { *px = 20 } func main() { x := 10 failedUpdate(\u0026x) fmt.Println(x) // prints 10 update(\u0026x) fmt.Println(x) // prints 20 } ","date":"2022-03-07","objectID":"/posts/go/go_note6/:2:2","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/go_note6/"},{"categories":["Go"],"content":"小心使用 基本上在 golang 是不建議使用 pointer，會影響數據傳遞的理解，除了在某些情況下使用會好些，例如在使用函式時需要一個 interface、部分類型需要以指針傳遞、數據類型中存在需要修改的狀態，會建議返回值使用指針類型。 ","date":"2022-03-07","objectID":"/posts/go/go_note6/:2:3","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/go_note6/"},{"categories":["Go"],"content":"效能 不過，pointer 的好處是無論任何的類型，pointer 都會是一樣的大小，也就是說當我們傳遞大的數值給函式時，花費的時間也會較多，但傳遞 pointer 則會減少原先所需傳遞的時間。 ","date":"2022-03-07","objectID":"/posts/go/go_note6/:2:4","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/go_note6/"},{"categories":["Go"],"content":"Slice 上一篇我們提到，Map 與 Slice 是以 pointer 實現的，故直接傳遞 Map 與 Slice 給函式是可以直接修改數值的，這邊提一下 Slice ，在函式內雖然可以修改內部數值，但不能修改 slice 的容量。 Slice 基本上為三個單元所組成： 資料，以 pointer 指向某一段記憶體空間。 長度，使用了多少空間。 容量，這個 slice 總共有多大。 因為 call by value 的關係，傳遞至函式內的 slice 會被複製，因為資料是以 pointer 指向某一段記憶體空間，所以可以直接修改，但容量部分只會修改函式內被複製的這份 slice，因此原先的 slice 並不會被修改到容量。 另外，slice 也很適合作為 buffer 使用，後面的文章會再提起 slice。 ","date":"2022-03-07","objectID":"/posts/go/go_note6/:2:5","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/go_note6/"},{"categories":["Go"],"content":"Garbage Collector Garbage 是指沒有 pointer 指向該筆數據，則代表該數據存在記憶體空間中但沒有做使用，該數據就是 Garbage，這些空間就會被拿來重新使用，避免記憶體使用量一直增加。 Golang 有 Garbage Collector，但不代表可以隨性的使用記憶體空間。因為 Garbage Collector 也是需要資源去處理這些 Garbage，會降低程式的效能。 另外， Golang 會將原始類型、結構等放至 stack 中，並順序排列，透過建立最少的 Garbage，達到低延遲的目標。 寫著寫著發現 Stack, Garbage Collector 是個坑，之後有空可能會另外寫一篇出來吧。 後面會附上一些連結，有興趣的話可以參考。 ","date":"2022-03-07","objectID":"/posts/go/go_note6/:3:0","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/go_note6/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) Getting to Go: The Journey of Go’s Garbage Collector Memory Bandwidth Napkin Math Language Mechanics On Stacks And Pointers Allocation efficiency in high-performance Go services ","date":"2022-03-07","objectID":"/posts/go/go_note6/:4:0","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/go_note6/"},{"categories":["Go"],"content":"本篇文章會說明如何使用 golang 撰寫函式，瞭解傳入值與返回值，介紹匿名函式與defer，並瞭解可以對函式所做的事情。 坦白說書對於這個章節寫的有點模糊，好啦其實是我自己理解能力差，這次看了不少 reference，若以後覺得還有要補充的地方會補上。 ","date":"2022-02-26","objectID":"/posts/go/go_note5/:0:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"宣告與使用函式 基本上宣告函式與其他程式語言幾乎相同，聲明會有四個部分： keyword, func 函數名稱 輸入參數 返回類型 func example(input int) int { fmt.Println(\"This is example.\") return 0 } 如果說這個函式沒有傳入參數，則小括號裡面則不需要填寫任何參數；如果說這個函式不會有任何的返回值，則宣告時也不需要寫返回類型。常使用的 main() 函式就是一個很好的例子。 func main(){ fmt.Println(\"Hello world\") } 若有許多傳入參數，且都為同一種類型時，可以稍微省略一些輸入參數的類型，但我是不建議就是了，每一個參數都寫清楚，後續維護會比較好處理一些。 func example(number1, number2 int) int { return number1+number2 } ","date":"2022-02-26","objectID":"/posts/go/go_note5/:1:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"具名與選擇性參數 (named and optional) 基本上許多程式語言都具有這兩個性質，但在 golang 中並沒有這兩個性質，基本上 golang 要求你宣告的輸入參數，全部都要使用（但也有例外）。 具名參數：用於識別傳入參數為何。許多情況下我們會傳入很類似的參數，透過具名參數的方式較容易識別。 選擇性參數：代表這個參數是選擇性傳入的，宣告函式時，選擇性參數必須擺在後面。若要選擇多個選擇性參數使用時，可以使用具名參數。 雖然 golang 無法使用這兩種參數，但可以用模擬的方式。 首先要訂一個 struct，代表這個函式會使用到的所有參數： type MyFuncOpt struct { FirstName string LastName string Age int } 接著，宣告函式時要使用前面宣告的 struct 作為傳入參數。使用時則傳入所需的數值即可。 func MyFunc(opts MyFuncOpt) error{ // do something } // 可以由外部傳入值 var i int = 55 // How to use. func main() { MyFunc(MyFuncOpts{ FirstName: \"Joe\", Age: i, }) } ","date":"2022-02-26","objectID":"/posts/go/go_note5/:2:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"可變參數 Golang 支援可變參數，可以允許任意數量的輸入參數。可變參數必須是函式聲明時的唯一一個參數，或是最後一個參數，並在類型前面加上 ...表示，這時會以這個類型的 slice 表示這個參數。 func number(base int, value ...int) int{ //do something. } 上述的例子中， value 已經是一個類型為 int 的 slice，所以也可以傳 slice 給他，只是說傳入時要在後面加上 ... 才能使用，否則會發生編譯錯誤。 number(1, []int{2,3,4,5}...) ","date":"2022-02-26","objectID":"/posts/go/go_note5/:3:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"多個返回值 Golang 的一個特色是，允許多個返回值。 func number(base int, value int)(int,int){ return base+value, base*value } 宣告函式時，多個返回值的類別需要以括號包起來，並以逗號隔開；函式內回傳值則是以逗號隔開即可。 多個回傳值則需要分配給多個變數，或是都被使用到，而不能像 python 一樣只分配給一個變數，因為 golang 多個回傳值就是回傳多個，不是像 python 一樣回傳一個數組。 numbers := number(1,2) // error number1, number2 := number(1,2) // success 返回值也是可以被具名的(named)，在宣告返回值類別時就都要加上括號，即便只有一個返回值也是，若只想命名部分的返回值，可以使用 _。另外具名的返回值可以分配在不同名稱的變數上，沒問題的。 func number(base int, value int)(ans1 int, ans2 int, _ int){ ans1, ans2 = base+value, base*value ans3 := 0 return ans1,ans2,ans3 } 不過，即使命名了返回值，也不代表一定要返回該值，golang 是允許不返回命名返回值的。使用上請小心，因為編譯器會將 return 的值分配給命名的返回值。 func number(base int, value int)(ans1 int, ans2 int, _ int){ ans1, ans2 = 1,2 ans3 := 0 return base+value,base*value,ans3 } func main(){ fmt.Println(number(5,2)) } // Output 7 10 0 ","date":"2022-02-26","objectID":"/posts/go/go_note5/:4:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"空白返回 (Blank returns) 空白返回適用在當我們命名了所有的返回值時，可以直接使用 return 而返回數值，不需要在 return 後面補上變數。 func number(base int, value int) (ans1 int, ans2 int) { ans1, ans2 = 1, 2 return } 雖然會節省許多時間，但維護上會很困擾。因為要去尋找返回值是從哪裡返回的，當函式一長，或是有多個 return，由判斷式決定的函式，看到都是 return，頭會很痛。 // 舉一個超超超簡單的例子。 func number(base int, value int) (ans1 int, ans2 int) { return // ???????? 哦哦回傳 zero value } func main(){ fmt.Println(number(5,2)) } // Output 0 0 ","date":"2022-02-26","objectID":"/posts/go/go_note5/:5:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"匿名函式 在函式中定義新函式，並將其分配給新的變數。而這些內部的新函式則是匿名函式。宣告方式基本上與一般函式相同，主要的差別在匿名函式不需要命名。使用時在後面用小括號傳入變數即可。 func main() { for i := 0; i \u003c 5; i++ { func(j int) { fmt.Println(\"printing\", j) }(i) } } //output printing 0 printing 1 printing 2 printing 3 printing 4 但我在 for loop 使用 fmt.Println() 就好了，直接使用內部的程式碼不是更好嗎？匿名函式的好處在哪裡呢？後續會在 defer 與 launching goroutines 這兩種情境中提到，匿名函式在這兩種情境中會是有用的。 ","date":"2022-02-26","objectID":"/posts/go/go_note5/:6:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"Closures ","date":"2022-02-26","objectID":"/posts/go/go_note5/:7:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"介紹 中文翻譯好像稱為閉包 (不喜歡)，Closures 可以限制函式的使用範圍，如果一個函式只會被另一個函式使用，但他會被多次使用，可以使用一個內部函式隱藏被使用的函式，正常函式呼叫完後內部的變數就會銷毀，但閉包卻能使本該銷毀的變數一直保留。 func intSeq() func() int { i := 0 return func() int { i++ return i } } func main() { nextInt := intSeq() fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) newInts := intSeq() fmt.Println(newInts()) } // Output 1 2 3 1 宣告一個 intSeq 的函式，返回值是函式，函式內第一個 return 使用了外部的 i，使得這個匿名函式成為了 Closures，而 i 則會被保留狀態並等待下次使用。 tips : 把函式想成一個數值會比較好理解，而運作方式也的確是如此。 ","date":"2022-02-26","objectID":"/posts/go/go_note5/:7:1","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"從函式返回函式 不只是能返回變數的狀態，也能夠返回函式的 closure： func makeMult(base int) func(int) int { return func(factor int) int { return base * factor } } func main() { twoBase := makeMult(2) for i := 0; i \u003c 3; i++ { fmt.Println(twoBase(i)) } } // Output 0 2 4 twoBase 的值是 makeMult(2) (記得函式也是一個數值的想法)，此時賦予 base 為 2。後面的 for loop 時，因為對於 twoBase 傳入了數值，故回傳內部的匿名函式。 ","date":"2022-02-26","objectID":"/posts/go/go_note5/:7:2","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"defer 通常使用 defer 是用來釋放資源，程式運作時需要常常釋放資源，例如開啟文件後要關閉，或是網路連線完成後，透過 defer 進行清理的工作。通常擺在函式的後面，與其他語言的 finally 相似。 func main() { f := createFile(\"/tmp/defer.txt\") defer closeFile(f) writeFile(f) } func createFile(p string) *os.File { fmt.Println(\"creating\") f, err := os.Create(p) if err != nil { panic(err) } return f } func writeFile(f *os.File) { fmt.Println(\"writing\") fmt.Fprintln(f, \"data\") } func closeFile(f *os.File) { fmt.Println(\"closing\") err := f.Close() if err != nil { fmt.Fprintf(os.Stderr, \"error: %v\\n\", err) os.Exit(1) } } // output creating writing closing 比方說要產生一個檔案，並寫入檔案後關閉對該檔案的存取，但我們在 main 中撰寫的順序是 createFile, closeFile，最後是 writeFile，但因為 defer 的關係， closeFile會在函數結束前執行。 補充一下 defer 的事情： 可以透過 defer 在函式中使用多個 closure，會以先入後出的方式進行，最後使用 defer 的會先運作。 defer 會是在 return 之後運行的。 defer 會造成延遲，若是要求速度至上的程式，請盡量減少使用。 defer 另一個好處是，可以用來檢查或修改返回值。且這也是前面提到命名返回值的理由。 // 書裡面的例子。 func DoSomeInserts(ctx context.Context, db *sql.DB, value1, value2 string) (err error) { tx, err := db.BeginTx(ctx, nil) if err != nil { return err } defer func() { if err == nil { err = tx.Commit() } if err != nil { tx.Rollback() } }() _, err = tx.ExecContext(ctx, \"INSERT INTO FOO (val) values $1\", value1) if err != nil { return err } // use tx to do more database inserts here return nil } 函式最後會回傳一個 error 類型的 err 變數，此時中間的 defer 會對這個數值進行判斷，如果沒有錯誤，則會提交，如果有錯誤的會則會 rollback。 ","date":"2022-02-26","objectID":"/posts/go/go_note5/:8:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"Call by Value 當我們傳遞變數至函數時， Golang 會將變數的值複製並傳遞進去。函式並不會改變該變數原本的數值。與其他語言不同的地方是，即使是傳遞一個 struct 至參數內，也不會改變在外部 struct 內的數值。 然而，傳遞 map 與 slice 進入參數時，函式進行修改是會影響到外部變數內的數值的，因為 map 與 slice 是用 pointer 實現的，對這個 pointer 所指的數值進行修改，就會影響到外部變數的數值。另外，傳遞至函式內的 slice，是無法延長的。 若我們需要像是 int, string 類型的變數進入函式進行修改時，要怎麼做呢？ pointer !! ","date":"2022-02-26","objectID":"/posts/go/go_note5/:9:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) 具名和選擇性引數 (C# 程式設計手冊) More on Functions 談談我所理解的閉包，js、php、golang裡的closure Go by Example: Closures Go初識-day10-閉包(closure) Go by Example: Defer ","date":"2022-02-26","objectID":"/posts/go/go_note5/:10:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"本篇文章將介紹 Block 與 Shadows，接著會說明控制結構（if、for、goto）等。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:0:0","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Code Blocks ","date":"2022-02-25","objectID":"/posts/go/go_note4/:1:0","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Types of blocks 其實用 blocks 作為關鍵字去尋找相關資訊並不太好找，反倒是以 Code Blocks 會比較容易些，基本上有聲明的地方，都會被稱為 blocks，在任何函數以外聲明的常數、變數、類型與函數都是放在 package block 內。而使用 import 內的時statement時，這些名稱則是放在 file block。 在 golang 中，有四種 blocks： universe block，包含了整個 project 的 source code。 package block，每一個 package 都有一個包含全部 code 的 block，但並不包含聲明。 file block，每一個 file 都有一個包含全部 code 的 block，也包含了聲明。 local blocks，基本上，在一個函數中，每一個大括弧 {} 都定義了一個 block。 local blocks 又分為 explicit local blocks 與 implicit local blocks，基本上要由 {} 與控制結構識別。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:1:1","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Hierarchies 透過圖片，會更了解 block 之間的層次結構。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:1:2","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Shadows 我們隨時可以從內部 block 訪問外部 block 的 identifer，如果內部與外部有相同的 identifer 時，會發生什麼事呢？ ","date":"2022-02-25","objectID":"/posts/go/go_note4/:2:0","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Shadowing variables func main() { x := 10 if x \u003e 5 { fmt.Println(x) x := 5 fmt.Println(x) } fmt.Println(x) } 可以先想一下這個函式的 blocks，再來想一下這個程式會印出什麼。在這個函式中發生了內部與外部的 identifer 相同的情況，此時外部的 identifer 會被隱藏。印出來的結果會是： 10 5 10 Shadowing Variable 是指在 package block 中的 variable 相同名稱的 variable，只要 Shadowsing variables 存在，就不能由外部訪問 Shadowing variables。該函式首先定義了 x 為 10，後來有一個 if statement，並遇到了大括號，記得前面說的每一個大括弧會是一個 block，這個 statement 內的 x 則是 shadowing variable，當離開這個 statement 時，這個 shadowing variable 就不能被訪問，故最後的 fmt.Println() 會是訪問頂部的 x 。 若善用 shadowing variables 在測試或是懶得想變數時會很方便，但記得使用的 identifer，若使用不慎可是會出問題的。 func main() { x := 10 fmt.Println(x) fmt := \"oops\" fmt.Println(fmt) } // Output fmt.Println undefined (type string has no field or method Println) 這個例子中，fmt 被聲明為 local variable，故會隱藏原先 fmt 所擁有的函式，也因此會有錯個錯誤發生。 個人認爲在測試內使用 shadowing variable 即可，開發的專案就不建議。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:2:1","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Detect 還記得在第一章提到的 vet 與 lint 可以做檢測用，但是 go vet 與 golangci-lint 是沒有檢測 shadow 的功能的(寫這篇文章時應該是沒有吧…)，但的確是有 shadow detect 工具可以使用的。 go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow@latest ","date":"2022-02-25","objectID":"/posts/go/go_note4/:2:2","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Control Structures Control Structures 其實跟許多語言的用法極為相似，但 golang 有一個與眾不同的 goto 可以使用。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:3:0","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"if if 的用法也與其他語言的用法相似 (很懶得寫)， if 的 condition 不用括號刮起來。 n := rand.Intn(10) if n == 0 { fmt.Println(\"That's too low\") } else if n \u003e 5 { fmt.Println(\"That's too big:\", n) } else { fmt.Println(\"That's a good number:\", n) } 主要提一點是，條件式內可以宣告變數的。 if n := rand.Intn(10); n == 0 { fmt.Println(\"That's too low\") } else if n \u003e 5 { fmt.Println(\"That's too big:\", n) } else { fmt.Println(\"That's a good number:\", n) } 在第一句的部分，我們新宣告了一個變數，後續的條件式則可以直接透過這個新的變數進行判斷。在某些場合會很好用。 但使用 if/else 時，請盡量將條件簡單化，另外是在 if statement 中宣告的變數，也是 shadowing variables，注意聲明的名稱與使用方式。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:3:1","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"for for 基本上也與其他語言一樣，作為循環使用，在 golang 中，for 有四種使用方式 標準型 for 條件型 for 無窮型 for for-range 標準型 for for i := 0; i \u003c 10; i++{ fmt.Println(i) } 這就像許多語言的用法一樣，有一個初始值，一個需要滿足的條件式，跟一個會遞增或遞減的行為，這個行為會在每一次的迴圈結束後進行。 條件型 for i := 0 for i \u003c 100 { fmt.Println(i) i = i + 1 } 條件型的 for 省略了初始值與行為，但仍須保留條件式。 無窮型 for for{ fmt.Println(\"Hello!\") } 取消了條件，亦同這個 for 會一直滿足且運作下去，當然也可以使用標準型或是條件型 for 達到相同的目的。如果要程式運作時需要結束這個無窮型迴圈，設計時可以使用條件式與 break 跳出這個 for。 i := 0 for{ i = i + 1 if i \u003e 10 { break } } for-range 通常像其他語言的迭代器(iterator) 我以前學不好的部分， for-range 常用在 string, array, slice 和 map 上。 evenVals := []int{2, 4, 6, 8, 10, 12} for i, v := range evenVals { fmt.Println(i, v) } // Output 0 2 1 4 2 6 3 8 4 10 5 12 用 for-range 會得到兩個變量，一個通常被稱為index或是key，我在這邊稱為位置，另一個則是該位置的數值。 如果不需要位置時，可以使用下底線進行隱藏。 evenVals := []int{2, 4, 6, 8, 10, 12} for _, v := range evenVals { fmt.Println(v) } // Output 2 4 6 8 10 12 如果需要位置而不需要值時，使用下底線嗎？也可以，但可以直接省略。 evenVals := []int{2, 4, 6, 8, 10, 12} for i := range evenVals { fmt.Println(i) } // Output 0 1 2 3 4 5 for-range 在遍歷 map 上會有特別的地方，會有每一次遍歷的順序結果不同的情形，這是 go 語言為了安全的設計，每一次的 for-range 迭代在遍歷 map 會有不同的結果。 for-range 所遍歷的會是一個副本而不是原變數的值，故在這個副本內修改的，並不會影響到原本的數值。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:3:2","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Continue continue 是用來跳過剩餘的部分，並進行下一次的迭代。用起來也與其他語言相似，但有一個特別的用法，透過 OUTER 標籤進行的 for。 OUTER: for _, item := range list.Items { for _, reserved := range reserved.Items { if reserved.ID == item.ID { continue OUTER } ... do some other work ... } ... do some other work ... } 透過這種方式，可以跳出或跳過外部循環的迭代器。聽說這種方法很少用就是了 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:3:3","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"switch Nintendo Switch !! switch也是很常在其他語言中看到的 statement，用法也相似，很多人不喜歡使用 switch (我自己也是)，但 switch 在 go 語言中有一些令人驚訝的地方(?) words := []string{\"a\", \"cow\", \"smile\", \"gopher\",\"octopus\", \"anthropologist\"} for _, word := range words { switch size := len(word); size { case 1, 2, 3, 4: fmt.Println(word, \"is a short word!\") case 5: wordLen := len(word) fmt.Println(word, \"is exactly the right length:\", wordLen) case 6, 7, 8, 9: default: fmt.Println(word, \"is a long word!\") } } 多個 case 要進行相同的邏輯，可以在同一個 case 寫多個條件。 每一個 case 都會是一個 block，像是 case 5 的 wordLen 是一個新的 variable，只能在這邊使用。 不必再每個 case 後面加上 break， go 只會進行符合的 case。 如果沒有滿足 case，不會發生任何事。或是使用 default 決定沒有滿足 case 時需要做什麼。 通常使用 break 代表要跳出這次的 switch。但與其他語言不同，在 case 底下使用 break，go 只會認為你想跳出該 case 而不是 switch，若需要跳出 switch 需搭配 label 做使用。使用方式如下列的程式碼： loop: for i := 0; i \u003c 10; i++ { switch { case i%2 == 0: fmt.Println(i, \"is even\") case i%3 == 0: fmt.Println(i, \"is divisible by 3 but not 2\") case i%7 == 0: fmt.Println(\"exit the loop!\") break loop default: fmt.Println(i, \"is boring\") } } ","date":"2022-02-25","objectID":"/posts/go/go_note4/:3:4","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"goto 簡單介紹一下就好，如同字面上的意思，會去到程式的某個地方。但因為 goto 接近為所欲為，想去哪就去哪，在撰寫程式、運作與維護頗為麻煩 (自己廢就說)，通常會被用在要跳過程式某些部分或是跳出迴圈、switch 等，並執行程式後面的部分時使用。 func main() { a := rand.Intn(10) for a \u003c 100 { if a%5 == 0 { goto done } a = a*2 + 1 } fmt.Println(\"do something when the loop completes normally\") done: fmt.Println(\"do complicated stuff no matter why we left the loop\") fmt.Println(a) } tips : 非必要，盡量盡量不要使用 goto。 函式內可以提的內容應該都說明了，這章應該還有些東西可以補充，但可能之後想到比較容易解釋的方式，或是例子，再回來補充。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:3:5","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) Code Blocks and Identifier Scopes Continue statements with Labels in Go (golang) Golang switch case 用法 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:4:0","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["blog"],"content":"本篇文章會簡單介紹 algolia search，並且說明如何在 LoveIt 上啟用 Algolia search。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:0:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Algolia search ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:1:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"介紹 Algolia search的宗旨是提供一個快速的搜尋體驗，並提供適用於多種不同 stack 的文件與工具，可以快速的建構搜尋功能，且搜尋功能只要利用 API 建立，不必花費太多時間建構。 另外可以分析搜尋結果，了解用戶到自己的網站搜尋了些甚麼，透過這些結果，可以自行定義，或是由 Algolia 自動生成較佳的搜尋規則。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:1:1","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"優點 速度非常快。Algolia Search 基本上是將網站建立索引(index)，並建立了分佈式搜尋網路(Distributed Search Network,DSN)，盡可能使搜尋要求送到最近的 DataCenter，降低延遲。 提供了自動建議字、自動糾正錯別字等搜尋功能，另外也支援多種語言的搜尋。 有免費的方案可以使用，雖然有些地方有所限制，但對於小型開發者而言，這個免費方案應能滿足需求。或是使用免費的 Docsearch，他是基於 algolia 的文件搜尋，不過他只能用在技術文件或是技術Blog，但我的 Blog 審核一直沒有通過，所以沒辦法使用…(應該是因為我寫的很差) ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:1:2","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"建置 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:2:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"註冊帳號 首先到 Algolia 的官方網站註冊帳號，基本上註冊的部分就不加以描述，而且我相信大家都有 Github account，algolia 也可以使用 Github 登入。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:2:1","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Key 註冊完成後，進到 Dashboard 並點選 API Keys，會獲得 Application ID，Search-Only API Key。 切記 : Admin API Key 絕對絕對絕對不要存放在任何地方。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:2:2","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Index 從 Dashboard 點選 Search，並建立一個新的 index，這個 index 可以自己任意取一個容易識別的名稱。 接下來的步驟，會用到前述提到的 Application ID、Search-Only API Key與index。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:2:3","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Algolia search config in LoveIt LoveIt 主題已經將 Algolia search 的功能製作完成，只需要輸入相對應的設定到 config.toml 中即可。 這邊附上官方的設定檔。 [params.search] enable = true # type of search engine (\"lunr\", \"algolia\") type = \"algolia\" # max index length of the chunked content contentLength = 4000 # placeholder of the search bar placeholder = \"\" # LoveIt NEW | 0.2.1 max number of results length maxResultLength = 10 # LoveIt NEW | 0.2.3 snippet length of the result snippetLength = 30 # LoveIt NEW | 0.2.1 HTML tag name of the highlight part in results highlightTag = \"em\" # LoveIt NEW | 0.2.4 whether to use the absolute URL based on the baseURL in search index absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 預設為 lunr 搜尋，請更換成 algolia。 在下方的部分，可以看到 index、appID 與 searchKey，請依據填入前述提到的數值。這裡的設定就完成，我們可以開始搜尋了。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:3:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Record 當完成設定之後，其實這個搜尋功能已經建立起來了，但是因為我們還沒上傳相關的記錄，所以 algolia search 會回傳 0 筆結果，那要如何上傳記錄呢? ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:4:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Create records 請在您的 config.toml 新增 output 屬性 : [outputs] home = [\"HTML\",\"RSS\",\"JSON\"] # Hugo 預設會生成 HTML 與 RSS，不建議刪除該兩參數，貌似會影響 Hugo 生成網頁的樣子。 設定完成後，我們執行 hugo，讓他重新建置並輸出 json，沒有意外的話會在 public 資料夾內產生一個 index.json，這個就是我們要的記錄檔，待會我們要上傳至 algolia search。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:4:1","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Upload records Dashboard -\u003e search -\u003e index -\u003e Add records 然後把剛剛產生的 json 上傳，上傳完成後應該幾秒內，你的 algolia search 就能夠搜尋到相關的結果了。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:4:2","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Auto upload 因為這個方式，當我們的 blog 有更新時，就必須手動上傳新的記錄，那能不能使用程式上傳呢 ? Ans : 官方有提供API，當然可以。 官方文件 有詳細說明使用方式與一些 example code，基本上官方文件提供的程式碼就可以滿足我們的需求。因為都使用 Hugo 了，基本上 go 的環境應該是沒問題。我這邊就使用官方提供的 go 範例做使用。 tips : 記得要更改的參數與路徑。 package main import ( \"encoding/json\" \"io/ioutil\" \"github.com/algolia/algoliasearch-client-go/v3/algolia/search\" ) type Actor struct { Name string `json:\"name\"` Rating int `json:\"rating\"` ImagePath string `json:\"image_path\"` AlternativeName string `json:\"alternative_name\"` ObjectID string `json:\"objectID\"` } func main() { client := search.NewClient(\"appID\", \"Admin API Key\") index := client.InitIndex(\"index\") var actors []Actor data, _ := ioutil.ReadFile(\"public/index.json\") _ = json.Unmarshal(data, \u0026actors) // Batching is done automatically by the API client _, _ = index.SaveObjects(actors) } 之後在 push repo 時，一併記得要執行這個更新記錄的程式即可。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:4:3","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"參考資料(Reference) Algolia LoveIt Sending Records in Batches ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:5:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"本篇文章基本上是介紹如何用 Hugo 建置 blog，並部署至 Github pages 上。 ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:0:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"前言 基本上建置這個部落格是為了紀錄自己的筆記，與自己遇到的問題和如何解決的方式，但從無到有建置一個非常麻煩，又不太想用像是 Medium 之類的網站，會少了一點自由，故想說使用框架產生靜態網頁的方式建置。 最一開始使用 Vuepress，使用了一陣子之後覺得用起來不是很順手，過了一陣子則有了換框架的想法，於是先換了 Docusaurus，因為小恐龍很可愛，沒想到 Docusaurus 對於自己來說，更難用！不到一天的使用時間，決定再次換框架，使用了 Hugo 建置，雖然搬遷很煩躁，但開始搬遷時第一個反應是： 哇塞，太快了吧！ 應該會有很長的一段時間，使用 Hugo，因此也想紀錄這些建置過程，作為自己的筆記，也希望可以分享給大家。 ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:1:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"安裝 Hugo 官方在 macOS 底下說明了使用 brew 與 port 兩種安裝方式，我會比較推薦使用 brew，如果環境是 Windows 或是 Linux 的使用者，官方文件有提到相關的安裝方式，這裡就不再加以說明。 $ brew install hugo 安裝後，可以使用 hugo version 確認是否安裝完成。 $ hugo version hugo v0.92.2+extended darwin/amd64 BuildDate=unknown 若安裝完成後，到自己的專案路徑底下建立站台專案。 ### hugo new site [sitename] $ hugo new site quickstart ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:2:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"安裝主題 (theme) Hugo 提供了許多種主題，或是到 Google 搜尋，基本上挑選自己喜歡的即可，我這邊選擇的是 LoveIt。 進入到站台專案，並使用 git 將 LoveIt 主題下載下來。 $ cd quickstart $ git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:3:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"增加內容 通常內容都會放置在專案內的 content 資料夾中，可以手動新增，也可以使用 hugo new 的方式新增，會自動在 frontmatter 補上標題與時間的資訊。 $ hugo new posts/first.md 產生檔案後，就用 markdown 語法寫文章即可，這邊要提醒一點是使用圖片的方式，要使用 HTML tag，而不能使用 ![name](url) 的方式。 \u003c!-- 請參考下面的程式碼，使用時請手動刪除 {{與\u003c 和 \u003e與}} 之間的空格。--\u003e {{ \u003cimage src=\"folder/filename\" caption=\"This is a image.\" \u003e }} ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:4:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"瀏覽 當內容新增完後，使用 hugo server -D，然後在瀏覽器輸入 http://localhost:1313/，就可以瀏覽了。 我自己會偏好使用 hugo serve -e production，使用生產環境的方式進行預覽，畢竟是要產生靜態網頁部署至 github page 做使用。只不過當directory 或是 path 更新時，會有一些問題發生，但基本上重新編譯即可。 $ hugo server -D ### Or $ hugo serve -e production ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:5:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"部署至 github 瀏覽網站並確認完畢後，首先先執行一次 hugo，這樣會在專案資料夾底下產生一個 /public，裡面的檔案就是 hugo 產生的靜態網頁內容，進入到 /public，將這些檔案 push 到自己的 username.github.io 的專案，稍等一下下後到 https://username.github.io，應該就可以看到網頁了。 cd public git init git add . git commit -m 'my first deploy' git remote add origin git@github.com:username/repo.git git push -u origin master 若對 git 不太熟悉的話 (像我)，git 與 github 的相關資訊，會附在參考資料作為參考。 基本上上傳完成且能看到網頁內容後，自己的部落格應該就完成了，往後新增或編輯文章後，就是再使用 hugo 重新產生靜態內容，並透過 git 將靜態內容上傳後即可。 後續有時間會再說明 theme 設定與一些功能的建置(SEO、algolia 與 disqus…等)。 ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:6:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"參考資料 Hugo 官方網站 Hugo quickstart Hugo themes Github pages Git 教學：如何 Push 上傳到 GitHub？ ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:7:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["Go"],"content":"本篇文章基本上是介紹 Go 的複合類型（Array, Slice, Map）與內置函式，另外會簡單介紹 struct。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:0:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Arrays 如同其他程式語言，Go 也有 Array，Array 中的所有元素，都必須是指定的類型。 var x [3]int 此時會建立長度為 3 的 Array，但未指定初始值，上一章提到若未指定初始值，則預設值會是 Zero Value，在這個 Array 中，類型是 int，故初始值會是 0 。 若要指定初始值，則可以使用這個方式。 var x = [3]int{10,20,30} 也可以用 index 的方式指定初始值。 // index:value var x = [10]int{1,5:2} // [1,0,0,0,0,2,0,0,0,0] 若已經很明確知道，陣列內的所有數值，在宣告時則可以用 [...] 省略陣列的長度。 var x = [...]int{10,20,30} var y = [3]int{10,20,30} // 這兩個 Array 是一樣的。 在 Go 中只有一維陣列，但可以模擬出多維陣列。 var x [5][10]int 可以透過內置函式 len() 得到 Array 的長度。 fmt.Println(len(x)) 但在 Go 中，很少使用 Array，因為 Array 的大小會被視為是 Array 類型的一部分，[3]int是一種類型，[4]int是另一種類型。 因此： 不能使用變數來指定 Array 的大小，因為類型必須在編譯前解析，而不是在運作時解析。 不能使用類型轉換，無法將不同大小的 Array 轉換成相同的類型。 最好是知道需要的長度，否則盡量不要使用 Array。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:1:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Slices 若資料的長度會變化，且不想受到 Array 的類型限制時，應該使用 Slices，宣告的方式與 Array 極為相似，但不指定大小。 這樣會宣告一個長度為 3 的 Slice。 var x = []int{10,20,30} 也可以用 index 的方式指定初始值。 // index:value var x = []int{1,5:2,88} // [1,0,0,0,0,2,88] Slice 也可以模擬出多維的 Slice。 var x [][]int 比較大的差別在於，Slice 的 Zero Value 並不會是宣告時之類型的 Zero Value，而會是 nil，它是一種標示符號，代表某些類型缺少數值。 nil 也沒有類型，因此可以賦予值或是與其他不同類型的數值進行比較。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:2:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Slice 內置函數 len 在前面的例子中有使用過了 len ，傳入 Array 會獲得該 Array 的長度，len 也適用於 Slice。若傳入 nil Slice 會獲得 0。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:2:1","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"append append 用於附加值至 Slice。最少要兩個傳入參數： 一個任意類型的 Slice 一個該類型的數值。 var x []int x = append(x,10)// [10] // 可以同時附加多個數值。 x = append(x,20,30,40) //[10,20,30,40] // 甚至是附加 Slice。但需要使用...這個運算符 y := []int{50,60,70} x = append(x,y...) //[10,20,30,40,50,60,70] cap (Capacity) Slice 是一系列連續的數值，每個元素被分配到連續的記憶體位置，這樣可以快速讀取或寫入這些數值。每個 Slice 都有一個 Capacity，即保留的連續記憶體位置的數量。 當使用 append 附加數值至 Slice 時，長度也會增加，當長度達到 Capacity，代表沒有空間存放資料了，若又使用 append 附加數值時，則會分配有更大 Capacity 的 Slice，並將原本 Slice 的數值複製到新的 Slice 後，將新的數值附加到 Slice 的最後，並返回新的 Slice。 cap() 可以獲得該 Slice 目前的 Capacity。 但 Capacity 增長，視 Go 語言的版本不同，基本上都會是增長原本大小的一倍，當已經知道某組數值的確切長度時，是否能指定 Capacity 的大小而不造成記憶體的浪費呢? 此時可以透過 make 內置函數建立確切 Capacity 的 Slice。 make make 可以聲明指定長度、類型與容量的 Slice。 這樣會建立一個類型為 int、長度與容量為5的slice，由於它的長度為5，故它的第0個至第4個元素是有效元素，會被初始化為 int 的 Zero Value，也就是 0 。 x := make([]int, 5) 若要指定容量，則在傳入參數內加入所需的容量大小。 x := make([]int, 5, 10) 甚至建立一個長度為 0 的 Slice 也是可行的。 x := make([]int, 0, 10) // 但後面使用，記得用 append 附加數值，長度為 0 是沒辦法做 index 的。 記住，絕對不要指定一個小於長度的 Capacity，也盡量不要使用變數指定 Capacity。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:2:2","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"宣告 Slice Slice 在宣告時有不同的方式，但最主要的目標是將 Slice 增長的次數最小化，若 Slice 不會增長，請使用 var 建立 nil slice。 var data []int 若有初始值，或是 Slice 的數值不會改變，會建議就是以賦值方式宣告。 data := []int(1, 2, 3, 4) 若很清楚 Slice 需要多大，但不清楚內部的數值會是甚麼，請使用 make 宣告 Slice。 若以 Slice 作為 buffer 使用，則指定一個非 0 長度的 Slice。 若確定 Slice 的大小，則可以指定 Slice 的長度。 在其他情況下，使用 make 宣告 0 長度與指定 Capacity 的 Slice，並使用 append 增加數值。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:2:3","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Slicing Slices Slice 的表達式由一個起始偏移量和一個結束偏移量組成，並用 : 分隔。若省略起始偏移量，則為0，若省略結束偏移量，則為結尾。 x := []int{1, 2, 3, 4} y := x[:2] z := x[1:] d := x[1:3] e := x[:] fmt.Println(\"x:\", x) fmt.Println(\"y:\", y) fmt.Println(\"z:\", z) fmt.Println(\"d:\", d) fmt.Println(\"e:\", e) // 輸出 x: [1 2 3 4] y: [1 2] z: [2 3 4] d: [2 3] e: [1 2 3 4] 另外以上述的 Slice 表達式，他們之間是共享記憶體的。使用上請小心。 x := []int{1, 2, 3, 4} y := x[:2] z := x[1:] x[1] = 20 y[0] = 10 z[1] = 30 fmt.Println(\"x:\", x) fmt.Println(\"y:\", y) fmt.Println(\"z:\", z) // 輸出 x：[10 20 30 4] y：[10 20] z：[20 30 4] Copy 若我想要建立一個 Slice，並使用原始 Slice 的數值，但不共享記憶體的獨立 Slice 時，請使用內置的 Copy 函式。 Copy 函式有兩個參數，第一個是目標 Slice，第二個是來源 Slice，並會盡量把數值複製到目標，並返回複製的 element 數量。 x := []int{1, 2, 3, 4} y := make([]int, 4) num := copy(y, x) fmt.Println(y, num) z := make([]int, 2) num := copy(z, x) fmt.Println(z, num) // 輸出 [1 2 3 4] 4 [1 2] 2 也可以透過 Slice 表達式，複製部分的數值。 x := []int{1, 2, 3, 4} y := make([]int, 2) copy(y, x[2:]) // 若不需要返回值，不用特地設一個變數然後執行 copy()。 copy 也可以用來把 Slice 的某部分覆蓋至別的部分。 x := []int{1, 2, 3, 4} num = copy(x[:3], x[1:]) fmt.Println(x, num) // 輸出 [2 3 4 4] 3 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:2:4","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Strings and Runes and Bytes Go 使用一個 Bytes 序列代表一個 String。 var s string = \"Hello there\" var b byte = s[6] // t 前述提到的 Slice 表達式，也可以用在 String。 但建議在 String 每一個字元都是一個 Byte 大小時再使用。(e.g. emoji是4個bytes) 單個 rune 或是 byte 可以使用類型轉換成 string。 但常使用的 int ，透過類型轉換的話，會變成 ascii 而不是直接轉換，若要單純的把 int 轉換成 string，請使用 strconv.Itoa()。 參考資料 字串也可以轉成 rune slice 或是 byte slice，使用方式也不困難，通常會使用 byte slice 做轉換。 var s string = \"Hello, world!\" var bs []byte = []byte(s) var rs []rune = []rune(s) ","date":"2022-02-16","objectID":"/posts/go/go_note3/:3:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Map ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"intro Map 其實與其他程式語言相似，將一個數值關聯到另一個數值的類型。Map 的 Zero Value 是 nil。 var nilMap map[string]int 但這種方式，在寫入 nil 時會導致恐慌，可以透過另一個方法建立映射變量。 myMap := map[string]int{} 若知道確切的數值，可以用賦值宣告的方式建立Map。 宣告方式為 key:value，每組數值都用 , 分隔，即使是最後一組也要加上逗號。 rank := map[string]int{ \"I\" : 1, \"you\" : 2, \"she\" : 3, } 若知道 Map 的確切大小但不清楚內部數值，可以使用 make 建立有默認大小的 map。 ages := make(map[int][]string, 10) Map 與 Slice 相似的地方： 增加 key:value pair 數據時，Map 會自動增長。 若知道會有多少筆數據，則可以使用 make 建立有初數大小的 Map。 將 Map 傳遞給 len ，可以獲得 key:value pair 的數量。 Map 的 Zero Value 是 nil。 Map 沒有可比性，只能檢查是否等於 nil，但無法檢查兩個 Map 是否有相同的 key:value pair。 另外有些要注意的點： key 必須是可以比較的類型，像是slice或是map這種無法比較，無可比性的類型就不能使用。 若數據要按照順序處理，建議使用 Slice，若數據不用嚴格按照順序處理，則可以使用 Map。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:1","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Read and Write myMap := map[string]int{} myMap[\"Taipei\"] = 1 fmt.Println(totalWins[\"Taipei\"]) fmt.Println(totalWins[\"I-lan\"]) myMap[\"I-lan\"]++ fmt.Println(totalWins[\"I-lan\"]) // 輸出 1 0 1 透過 key 的方式分配 value，這邊要注意是使用 = 而不能使用 :=，若要讀取未分配 value 的 key 之 value 時，則會返回 Zero Value。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:2","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"The comma ok Idiom 那要如何知道 Map 中，我所需要的 key:value pair 是否在 Map 中？可以使用 comma ok Idiom 的方式區分 key:value pair 是否在 Map。 m := map[string]int{ \"hello\": 5, \"world\": 0, } v, ok := m[\"hello\"] fmt.Println(v, ok) v, ok = m[\"world\"] fmt.Println(v, ok) v, ok = m[\"goodbye\"] fmt.Println(v, ok) // 輸出 5 true 0 true 0 false ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:3","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Deleting from Maps 刪除 key:value pair 的方式，透過內置函數 delete即可， m := map[string]int{ \"hello\": 5, \"world\": 10, } delete(m, \"hello\") 若 key 不存在於 map 內，或是說 map 是 nil，則甚麼都不會發生 !! ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:4","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"(補充 : Using Maps as Sets) 因為 Go 沒有 set 這個類型，但可以透過 Map 去實現。 intSet := map[int]bool{} vals := []int{5, 10, 2, 5, 8, 7, 3, 9, 1, 2, 10} for _, v := range vals { intSet[v] = true 透過 map 與迴圈，將設定的數值與 bool 連結，若有的數值則設定為 true，其他未在內的數值，因為 bool 的 Zero Value，都會是 false。這樣使用上就可以達到 set 的功能。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:5","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Struct 若有想要組合在一起的相關數據時，應該訂意一個 struct。 type person struct{ name string age int pet string } 一個 struct 透過關鍵字 type、結構類型的名稱與struct組成。struct 內部則是field，由變數名稱與變數類型。 聲明 struct 後，就可以定義該類型的變數。 基本上這兩種方式，都會將 struct 內的所有 field 設定為 Zero Value。 var renne person lapis := person{} 若有初始值的話則是依據 field 宣告，記得按照順序，依據類型宣告。 nadia := person{ \"Nadia\", \"18\", \"cat\", } 或者是以類似 key:value pair 的方式宣告。可以不必按照順序宣告，可以指定部分變數即可，沒被指定的會被設定為 Zero Value。(建議用這種 !!) Tio := person{ name: \"Tio\", age: \"18\", pet: \"cat\", } struct 內的 field 用 . 進行訪問。 Tio.name = \"Tio Plato\" fmt.Println(Tio.name) ","date":"2022-02-16","objectID":"/posts/go/go_note3/:5:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Anonymous Structs(匿名結構) 簡單來說，就是實現一個 struct 但不需要先命名，稱為匿名結構。通常用在將外部數據轉換成 struct，或是將 struct 轉換成外部數據(e.g. json)，這被稱為unmarshaling and marshaling data。 pet := struct { name string kind string }{ name: \"Cute\", kind: \"cat\", } ","date":"2022-02-16","objectID":"/posts/go/go_note3/:5:1","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"比較與轉換結構 不同類型的結構之變數之間，是不能比較的，除非兩個struct的field具有相同的名稱、順序與類型，才允許進行比較與類型轉換。 在 struct 的比較中，若其中至少有一個匿名結構的話，若兩個結構的 field 有相同的名稱，則可以在不進行類型轉換的情況下進行比較，若兩個結構的 field 具有相同的名稱、順序與類型，還可以在兩個結構之間進行 assign。 type firstPerson struct { name string age int } f := firstPerson{ name: \"Bob\", age: 50, } var g struct { name string age int } // compiles -- can use = and == between identical named and anonymous structs g = f fmt.Println(f == g) ","date":"2022-02-16","objectID":"/posts/go/go_note3/:5:2","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) How to convert an int value to string in go ","date":"2022-02-16","objectID":"/posts/go/go_note3/:6:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"本篇文章將介紹類型與聲明，基本上接觸過程式語言的話，許多部份是相似的，僅有少處不同。 如同其他的程式語言，Golang 也有許多與相同的類型：Boolean、Integer、Float與String，後續會分別介紹不同的類型。 但我比較喜歡使用宣告，後面若看到宣告意同聲明。(Declarations) ","date":"2022-02-12","objectID":"/posts/go/go_note2/:0:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Zero Value 在 Golang 中，會默認 Zero Value分配給已經聲明，但未分配數值的任何變數，換句話說也可以被稱為預設值，不同的類型的 Zero Value 也有所不同。這裡列出了幾個常用的變數的 Zero Value。 【Zero Value 並不是代表為 0 !! 不同類型的變數有不同的 Zero Value !!】 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:1:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Literal Literal 簡單來說是在程式碼中賦予的數值、字元或是字串，例如： func main(){ fmt.Println(\"Hello World\") } 這裡的 \"Hello World\" 就是字串型態的 Literal。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Integer literal 若 Literal 為整數時，透過不同的前綴代表不同的進制方式。另外，當整數字串過長時，可以透過 underscore 將數字進行分組，提高閱讀的效能，但不能在該數字的開頭或結尾使用。 0b111 // 2進制 0o111 // 8進制 0x111 // 16進制 0111 // 這也是代表8進制，但容易搞混，不要使用這種方式!! //b,o,x可以用大寫B,O,X代替，會是一樣的作用。 a := 1111 b := 1_111 // 這兩組代表的是相同的數字。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:1","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Float literal 若 Literal 為 float 時，可以使用字母 e 和數字組合出要使用的指數數值。與 Integer Literal 一樣能使用 underscore 提高閱讀的效能。 1.11e2 // 111.0 0.111_111 // 0.111111 另外， Float Literal有一種十六進制的表示方式。以 0x 作為前綴，指數後面以字母 P 為開頭進行運算。 0x1p-2 // 1.0 * (2^-2) = 1.0/4 = 0.25 0x2.p10 // 2.0 * 2^10 = 2048.0 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:2","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Rune literal 通常代表字元，會用單引號包起來，常用來表示 Unicode 字元。 'a' // Unicode '\\141' // 8進制 '\\x61' // 16進制 // 另外還有一些較特別且常使用的符號。 '\\n' // newLine '\\t' // tab '\\'' // 單引號 '\\\"' // 雙引號 '\\\\' // 反斜線 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:3","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"String literal 如同前面所提到的 \"Hello world\"，會使用雙引號建立一個字串，並包含0個或多個字元，若要使用換行、反斜線與雙引號時，請記得透過反斜線進行轉義，使用方式與前面介紹 Rune literal 的符號是一樣的。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:4","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Boolean 透過 bool 表示布林變數，布林具有 true 或 false兩種數值，bool的 Zero Value 為 false。 var flag bool var status = true ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:5","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Numeric Types (數值類型) 基本上可分為三類：整數、浮點數與一些不常使用的複雜類型。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:3:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"整數 (integer) 基本上有各種大小的有符號數與無符號數。所有整數類型的 Zero Value 為 0 ，整數類型如下表所示： 類型名稱 數值範圍 int8 –128 to 127 int16 –32768 to 32767 int32 –2147483648 to 2147483647 int64 –9223372036854775808 to 9223372036854775807 uint8 0 to 255 uint16 0 to 65536 uint32 0 to 4294967295 uint64 0 to 18446744073709551615 另外， int 與 uint 會因為開發環境的 CPU 而會是不同類型的整數，在32位元的CPU上會是 int32,uint32，在64位元的CPU上會是int64,uint64。 然而，這麼多種的整數類型，要如何知道在何時使用其中一個呢？可以透過下述的三條規則去決定： 若開發或使用在具有特定大小的整數之格式或協議，則使用相應的整數類型。 若是撰寫一個用在任何整數類型的函式庫之函式時，請盡可能寫兩個函式，一個用 int而另一個使用uint。更加嚴謹的狀況下能規定大小會更好。(e.g. int64,uint64) 其他情況下，使用 int 即可，除非因為效能或是特定目的，已知需要明確的整數大小與有無符號，否則請使用 int。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:3:1","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"浮點數 (float) 基本上分為兩種， float32與float64，浮點數類型的 Zero Value 為 0。 類型名稱 最大絕對值 最小(非零) float32 3.40282346638528859811704183484516925440e+38 1.401298464324817070923729583289916131280e-45 float64 1.797693134862315708145274237317043567981e+308 4.940656458412465441765687928682213723651e-324 除非是記憶體問題，否則請使用精度較好的 float64，但精度較好也不能明確的表示十進制數值，請不要使用浮點數代表金錢或是需要精確十進制表示的數值。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:3:2","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"複雜 (complex) 基本上用於複數，有complex64與complex128兩種。(想到電學的交流電計算(頭痛))。但因為複數很少使用，我認為僅要知道有這個內置的類型即可。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:3:3","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"運算子 常見的運算子 +, -, *, /, %，整數除法的結果仍會是整數，若需要有浮點數效果，則需使用類型轉換。 另外可以將任何運算子與 = 做結合修改變數：+=, -=, *=, /=, %=。 比較的運算子則有 ==, !=, \u003e=, \u003e, \u003c, \u003c= 操作運算符則有： \u003c\u003c // shift left \u003e\u003e // shift right \u0026 // logical AND | // logical OR ^ // logical XOR \u0026^ // logical AND NOT 一樣可以與 = 結合修改變數：\u0026=, |=, ^=, \u0026^=, \u003c\u003c=, \u003e\u003e= ","date":"2022-02-12","objectID":"/posts/go/go_note2/:4:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"類型轉換 許多語言也有許多數字類型，且會在需要時自動類型提升，但自動轉換時可能會發生複雜的問題，並會有意想不到的結果。Go 作為嚴謹性高的語言，不允許自動類型提升，需要時要使用類型轉換才行。 var x int32 = 10 var y int64 = 20 var z int64 = int64(x) + y var w float64 = float64(y) + float64(z) ","date":"2022-02-12","objectID":"/posts/go/go_note2/:5:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"聲明 (var, :=) 宣告變數有許多方法，而每一種方法都傳達了有關如何使用該變數的資訊。 最冗長的方法是使用 var、類型並賦予值。 var x int = 1 若等號右側的類型，是變數的預期類型，則可以省略等號左側的類型， var x = 1 // type is int. 若宣告變數並將其設為Zero Value，則將等號右側刪除。 var x int 並可以一次宣告多個變數，可以是相同的類型，或是不同的類型。 var x,y int = 1,2 var i,j int var a,b = 1,\"Hi\" 還可以使用宣告列表(declaration list)一次宣告多個變數，但適用在函式外。 var( x int y = 1 a,b = 1,\"Hi\" i,j string ) 在函數中時，可以使用 := 替換掉 var 使用類型推斷的聲明。 var x = 10 x := 10 // 這兩行程式碼的作用是相同的。 一樣可以同時聲明多個變數，但這種不帶類型的宣告方式只能在函數中使用。 a,b := 1,\"Hi\" := 可以允許為現有的變數賦值，只要 :=左側有一個新的變數，則任何其他變數都可以存在。 x := 1 x,y := 2, \"Hi\" 在package宣告變數的話，則必須使用 var 宣告，在函式外使用 :=是不允許的。 另外有些情況下，盡量不要使用:= 將變數初始化為 Zero Value 時，請使用 var 進行宣告，因為 Zero Value 是有意的。 賦值的預設類型與變數的類型不同時，請使用 var。 x := byte(20) // 這個不好，賦值的預設類型是int，但變數是 byte。雖然可以用類型轉換處理這個議題，但用 var 直接宣告清楚會好一點。 var x byte = 20 := 可以同時宣告新變數與現有變數，但使用上可能會有 shadow variable 的狀況發生，建議宣告新的變數時用var宣告，並用 = 賦予數值。 最後，盡量不在函式外宣告變數。會難以追蹤。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:6:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"const 簡單來說，就是宣告一個數值，且該數值是不可變的。 const x int64 = 1 const ( a = 1 b = 2 ) ","date":"2022-02-12","objectID":"/posts/go/go_note2/:7:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"變數命名 基本上沒有硬性規定，但還是建議遵循以下幾點。 當變數名稱為多個單字組成時，採用駝峰式大小寫命名。 var studentScore int = 100 變數名稱的第一個字母會確定是否能在 package 外被存取。 在函式中，盡量使用較短的變數名稱，當該變數的範圍愈小，名稱就應該愈短。(e.g.跑迴圈時常使用 i 為變數(integer)) Go 是強類型語言，是不需要在變數名稱中加入預期的變數類型，與其加入變數類型，最好是再想一個更完整的名稱來宣告這個變數代表甚麼。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:8:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"參考資料 Learning Go(書籍) Basic Types and Basic Value Literals ","date":"2022-02-12","objectID":"/posts/go/go_note2/:9:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"本篇基本上是說明golang的環境建置，編譯，環境先建置好，後續才能進行開發。另外會再提到一些程式碼的品質工具等。基本上在開發時都希望程式碼能具有較好的品質與一致的規範，降低後續維護的成本。 ","date":"2022-01-15","objectID":"/posts/go/go_note1/:0:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"Install go 我自己的開發環境是在 macos 底下，基本上透過 brew install go 就會安裝完成。如果網路沒問題的話? $ brew install go 在 Windows 環境下，可以透過 Chocolatey 進行安裝，此外官方網站有提供相關壓縮檔與安裝檔，挑選自己使用的平台下載相關檔案後，解壓縮或是進行安裝即可。 安裝完成後，可以透過 go version指令，確定是否安裝完成。 $ go version go version go1.15.2 darwin/amd64 ","date":"2022-01-15","objectID":"/posts/go/go_note1/:1:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"First program 建立一個檔案，通常第一支程式都會是設法在 Terminal 上顯示 Hello world!，故這程式碼的檔名先命名為 hello.go，並編輯該檔案。 $ touch hello.go $ vim hello.go 程式碼大致如下。 package main import \"fmt\" func main() { fmt.Println(\"Hello world!\") } 儲存該檔案後，在 Terminal 執行下列指令，此時應該能看到 Hello world! 顯示在Terminal上。 $ go run hello.go Hello world! go run 指令會將程式碼在臨時目錄中編譯成 binary 後執行，執行完成後刪除這個檔案，若要編譯成 binary 並使用，則使用 go build 。 $ go build hello.go 此時會產生一個hello的檔案，執行該檔案一樣會看到 Hello world! 顯示在Terminal上。 $ ./hello Hello world! ","date":"2022-01-15","objectID":"/posts/go/go_note1/:2:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"Format go 語言對於撰寫格式相當嚴格，須嚴格使用標準格式，雖然在開發上會稍有不適，但對於多人開發與維護時，固定格式的程式碼會使這些工作更加容易。 也因為格式有嚴格標準，go也提供一個開發工具，go fmt，這個工具會自動重新格式化程式碼使齊符合標準格式。且目前有 go fmt 的加強版 goimports，有新的且更好用的工具，那就用新的工具吧。喜新厭舊 嘗試一下，修改前面提到的 hello.go，將其改成下面的程式碼，改動不大，僅是刪除一行縮排。 package main import \"fmt\" func main() { fmt.Println(\"Hello world!\") } 安裝 goimports，在 Terminal 中使用下列指令下載 goimports。 $ go install golang.org/x/tools/cmd/goimports@latest 安裝完成後，使用以下指令，重新開啟該檔案會發現那行縮排被重新加了回去。代表在函式中，程式碼要縮排為嚴格標準格式的規範。 $ goimports -l -w . -l : 告訴goimports，將格式不正確的檔案顯示在 Terminal上。 -w : 告訴goimports，直接修改該文件。 . : 路徑的意思，這邊用 . 代表目前的目錄與所有子目錄的所有檔案。 注意，盡量在編譯前執行 go fmt 或 goimports ，確保程式碼的格式沒有問題。 ","date":"2022-01-15","objectID":"/posts/go/go_note1/:3:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"Linting and Veting goimports 能確保程式碼是大家慣用的格式，但在其他規範上則不會做檢查，像是變數命名規則，程式碼樣式與潛在錯誤等。高品質的程式碼請參考 Effective Go 與 Go Code Review Comments 兩個網站。當然，也有相關的工具能處理這些問題，目前常見的有 golint、go vet 工具。 golint，嘗試確保程式碼會依循文件，會建議更改像是變數名稱、public method 等，他的建議並不代表是錯誤，只是希望程式碼具有特定的格式並遵循特定的規則。 go vet，可以檢測一些有效的但有可能存在錯誤的程式碼。像是將錯誤數量的參數傳遞給 method，或使用不恰當的 Function。 除了這兩個工具以外，另外還有許多第三方的工具可以檢查程式碼樣式與潛在錯誤，然而愈多的工具，在進行檢查時就會花費愈多時間。其中，golangci-lint結合了上述兩項與其他相關的程式碼品質工具。golangci-lint 文件 且這個工具可以在開發目錄的根目錄中，透過一個 .golangci.yml 的檔案，根據需求設定啟用那些工具與檢查那些檔案。.golangci.yml 文件 $ golangci-lint run 注意，一樣盡量在編譯前執行 golangci-lint，或是其他相關的工具，盡可能在編譯前找出錯誤或有疑慮的部分，確保程式碼的品質。 ","date":"2022-01-15","objectID":"/posts/go/go_note1/:4:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"Makefile 也就是說，在寫完程式後要進行編譯，我需要經常做這些事情： $ goimport -l . $ golangci-lint run $ go run [targetPath] ### 或是 $ go build [targetPath] 太麻煩了 !!! 透過 Make、shellscript 或其他的腳本語言，可以省略掉許多手動的步驟，降低重複動作的時間。 但此篇文章說的是關於程式設計，我會傾向用 make 來設計： 建立一個檔案名為Makefile，並編輯該檔案： .DEFAULT_GOAL := build fmt: goimports -l -w . .PHONY:fmt lint: golangci-lint run *.go .PHONY:lint build: lint go build hello.go .PHONY:build 並使用根目錄下使用 make 指令。 $ make 若順利的話，則會依序進行 goimports、golangci-lint 與 go build，且不用再重複下多次指令，一個 Make 就足夠了，只是要做一些前置準備。(Makefile)，另外，因為這篇主要是說明 golang 的環境建置， Makefile 的說明以後有空會再另外寫一篇說明(?) ","date":"2022-01-15","objectID":"/posts/go/go_note1/:5:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go(書籍) Effective Go Go Code Review Comments goimports golangci-lint .golangci.yml ","date":"2022-01-15","objectID":"/posts/go/go_note1/:6:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Infra"],"content":"自己常用的 Linux 是 Debian，從 Debian 6(squeeze) 用到 Debian 10(buster)。Debian 在 2021.08.14 時釋出了 Debian 11(bullseye)，自己以往都是至官方連結下載新版的 ISO 重新安裝，這次則想說透過升級的方式進行更新，且這也是 Debian 著名的功能，故想於這次嘗試之。 (其實是有Service在運作並做一些測試，不想重弄) ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:0:0","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"準備 備份你所有的資料。（文件、圖片、設定檔、驅動程式等） 關閉所有的應用程式與服務。 關閉或刪除任何的個人套件庫(Personal Package Archive, PPA)，更新完成後再開啟或新增即可。 盡可能確保網路是穩定的。 保留一些時間進行升級。 ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:1:0","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"更新步驟 ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:2:0","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"更新現有的 package 開啟terminal，輸入 apt update \u0026\u0026 apt upgrade 更新套件索引(package indexes)與套件（packges），需要先將更新目前的packages。 root@server:~# apt update \u0026\u0026 apt upgrade ### 注意使用者身份，不是root的話，請加上sudo ### user@server:~$ sudo apt update \u0026\u0026 sudo apt upgrade ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:2:1","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"更新來源(source.list) 修改apt的source.list，將來源由buster更改為新的bullseye。修改 /etc/apt/source.list (注意編輯權限)，不一定要使用vim，用自己喜歡的編輯器即可(e.g. emacs, nano)，請記得編輯設定檔前記得備份！！！ user@server:~$ sudo cp /etc/apt/source.list /etc/apt/source.list.bak user@server:~$ sudo vim /etc/apt/source.list 修改前的檔案 修改前的檔案\" 修改前的檔案 修改後的檔案 修改後的檔案\" 修改後的檔案 這裡再補充介紹 main, contrib, non-free main: 主要為完全符合 Debian 自由軟體指南(Debian Free Software Guidelines, DFSG)的所有package。 contrib: 為開源但依賴於 non-free 的 package。 non-free: 為不符合 Debian 自由軟體指南的 package。 ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:2:2","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"升級 先使用 apt update 確認第二步的編輯是否沒有問題，若無錯誤訊息再進行 apt full-upgrade。 user@server:~$ sudo apt update user@server:~$ sudo apt full-upgrade 途中會有一些訊息需要選擇。 顯示有關packages更新的新聞。按q退出。 Information about package update\" Information about package update Package configuration，請選擇 \u003cYes\u003e Package configuration\" Package configuration 相關package的configuration，請依據需求設定，建議用 N 保留設定。 Options description : Y or I : install the package maintainer’s version (安裝維護者版本的package，會覆蓋掉該檔案的設定。) N or O : keep your currently-installed verstion (保留目前安裝的版本。) D : show the differences between the versions (顯示版本之間的差異。) Z : start a shell to examine the situation (啟動一個shell檢查情況。) 完成升級後，重新啟動系統。 user@server:~$ sudo systemctl reboot ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:2:3","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"確認 透過 lsb_release -a 指令進行確認，可以發現已經從 buster 升級至 bullseye了。 user@server:~$ lsb_release -a Distributor ID: Debian Description: Debian GNU/Linux 11 (bullseye) Release: 11 Codename: bullseye 確認完成後，使用 apt --purge autoremove 刪除不再需要且不必要的packages。 user@server:~$ sudo apt --purge autoremove ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:2:4","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"結論 第一次自己升級 Debian ，坦白說並沒有想像中的困難，有做好備份可以降低升級上的壓力。基本上都是apt在負責，只要有依據文件設定 /etc/apt/source.list，應該不會構成太大的問題。 ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:3:0","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"參考資料 man apt debian.org Debian管理者手冊 Debian自由軟體指南,DFSG main,contrib,nonfree解釋 ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:4:0","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Misc"],"content":"一來是學過一些網路與系統服務的知識與技能，但一直都沒有做詳細的筆記，簡單來說這筆記只有自己看得懂，自己懂是一回事，要讓別人懂又是另一回事。 二來是以寫筆記或是技術文章的方式，可以促使自己學習好一點，深入一點，自己做開發或設定時，有些功能或參數可能就是把它 turn on turn off，而不會去想說這個是代表什麼，寫文章的話則必須要去解釋這個功能，進而讓自己深入學習。 三來是受大神同學影響，因為他真的很強，我也想跟他一樣強(? 有空會放上自己以前做過的服務或遇到的問題處理方式(troubleshooting)，往後學習新技能時或遇到新問題時，也盡量寫成文章記錄做出回饋。（主要是以技術文章寫筆記） 文筆不太好，若有問題請多指教。 ","date":"2021-12-28","objectID":"/posts/misc/start/:0:0","tags":["Misc"],"title":"Start","uri":"/posts/misc/start/"},{"categories":null,"content":"About ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Announcement 沒有甚麼新消息。 ","date":"0001-01-01","objectID":"/about/:1:1","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Info 各位好，這裡是瑋瑋。 請多指教。 ","date":"0001-01-01","objectID":"/about/:1:2","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"My TimeLine Cameo Communications, Inc. Software Engineer 2022 function non0plural(number, name) { if (number == 0) { return \"\" } if (number 1) { return number + \" \" + name + \"s\" } return number + \" \" +name } el = document.querySelector(\"#moment\"); function refresh() { start = dayjs(\"2022-06-06\") now = dayjs() total_months = now.diff(start, \"M\", true) months = total_months % 12 years = Math.floor((total_months) / 12) el.innerHTML = non0plural(years,\"year\")+\" \"+non0plural(months.toFixed(8),\"month\") } window.setInterval(refresh, 100); Null 6 months Learn golang. Build my blog. Review my knowledge and prepare interview… 2022 National Taipei University of Technology 2 years M.S. Student in Wireless and Broadband Networks Lab Major in Computer Science and Information Engineering. 2021 Taiwan Network Information Center 1 year 8 months Part-time in TWCERT/CC. Implement script to process a large amount cyber security data. Optimize existing script, reduce time of processing. ( best case : -95% ) Management and troubleshooting Web services on Windows Server and Linux(CentOS). Analyze cyber security incidents from people. 2021 The 49th National Skills Competition Skills : 資訊網路布建 (Information Network Cabling) Awards : 備取國手 (Silver medal) Optical fibre cabling and structured cabling system. Smart Home/Office Application. Troubleshooting and Measuring for copper and fibre cabling. 2019 CHT Security Co., Ltd. 2 months Intern. ⚠️ Secret !! ⚠️ 2018 Taiwan Academic Network Roaming Center 8 months Part-time. Troubleshoot problem about RADIUS server. Build environment and service test. 2018 ","date":"0001-01-01","objectID":"/about/:1:3","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"SkillTree 下面是我在至少一個計畫、作業或工作中使用過的技能。這並不意味著我知道他們的一切。 另外也列出了學習中與正在學習的技能。 比較常用的 Framework : Hugo Language : C/C++, Python, Shell Script System \u0026 Networking : Windows Server 2008/2012, Debian-based Linux Distributions, Cisco Networking, Tool : Vim, Visual Studio Code, Iterm2, Telegram bot 學習中技能 Language : Go, C Tool : git, Github Actions 計畫要點的 Database : PostgreSQL, Elasticsearch System \u0026 Networking : Amazon Web Service Tool : Ansible 暫時封存的 Database : MySQL Framework : Vuepress Language : Java, Javascript System \u0026 Networking : CentOS, Cabling(Optical fibre, Copper) ","date":"0001-01-01","objectID":"/about/:1:4","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"補充 E子是我的信仰，也是這個 ID 的由來。 ","date":"0001-01-01","objectID":"/about/:1:5","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"About Blog ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Info 我會在這裡放上自己寫的軟體、系統與網路相關的筆記，與自己在開發或是故障排除的經驗。 除此之外的會在 medium 分享。 目前 blog 是由 Hugo 產生，主題是修改過後的 LoveIt，並由 Github Actions 替我編譯產生靜態網頁後，push 至 Github page 上。 ","date":"0001-01-01","objectID":"/about/:2:1","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Log 2021/12/28 : 開始。 2022/02/13 : 更改 Framework，從 Vuepress 搬遷至 Docusaurus。 2022/02/14 : 更改 Framework，從 Docusaurus 搬遷至 Hugo (theme:LoveIt)。 2022/03/03 : 脫離地端建置，改用 Github Actions 建置網頁。 2022/07/06 : 更新留言服務，從 disqus 轉至 utterances。 ","date":"0001-01-01","objectID":"/about/:2:2","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"License Info Attribution-NonCommercial 4.0 International (CC BY-NC 4.0) ","date":"0001-01-01","objectID":"/about/:2:3","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Link ","date":"0001-01-01","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"友站連結 O3R ","date":"0001-01-01","objectID":"/about/:3:1","tags":null,"title":"About","uri":"/about/"}]