[{"categories":["Infra"],"content":"當我們開始定期使用 Ansible 時，有時會想讓自己的 playbook 運行得更快。 本篇文章將簡述減少 Ansible 執行 playbook 之所需時間的一些方法。 ","date":"2023-08-25","objectID":"/posts/ansible/10_faster/:0:0","tags":["Ansible","Infra"],"title":"Ansible - How to go faster","uri":"/posts/ansible/10_faster/"},{"categories":["Infra"],"content":"SSH ","date":"2023-08-25","objectID":"/posts/ansible/10_faster/:1:0","tags":["Ansible","Infra"],"title":"Ansible - How to go faster","uri":"/posts/ansible/10_faster/"},{"categories":["Infra"],"content":"Multiplexing and ControlPersist Ansible 使用 SSH 作為主要的傳輸機制，SSH 是基於 TCP 傳輸協定，設備之間要先協商該次連接，完成後才實際進行傳輸行為。 但是，多次的協商累積的時間下來也不小，這時候就造成了時間浪費。 而且 Ansible 執行 playbook 時，會建立許多 SSH 連接，這都是造成浪費的兇手。 我們可以透過 Multiplexing 來降低這些浪費。 通常在 Linux or macOS，是使用 openSSH，而 openSSH 支援 Multiplexing 的最佳化，也被稱為 ControlPersist。 啟用 Multiplexing 後，將發生以下情況： 第一次用 SSH 連接到主機時，OpenSSH 會啟動一個連接。 OpenSSH 建立與遠端主機關聯的 Unix domain Socket（Control Socket）。 下次用 SSH 連接到主機時，OpenSSH 將使用 Control Socket 與進行傳輸，而不是建立新的 TCP 連接。 不過呢，Ansible 自動使用 Multiplexing，這邊只要知道 Multiplexing 是什麼就好了(吧) ","date":"2023-08-25","objectID":"/posts/ansible/10_faster/:1:1","tags":["Ansible","Infra"],"title":"Ansible - How to go faster","uri":"/posts/ansible/10_faster/"},{"categories":["Infra"],"content":"Pipelining [connection] pipelining = True 好了，把他設定為 True 就好。 複習一下 Ansible 執行流程： 將根據正在使用的模組產生 python script。 將 python script 複製到主機。 執行 python script。 透過啟用 pipelining，則 Ansible 會透過執行許多模組，而不是將檔案傳輸到遠端主機上來執行。 一來減少檔案傳輸的時間，二來減少了網路連接，透過這個方式來加快速度。 不過這個方式，經常一開始會因為 requiretty 出錯，這時候使用 visudo 修改 sudo 即可 : $ visudo #找到這行 Defaults requiretty # 加上註解 #Defaults requiretty ","date":"2023-08-25","objectID":"/posts/ansible/10_faster/:2:0","tags":["Ansible","Infra"],"title":"Ansible - How to go faster","uri":"/posts/ansible/10_faster/"},{"categories":["Infra"],"content":"Mitogen Mitogen是一個第三方 Python lib，用於設計分散式自我複製程式。 Mitogen 在 Ansible 上運行時。只需要更改很少的設定，它使用純 Python 取代 Ansible 以 shell 為中心的實現， 並透過 SSH tunnel 使用更高速的 remote procedure call。 Warning 請注意，我在撰寫本篇文章時，Mitogen 僅支援 Ansible 2.10 以下的版本。 在 Ansible Controller 上安裝 Mitogen： $ pip3 install --user mitogen 也可以去下載 Mitogen，這邊我不提供路徑了。 要將 mitogen 設定為 ansible 中的strategy，修改 ansible.cfg： [defaults] strategy_plugins = /path/to/strategy strategy = mitogen_linear ","date":"2023-08-25","objectID":"/posts/ansible/10_faster/:3:0","tags":["Ansible","Infra"],"title":"Ansible - How to go faster","uri":"/posts/ansible/10_faster/"},{"categories":["Infra"],"content":"Cache 我們先前有使用動態變數，那時候也有提到 gather_facts: false，這是將 fact cache 關閉。 因為動態變數是需要花時間去執行相關程式並取值回來，這邊也是要花費時間的。 所以我們使用 fact cache 來暫時儲存相關的數值，此時就不用每次執行時都重新取一次數值，達到節省時間的目的。 [default]gathering = smartfact_caching_timeout = 86400這時候就不要在 playbook 內設定 gather_facts，會影響 gathering 的運作。 gathering 在 cache 中找不到 fact ，才會去做取值的動作。 ","date":"2023-08-25","objectID":"/posts/ansible/10_faster/:4:0","tags":["Ansible","Infra"],"title":"Ansible - How to go faster","uri":"/posts/ansible/10_faster/"},{"categories":["Infra"],"content":"JSON 我們可以將 cache 存成 json 檔案。 [default]gathering = smartfact_caching_timeout = 86400fact_caching = jsonfilefact_caching_connection = /path/of/cache","date":"2023-08-25","objectID":"/posts/ansible/10_faster/:4:1","tags":["Ansible","Infra"],"title":"Ansible - How to go faster","uri":"/posts/ansible/10_faster/"},{"categories":["Infra"],"content":"Redis 除了 JSON 以外，也可以將 cache 寫進 Redis 內，但 Redis 我不熟，這邊簡單提一下設定。 [default]gathering = smartfact_caching_timeout = 86400fact_caching = redis","date":"2023-08-25","objectID":"/posts/ansible/10_faster/:4:2","tags":["Ansible","Infra"],"title":"Ansible - How to go faster","uri":"/posts/ansible/10_faster/"},{"categories":["Infra"],"content":"Parallelism 對於每一個 task，Ansible 都會以平行的方式連接到目標主機並執行任務，但不一定會平行連接到所有主機。 連接數是透過 ANSIBLE_FORKS 這個參數來決定，預設值為 5，代表同時有五個 Parallelism Processes 在執行。 $ export ANSIBLE_FORKS=10 # 這樣就修改為 10 個 也可以在 ansible.cfg 中設定： [defaults]forks = 10不過，取決於電腦性能，太多 forks 反而會導致執行速度降低。 ","date":"2023-08-25","objectID":"/posts/ansible/10_faster/:5:0","tags":["Ansible","Infra"],"title":"Ansible - How to go faster","uri":"/posts/ansible/10_faster/"},{"categories":["Infra"],"content":"Async 在執行 tasks 時，會是依序進行，先完成 task1 後再緊接著執行 task2，但兩件事情有時是不相干的，是可以同時進行的，這時候我們可以透過 async 讓 task2 在 task1 完成前執行。 另外，有些 tasks 花費的時間會很長，會比 ssh 超時時間還要長，一樣可以用 async ，並使用 polling 的方式直到 tasks 執行完畢。 task:- name:This is sleeping.command:/bin/sleep 30async:90# 允許執行多長時間，如果超過這個數值，會自動停止與這個 task 相關的 processpoll:0# 確認多久輪詢一次，如果為 0 就是直接執行下一個 task。register:linux_sleep# 後續要取得 result 要用的。- name:Get resultasync_status:# 用來檢查 task 的狀態jid:\"{{ linux_sleep.ansible_job_id }}\"# 透過我們在上一個 task 所註冊的變數。register:resultuntil:result.finished# 直到 result 變數中的 finished 為 True（即操作完成）之前，將不斷重試此檢查。retries:3600# 最多重試3600次","date":"2023-08-25","objectID":"/posts/ansible/10_faster/:6:0","tags":["Ansible","Infra"],"title":"Ansible - How to go faster","uri":"/posts/ansible/10_faster/"},{"categories":["Infra"],"content":"結論 簡單結論一下，當我們撰寫好 playbook 與相關設定後，我們可以透過前述的設定，讓 ansible 運行得更快。 不過呢，有些工具不能在最新的環境上使用，此時就需要等待，或是自己改寫相關工具，另外有些設定不一定會讓 ansible 運行的更快，可能需要多次嘗試才能夠找出較佳的設定。 ","date":"2023-08-25","objectID":"/posts/ansible/10_faster/:7:0","tags":["Ansible","Infra"],"title":"Ansible - How to go faster","uri":"/posts/ansible/10_faster/"},{"categories":["Infra"],"content":"參考資料 Ansible: Up and Running: Automating Configuration Management and Deployment the Easy Way (3rd edition) Mitogen for Ansible Asynchronous actions and polling ","date":"2023-08-25","objectID":"/posts/ansible/10_faster/:8:0","tags":["Ansible","Infra"],"title":"Ansible - How to go faster","uri":"/posts/ansible/10_faster/"},{"categories":["Infra"],"content":"這篇文章會簡單說明 roles 是什麼， roles 的結構與如何設計一個簡單的 roles，另外會稍微說明 ansible-galaxy，一個知名的共享 roles 工具。 ","date":"2023-07-07","objectID":"/posts/ansible/08_roles/:0:0","tags":["Ansible","Infra","roles","ansible-galaxy"],"title":"Ansible - Roles","uri":"/posts/ansible/08_roles/"},{"categories":["Infra"],"content":"Roles Roles 可以讓我們根據已知的資訊，自動載入相關的變數、文件與 task 等。 透過 Roles 可以讓我們更容易重複使用，也方便與他人分享。 ","date":"2023-07-07","objectID":"/posts/ansible/08_roles/:1:0","tags":["Ansible","Infra","roles","ansible-galaxy"],"title":"Ansible - Roles","uri":"/posts/ansible/08_roles/"},{"categories":["Infra"],"content":"產生 roles 我們先用 ansible-galaxy 來產生一個 roles （這樣比較快啦）。 $ ansible-galaxy role init --init-path playbooks/roles database - Role database was created successfully 這樣會以 database 為名稱，初始化一個 roles。 ansible-galaxy 是一個很好用的工具，後面會提到他。 ","date":"2023-07-07","objectID":"/posts/ansible/08_roles/:1:1","tags":["Ansible","Infra","roles","ansible-galaxy"],"title":"Ansible - Roles","uri":"/posts/ansible/08_roles/"},{"categories":["Infra"],"content":"基本架構 基本上每一個 role 都會有一個名稱，並且會放置在 roles 這個目錄底下。 $ tree # 這邊我拿之前實驗的目錄當例子。 roles ├── database │ ├── README.md │ ├── defaults │ │ └── main.yml │ ├── files │ ├── handlers │ │ └── main.yml │ ├── meta │ │ └── main.yml │ ├── tasks │ │ └── main.yml │ ├── templates │ ├── tests │ │ ├── inventory │ │ └── test.yml │ └── vars │ └── main.yml 基本上不同的目錄代表不同的含義： task : 主要的 task ，這邊會是 roles 執行的入口。 file : 這邊會存放要上傳到 host 的檔案或 script。 templete : 這邊保存要上傳到 host 的 Jinja2 template。 handler : 主要的 handler。 vars : 通常不該被改變的變數。 defaults : 可以更改的預設變數。 meta : 有關這個 role 的資訊。 test : 測試的地方。 每個單獨的檔案都是可選的，例如說我們的 role 沒有 handler，就不需要去建立一個空的。 另外許多功能先前已經說明過，這邊只會先介紹最基本的 task 跟 variable，如果其他的功能不太熟悉，可以看先前的文章，或是後面待會說明 ansible-galaxy 時，下載其他大神的 roles 來參考。(偷懶啊！) ","date":"2023-07-07","objectID":"/posts/ansible/08_roles/:1:2","tags":["Ansible","Infra","roles","ansible-galaxy"],"title":"Ansible - Roles","uri":"/posts/ansible/08_roles/"},{"categories":["Infra"],"content":"task 前面提到 task 是 roles 執行的入口。我們先修改 task 中的 main.yml，並讓他 print 一些系統資訊。 ---- name:Echo some message.debug:msg:\u003e-os_family: {{ ansible_facts.os_family }}, distro: {{ ansible_facts.distribution }} {{ ansible_facts.distribution_version }}, kernel: {{ ansible_facts.kernel }}接著修改或是新增 playbook，我這邊是又新增 roles.yml 來測試。 ---- hosts:vagrant1roles:- role:database然後使用 ansible-playbook 執行 roles.yml，可以看到該台主機相關的資訊。 Question 這樣跟我們之前用的有什麼不同，不就只是把 playbook 換個地方然後引進來使用嗎？ 我們目前就只有數個 playbook，管理三台由 vagrant 產生的機器，如果我們有數百甚至數千的 playbook 跟 host，那使用上可能會遇到大量的重複使用，且在管理上也是要花費很多時間且難以理解。 將做好的功能做成 role，來讓其他 playbook 可以重複使用，以提高 ansible 使用上的靈活度。 ","date":"2023-07-07","objectID":"/posts/ansible/08_roles/:1:3","tags":["Ansible","Infra","roles","ansible-galaxy"],"title":"Ansible - Roles","uri":"/posts/ansible/08_roles/"},{"categories":["Infra"],"content":"default, var 前面提到，這兩個地方是放置變數的，差別只在一個經常變動，另一個則不經常變動。 我們修改 default 跟 var 中的 main.yml default/main.yml ---# defaults file for databasedefault_test:\"I am default\"vars/main.yml ---# vars file for databasevars_test:\"I am vars\"然後再修改前面所用的 task/main.yml ---- name:Echo some message.debug:msg:\u003e-test: {{ default_test }} {{ vars_test }}接著執行 playbook，你應該可以看到 default 跟 vars 中的變數內容 (連在一起了啦)： $ ansible-playbook -C roles.yml PLAY [vagrant1] **************************************************************** TASK [Gathering Facts] ********************************************************* ok: [vagrant1] TASK [database : Echo some message.] ******************************************* ok: [vagrant1] =\u003e {} MSG: test: I am default I am vars PLAY RECAP ********************************************************************* vagrant1 : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 Info 通常我們改變數只會改 default 中的變數，vars 比較不會去動它。 另外在優先權的部分，default 是最小的，所以 vars 或是其他檔案中有相同名稱的變數，則會覆蓋掉 default 中的變數。 由於 vars 的優先權極高，建議是在 task 執行時進行傳遞或是覆蓋。 ","date":"2023-07-07","objectID":"/posts/ansible/08_roles/:1:4","tags":["Ansible","Infra","roles","ansible-galaxy"],"title":"Ansible - Roles","uri":"/posts/ansible/08_roles/"},{"categories":["Infra"],"content":"Ansible-galaxy ansible-galaxy 主要的目的是使用社群上大家所分享的 role。 另外也可以初始化 roles，提供一個簡單的目錄給我們開發，就像前面使用的功能。 ansible-galaxy的指令有搜尋、安裝與移除等： $ ansible-galaxy search database Found 1997 roles matching your search. Showing first 1000. Name Description ---- ----------- 0x0i.grafana Grafana - an analytics and monitoring observability platform 0x0i.prometheus Prometheus - a multi-dimensional time-series data monitoring and alerting toolkit 0x5a17ed.ansible_role_netbox Installs and configures NetBox, a DCIM suite, in a production setting. 0x_peace.mariadb Mariadb role 123mwanjemike.ansible_mongodb Configure the components of a MongoDB Cluster 1it.riak Installs and configures Riak KV and TS, a distributed, highly available NoSQL and TimeSeries database. 1mr.timezone change timezone ... 如果有找到喜歡的，我們可以用 install 進行安裝，這邊我就以安裝 0x_peace.mariadb 為例子： $ ansible-galaxy install 0x_peace.mariadb Starting galaxy role install process - downloading role 'mariadb', owned by 0x_peace - downloading role from https://github.com/0x-peace/mariadb/archive/master.tar.gz - extracting 0x_peace.mariadb to /Users/user/.ansible/roles/0x_peace.mariadb - 0x_peace.mariadb (master) was installed successfully # 我想要換路徑啦！那就用下面這個！ $ ansible-galaxy install -f -p [path] 0x_peace.mariadb ","date":"2023-07-07","objectID":"/posts/ansible/08_roles/:2:0","tags":["Ansible","Infra","roles","ansible-galaxy"],"title":"Ansible - Roles","uri":"/posts/ansible/08_roles/"},{"categories":["Infra"],"content":"List list 可以讓我們知道已經安裝了哪一些 roles，在我的環境中，他會去抓一些預設的路徑。 $ ansible-galaxy list # /Users/user/.ansible/roles - 0x_peace.mariadb, master [WARNING]: - the configured path /usr/share/ansible/roles does not exist. [WARNING]: - the configured path /etc/ansible/roles does not exist. # 一樣也可以指定路徑。 $ ansible-galaxy list -p [path] # /Users/user/Desktop/playbooks/roles - 0x_peace.mariadb, master # /Users/user/.ansible/roles - 0x_peace.mariadb, master [WARNING]: - the configured path /usr/share/ansible/roles does not exist. [WARNING]: - the configured path /etc/ansible/roles does not exist. ","date":"2023-07-07","objectID":"/posts/ansible/08_roles/:2:1","tags":["Ansible","Infra","roles","ansible-galaxy"],"title":"Ansible - Roles","uri":"/posts/ansible/08_roles/"},{"categories":["Infra"],"content":"Remove 知道了我們有裝哪些 roles 後可以幹嘛呢？沒錯就是要來把它刪掉 Remove 就如同字面上，用來把想刪的 roles 刪除！ $ ansible-galaxy remove 0x_peace.mariadb - successfully removed 0x_peace.mariadb # 一樣可以用 -p 來指定路徑 $ ansible-galaxy remove -p [path ]0x_peace.mariadb - successfully removed 0x_peace.mariadb ","date":"2023-07-07","objectID":"/posts/ansible/08_roles/:2:2","tags":["Ansible","Infra","roles","ansible-galaxy"],"title":"Ansible - Roles","uri":"/posts/ansible/08_roles/"},{"categories":["Infra"],"content":"上傳 roles 我寫好了，我想上傳跟大家分享！ 上傳 roles 的話，首先要有一個 github 帳號，然後把你的 roles push 到 github 上。 接著登入到 Galaxy Ansible，網站會幫你同步你的 repository，你只要把你存放 roles 的 repository 權限打開即可。 因為網站經常改版，雖然步驟都是一樣但功能的相對位置會改變，這邊就不附上圖片說明。 ","date":"2023-07-07","objectID":"/posts/ansible/08_roles/:2:3","tags":["Ansible","Infra","roles","ansible-galaxy"],"title":"Ansible - Roles","uri":"/posts/ansible/08_roles/"},{"categories":["Infra"],"content":"Requirements 有時候你會發現 role 內有一個 requirements.yml，這個是用來列出這個 role 的依賴項，通常會在 roles 內，如果是使用 AWX 或是 Ansible Tower 時會自動安裝列出的依賴項。 這邊可以使用 galaxy 中的 role 或是其他 repository 中的 role。 不同的來源在 requirements 中用法也不同，這邊可以參考官方的說明文件，我在這也附上相關用法。 # from galaxy- name:yatesr.timezone# from locally cloned git repository (git+file:// requires full paths)- src:git+file:///home/bennojoy/nginx# from GitHub- src:https://github.com/bennojoy/nginx# from GitHub, overriding the name and specifying a specific tag- name:nginx_rolesrc:https://github.com/bennojoy/nginxversion:main# from GitHub, specifying a specific commit hash- src:https://github.com/bennojoy/nginxversion:\"ee8aa41\"# from a webserver, where the role is packaged in a tar.gz- name:http-role-gzsrc:https://some.webserver.example.com/files/main.tar.gz# from a webserver, where the role is packaged in a tar.bz2- name:http-role-bz2src:https://some.webserver.example.com/files/main.tar.bz2# from a webserver, where the role is packaged in a tar.xz (Python 3.x only)- name:http-role-xzsrc:https://some.webserver.example.com/files/main.tar.xz# from Bitbucket- src:git+https://bitbucket.org/willthames/git-ansible-galaxyversion:v1.4# from Bitbucket, alternative syntax and caveats- src:https://bitbucket.org/willthames/hg-ansible-galaxyscm:hg# from GitLab or other git-based scm, using git+ssh- src:git@gitlab.company.com:mygroup/ansible-core.gitscm:gitversion:\"0.1\"# quoted, so YAML doesn't parse this as a floating-point value","date":"2023-07-07","objectID":"/posts/ansible/08_roles/:3:0","tags":["Ansible","Infra","roles","ansible-galaxy"],"title":"Ansible - Roles","uri":"/posts/ansible/08_roles/"},{"categories":["Infra"],"content":"結論 role 是組織 playbook 的好方法，這篇文章介紹了如何使用 role，如何設計自己的 role 跟使用別人所設計的 role。 這篇筆記是自己受傷後所寫的第一篇，希望自己能趕快恢復狀況，維持持續學習的習慣。 ","date":"2023-07-07","objectID":"/posts/ansible/08_roles/:4:0","tags":["Ansible","Infra","roles","ansible-galaxy"],"title":"Ansible - Roles","uri":"/posts/ansible/08_roles/"},{"categories":["Infra"],"content":"參考資料 Ansible: Up and Running: Automating Configuration Management and Deployment the Easy Way (3rd edition) Galaxy User Guide ","date":"2023-07-07","objectID":"/posts/ansible/08_roles/:5:0","tags":["Ansible","Infra","roles","ansible-galaxy"],"title":"Ansible - Roles","uri":"/posts/ansible/08_roles/"},{"categories":["TroubleShooting"],"content":"關於遇到 Squid 因為 UTF8-BOM 而導致 Invalid Response 的問題。 ","date":"2023-06-01","objectID":"/posts/troubleshooting/squid_utf8bom/:0:0","tags":["Infra","squid","encoding","UTF-8","UTF-8 with BOM","UTF8BOM"],"title":"【TroubleShooting】Invalid Response on Squid(Duo to BOM)","uri":"/posts/troubleshooting/squid_utf8bom/"},{"categories":["TroubleShooting"],"content":"問題 客戶端使用 Squid 作為 proxy server 並連線到一台帶有網頁管理介面的 Layer3 Switch，發生了錯誤導致網頁無法瀏覽。 但是，不透過 Squid，直接連線到設備時，網頁又正常運作。 Squid 給我的錯誤訊息，真不想看到這個。(已刪除敏感訊息)\" Squid 給我的錯誤訊息，真不想看到這個。(已刪除敏感訊息) 此時要先釐清問題點是在設備上，還是 Squid 上。如果是 Squid 就不甘我的事了！！ ","date":"2023-06-01","objectID":"/posts/troubleshooting/squid_utf8bom/:1:0","tags":["Infra","squid","encoding","UTF-8","UTF-8 with BOM","UTF8BOM"],"title":"【TroubleShooting】Invalid Response on Squid(Duo to BOM)","uri":"/posts/troubleshooting/squid_utf8bom/"},{"categories":["TroubleShooting"],"content":"過程 ","date":"2023-06-01","objectID":"/posts/troubleshooting/squid_utf8bom/:2:0","tags":["Infra","squid","encoding","UTF-8","UTF-8 with BOM","UTF8BOM"],"title":"【TroubleShooting】Invalid Response on Squid(Duo to BOM)","uri":"/posts/troubleshooting/squid_utf8bom/"},{"categories":["TroubleShooting"],"content":"拓墣 拓墣是 Squid 跟 Switch 之間直接連線。客戶端再與 Squid 直接連線。 Switch 192.168.0.1 \u003c—\u003e Squid 192.168.0.111 \u003c—\u003e Client 192.168.0.10 ","date":"2023-06-01","objectID":"/posts/troubleshooting/squid_utf8bom/:2:1","tags":["Infra","squid","encoding","UTF-8","UTF-8 with BOM","UTF8BOM"],"title":"【TroubleShooting】Invalid Response on Squid(Duo to BOM)","uri":"/posts/troubleshooting/squid_utf8bom/"},{"categories":["TroubleShooting"],"content":"Log 因為看到錯誤訊息是 Invalid Response，在想應該是 Squid 跟 設備之間有傳輸問題，先看了一下 /var/log/squid/access.log 跟 var/log/squid/cache.log (這邊我會調整一下資訊，會與我真實遇到的情況不同，但我盡可能保留原本的樣子。) $ sudo tail -f /var/log/squid/access.log 1685583425.309 89 192.168.0.10 TCP_REFRESH_IGNORED/200 10211 GET http://192.168.0.1/login.lsp - HIER_DIRECT/192.168.0.1 text/html 1685583433.755 97 192.168.0.10 TCP_MISS/200 563 POST http://192.168.0.1/login.lua - HIER_DIRECT/192.168.0.1 application/json 1685583433.871 103 192.168.0.10 TCP_REFRESH_FAIL_ERR/502 5077 GET http://192.168.0.1/main.lsp - HIER_DIRECT/192.168.0.1 text/html $ sudo tail -f /var/log/squid/cache.log 2023/05/31 09:38:12 kid1| WARNING: HTTP: Invalid Response: Bad header encountered from http://192.168.0.1/main.lsp AKA http://192.168.0.1/main.lsp 在觀察到 access.log 產生 502 錯誤時， cache.log 也紀錄了一筆警告資訊，遇到錯誤的 header。 … Bad header encountered … 好的，看起來是 header 有問題，這邊可以用 curl 去觀察 header，也可以在 squid.conf 中加入 log_mime_hdrs on 這個參數，這樣會紀錄傳輸時的 header。 1685499970.322 95 192.168.0.10 TCP_MISS/200 588 POST http://192.168.0.1/login.lua - HIER_DIRECT/192.168.0.1 application/json [User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/113.0\\r\\nAccept: application/json, text/javascript, */*; q=0.01\\r\\nAccept-Language: zh-TW,zh;q=0.8,en-US;q=0.5,en;q=0.3\\r\\nAccept-Encoding: gzip, deflate\\r\\nContent-Type: application/x-www-form-urlencoded; charset=UTF-8\\r\\nX-Requested-With: XMLHttpRequest\\r\\nContent-Length: 119\\r\\nOrigin: http://192.168.0.1\\r\\nConnection: keep-alive\\r\\nReferer: http://192.168.0.1/login.lsp\\r\\nCookie:\\r\\nHost: 192.168.0.1\\r\\n] [HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\nX-Frame-Options: SAMEORIGIN\\r\\nDate: Wed, 02 Jan 2019 19:36:58 GMT\\r\\nServer: lighttpd\\r\\nContent-Type: application/json\\r\\nExpires: Wed, 02 Jan 2019 19:36:58 GMT\\r\\nLast-Modified: Wed, 02 Jan 2019 19:36:58 GMT\\r\\nCache-Control: no-cache\\r\\nSet-Cookie:\\r\\n\\r] 1685599970.433 84 192.168.0.10 TCP_MISS/502 5078 GET http://192.168.0.1/main.lsp - HIER_DIRECT/192.168.0.1 text/html [User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/113.0\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\\r\\nAccept-Language: zh-TW,zh;q=0.8,en-US;q=0.5,en;q=0.3\\r\\nAccept-Encoding: gzip, deflate\\r\\nConnection: keep-alive\\r\\nReferer: http://192.168.0.1/login.lsp\\r\\nCookie: \\r\\nUpgrade-Insecure-Requests: 1\\r\\nHost: 192.168.0.1\\r\\n] [HTTP/1.1 502 Bad Gateway\\r\\nServer: squid/4.13\\r\\nMime-Version: 1.0\\r\\nDate: Wed, 31 May 2023 02:26:10 GMT\\r\\nContent-Type: text/html;charset=utf-8\\r\\nContent-Length: 4710\\r\\nX-Squid-Error: ERR_INVALID_RESP 0\\r\\nVary: Accept-Language\\r\\nContent-Language: zh-tw\\r\\n\\r] Header 看起來沒有問題呀！！！ 但是他就是寫 Header 有錯啊！！！ 這時我做了兩件事情： 問我的大神朋友。 通靈！土法煉鋼！wireshark 用起來。 最後都指出了一樣的事情。UTF-8 with BOM(Byte Order Mark)。 ","date":"2023-06-01","objectID":"/posts/troubleshooting/squid_utf8bom/:2:2","tags":["Infra","squid","encoding","UTF-8","UTF-8 with BOM","UTF8BOM"],"title":"【TroubleShooting】Invalid Response on Squid(Duo to BOM)","uri":"/posts/troubleshooting/squid_utf8bom/"},{"categories":["TroubleShooting"],"content":"轉折點 觀察了 Squid 回傳 200 跟跟 Squid 回傳 502 前，Switch 的傳輸內容，發現在 Header 的部分多了 ef bb bf。 這三個 Byte 扔到 Google 發現是 BOM(Byte Order Mark)，是關於編碼的 Mark。 但我在 curl 跟 access.log 都沒看到，隱隱約約覺得是這個 BOM 而導致 header 有問題。 正常結果。\" 正常結果。 有 BOM 的結果。\" 有 BOM 的結果。 同時我的大神朋友也回傳給我了他的分析結果。 大神的 wireshark 會給 Expert info，不愧是大神！！！ Illegal Characters.\" Illegal Characters. 到這邊就確定是 BOM 在搞事，影響了 header，重新編碼有問題的網頁後，這個問題就解決了。 Code review 時還花了一堆時間解釋…\" Code review 時還花了一堆時間解釋… 雖然還有個問題，是要找出哪些網頁也是用這個編碼方式儲存，但這個屬於小問題好解決啦～ $ find . -type f -name \"*.html\" | xargs file | grep \"UTF-8 Unicode (with BOM)\" ./path/to/file/index.html: HTML document, UTF-8 Unicode(with BOM) text, with CRLF line termintors # 建議先用自己環境的 find 跟 file，可能需要依據結果做調整這段 script。 # html 可以依據自己需求更改檔案類型或名稱，反正根據需求使用 regex 即可。 我要來問大神為什麼他的 wireshark 像個 expert 而我的不像了。 ","date":"2023-06-01","objectID":"/posts/troubleshooting/squid_utf8bom/:3:0","tags":["Infra","squid","encoding","UTF-8","UTF-8 with BOM","UTF8BOM"],"title":"【TroubleShooting】Invalid Response on Squid(Duo to BOM)","uri":"/posts/troubleshooting/squid_utf8bom/"},{"categories":["TroubleShooting"],"content":"Byte Order Mark (BOM) ","date":"2023-06-01","objectID":"/posts/troubleshooting/squid_utf8bom/:4:0","tags":["Infra","squid","encoding","UTF-8","UTF-8 with BOM","UTF8BOM"],"title":"【TroubleShooting】Invalid Response on Squid(Duo to BOM)","uri":"/posts/troubleshooting/squid_utf8bom/"},{"categories":["TroubleShooting"],"content":"簡介 網路上其實很多資源說的蠻清楚的，我這邊就簡單說明一下。 Byte Order Mark 常被用來當做標示檔案是以 UTF-8、UTF-16或 UTF-32 編碼的記號。 他會在檔案開始處使用特定字元來標記，一般常用的編輯器是看不到這些特定字元，通常要使用 binary 或是 hex 的方式來打開，像是用 hexdump 或是 vim 搭配 xxd。 要不要使用看個人的設計與需求，但經常會干擾應用程式的運作，而導致檔案出現空白或是亂碼的情形。 ","date":"2023-06-01","objectID":"/posts/troubleshooting/squid_utf8bom/:4:1","tags":["Infra","squid","encoding","UTF-8","UTF-8 with BOM","UTF8BOM"],"title":"【TroubleShooting】Invalid Response on Squid(Duo to BOM)","uri":"/posts/troubleshooting/squid_utf8bom/"},{"categories":["TroubleShooting"],"content":"建議 檔案中有架構可以明確給出編碼的，盡量不要使用 UTF-8 with BOM 做編碼；但如果是不會明確給出編碼的，你要怎麼確保別人開啟時會用 UTF-8？說不定他用別的編碼方式呀，此時用 UTF-8 with BOM 是沒問題的。 下面舉了兩個例子：html, xml html \u003chead\u003e \u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"\u003e \u003c/head\u003e xml \u003c?xml version = \"1.0\" encoding = \"UTF-8\" standalone = \"no\" ?\u003e 注意編輯器的編碼方式，據說 notepad 常常使用 UTF-8 with BOM。 如果有發現使用錯誤的編碼方式，可以透過編輯器用別的編碼方式再儲存一次，但要記得編碼後作驗證，避免有其他問題發生。 ","date":"2023-06-01","objectID":"/posts/troubleshooting/squid_utf8bom/:4:2","tags":["Infra","squid","encoding","UTF-8","UTF-8 with BOM","UTF8BOM"],"title":"【TroubleShooting】Invalid Response on Squid(Duo to BOM)","uri":"/posts/troubleshooting/squid_utf8bom/"},{"categories":["TroubleShooting"],"content":"Wireshark 因應這次的問題，請教了朋友，朋友也給了一些建議，故紀錄： ","date":"2023-06-01","objectID":"/posts/troubleshooting/squid_utf8bom/:5:0","tags":["Infra","squid","encoding","UTF-8","UTF-8 with BOM","UTF8BOM"],"title":"【TroubleShooting】Invalid Response on Squid(Duo to BOM)","uri":"/posts/troubleshooting/squid_utf8bom/"},{"categories":["TroubleShooting"],"content":"Allow subdissector to reassemble tcp streams 這個預設是開啟的。\" 這個預設是開啟的。 在傳輸時，往往會因為資料大於 MTU、MSS 的關係而分段傳輸。 Wireshark 會將屬於同一個 PDU 的封包集合起來，關閉這個功能可以呈現較真實的傳輸情形。 ","date":"2023-06-01","objectID":"/posts/troubleshooting/squid_utf8bom/:5:1","tags":["Infra","squid","encoding","UTF-8","UTF-8 with BOM","UTF8BOM"],"title":"【TroubleShooting】Invalid Response on Squid(Duo to BOM)","uri":"/posts/troubleshooting/squid_utf8bom/"},{"categories":["TroubleShooting"],"content":"Follow 追蹤。\" 追蹤。 透過這個功能，可以較容易觀察該 stream 收發了什麼資料。 ","date":"2023-06-01","objectID":"/posts/troubleshooting/squid_utf8bom/:5:2","tags":["Infra","squid","encoding","UTF-8","UTF-8 with BOM","UTF8BOM"],"title":"【TroubleShooting】Invalid Response on Squid(Duo to BOM)","uri":"/posts/troubleshooting/squid_utf8bom/"},{"categories":["TroubleShooting"],"content":"參考資料 我的神朋友 Oscar. What’s the difference between UTF-8 and UTF-8 with BOM? wikipedia-位元組順序記號 「带 BOM 的 UTF-8」和「无 BOM 的 UTF-8」有什么区别？网页代码一般使用哪个？ ","date":"2023-06-01","objectID":"/posts/troubleshooting/squid_utf8bom/:6:0","tags":["Infra","squid","encoding","UTF-8","UTF-8 with BOM","UTF8BOM"],"title":"【TroubleShooting】Invalid Response on Squid(Duo to BOM)","uri":"/posts/troubleshooting/squid_utf8bom/"},{"categories":["Infra"],"content":"錯誤經常發生，不論是在 playbook 或是 configuration 上，出錯是正常的，我們要知道的是問題點在哪，並找出方法解決問題。本篇文章將介紹一些在 Ansible 上的故障排除方法與工具。 ","date":"2023-03-04","objectID":"/posts/ansible/07_debug/:0:0","tags":["Ansible","Infra","debug"],"title":"Ansible - Debug","uri":"/posts/ansible/07_debug/"},{"categories":["Infra"],"content":"Error Message 舉例來說，我使用上次 show.yml 那個為範例，我將相關的設備關機後並執行： $ ansible-playbook show.yml PLAY [Do something to host] ************************************************************* TASK [Gathering Facts] ****************************************************************** fatal: [vagrant1]: UNREACHABLE! =\u003e {\"changed\": false, \"msg\": \"Failed to connect to the host via ssh: \", \"unreachable\": true} fatal: [vagrant3]: UNREACHABLE! =\u003e {\"changed\": false, \"msg\": \"Failed to connect to the host via ssh: \", \"unreachable\": true} PLAY RECAP ****************************************************************************** vagrant1 : ok=0 changed=0 unreachable=1 failed=0 skipped=0 rescued=0 ignored=0 vagrant3 : ok=0 changed=0 unreachable=1 failed=0 skipped=0 rescued=0 ignored=0 你可以發現到 ansible 回報了錯誤，並提供一些相關資訊，在最下方也有相關的紀錄。（unreachable） 我們可以透過修改 ansible.cfg 中的 [default]，加入stdout_callback = debug 讓訊息更容易閱讀： [defaults]inventory = inventorystdout_callback = debug$ ansible-playbook show.yml PLAY [Do something to host] ************************************************************* TASK [Gathering Facts] ****************************************************************** fatal: [vagrant1]: UNREACHABLE! =\u003e { \"changed\": false, \"unreachable\": true } MSG: Failed to connect to the host via ssh: fatal: [vagrant3]: UNREACHABLE! =\u003e { \"changed\": false, \"unreachable\": true } MSG: Failed to connect to the host via ssh: PLAY RECAP ****************************************************************************** vagrant1 : ok=0 changed=0 unreachable=1 failed=0 skipped=0 rescued=0 ignored=0 vagrant3 : ok=0 changed=0 unreachable=1 failed=0 skipped=0 rescued=0 ignored=0 ","date":"2023-03-04","objectID":"/posts/ansible/07_debug/:1:0","tags":["Ansible","Infra","debug"],"title":"Ansible - Debug","uri":"/posts/ansible/07_debug/"},{"categories":["Infra"],"content":"Troubleshooting ","date":"2023-03-04","objectID":"/posts/ansible/07_debug/:2:0","tags":["Ansible","Infra","debug"],"title":"Ansible - Debug","uri":"/posts/ansible/07_debug/"},{"categories":["Infra"],"content":"module 我們可以透過 -m 這個參數，來使用 module 中的一些指令進行 Troubleshooting : $ ansible vagrant1 -m ping vagrant1 | UNREACHABLE! =\u003e { \"changed\": false, \"msg\": \"Failed to connect to the host via ssh: \", \"unreachable\": true } Question 那這樣跟我直接用 $ ping vagrant1 有什麼不一樣？我還要打更多的字耶！ 的確是沒有什麼不一樣，但如果你有上百台機器要處理呢？還記得我們前面提到的 Group 嗎？你甚至可以使用 all 來協助你同時處理更多機器！ $ ansible all -m ping vagrant1 | UNREACHABLE! =\u003e { \"changed\": false, \"msg\": \"Failed to connect to the host via ssh: \", \"unreachable\": true } vagrant2 | UNREACHABLE! =\u003e { \"changed\": false, \"msg\": \"Failed to connect to the host via ssh: \", \"unreachable\": true } vagrant3 | UNREACHABLE! =\u003e { \"changed\": false, \"msg\": \"Failed to connect to the host via ssh: \", \"unreachable\": true } 當然還有許多好用的 module，像是 command, file, stat, service 等等。 官方文件有提供所有的內建 module，有空可以參考（因為真的太多啦！） All modules ","date":"2023-03-04","objectID":"/posts/ansible/07_debug/:2:1","tags":["Ansible","Infra","debug"],"title":"Ansible - Debug","uri":"/posts/ansible/07_debug/"},{"categories":["Infra"],"content":"-v 這個參數可以提供給我們更多的資訊來進行 troubleshooting： $ ansible all -v -m ping Question 你可以試試看 -v, -vv, -vvv, -vvvv 有什麼不同？ 知道相關資訊之後，可以開始推測原因，也許是我們根本沒辦法到目的機器，也許是機器上的 port 被關了，也許只是網路一時抽筋等等，後續的 troubleshooting 又是另一個世界了。 一些 troubleshooting 的方式與工具可以參考我的文章。 網路中斷 服務中斷 Slowly ","date":"2023-03-04","objectID":"/posts/ansible/07_debug/:2:2","tags":["Ansible","Infra","debug"],"title":"Ansible - Debug","uri":"/posts/ansible/07_debug/"},{"categories":["Infra"],"content":"debugger 在 ansible 2.5 以後的版本中，加入的 debugger 這個功能，讓我們可以逐步執行 playbook。 name:Do something to hosthosts:- vagrant1- vagrant3debugger:always你可以輸入 c 讓他進行下一步。 $ ansible-playbook show.yml PLAY [Do something to host] ************************************************************* TASK [Gathering Facts] ****************************************************************** ok: [vagrant3] [vagrant3] TASK: Gathering Facts (debug)\u003e 這邊提供一些 debugger 支援的指令： Command key Action print p 印出 task 的相關資訊 update-task u 使用新的 vars 來重新建立 task redo r 重新執行 task continue c 繼續執行下個 task quit q 離開 debugger 其中 p 後面還可以加上變數來印出所需的訊息。 Variable Description p task 失敗的 task 名稱 p task.args Modules 的參數 p result 失敗的 task 返回的結果 p vars 所有的 vars p vars[key] 特定 variable 的值 ","date":"2023-03-04","objectID":"/posts/ansible/07_debug/:3:0","tags":["Ansible","Infra","debug"],"title":"Ansible - Debug","uri":"/posts/ansible/07_debug/"},{"categories":["Infra"],"content":"assert assert 通常是用來做檢查的工具，如果 assert 不滿足指定條件，那就會發生錯誤並終止。 task:- assert:that:- 1\u003e 2因為這個條件不成立，所以會發生錯誤： TASK [assert] *************************************************************************** fatal: [vagrant1]: FAILED! =\u003e { \"assertion\": \"1 \u003e 2\", \"changed\": false, \"evaluated_to\": false } 我們可以用這個方式，來檢查一些 vars 或是 result 是否為我們所想要的數值。 這邊以 stat 來舉例，把這些 code 放到上次用到的 show.yml 後面並做測試。 ---- name:Do something to hosthosts:- vagrant1- vagrant3gather_facts:truetasks:- name:Print system detailsdebug:msg:\u003e-os_family: {{ ansible_facts.os_family }}, distro: {{ ansible_facts.distribution }} {{ ansible_facts.distribution_version }}, kernel: {{ ansible_facts.kernel }}- name:Print ip address by hostvardebug:var=hostvars[inventory_hostname]['ansible_default_ipv4']- stat:path:/boot/grubregister:p- assert:that:- p.stat.exists and p.stat.isdir...測試結果：原來Ubuntu 跟 CentOS 的 grub 不一樣呀 TASK [assert] *************************************************************************** ok: [vagrant1] =\u003e { \"changed\": false } MSG: All assertions passed fatal: [vagrant3]: FAILED! =\u003e { \"assertion\": \"p.stat.exists and p.stat.isdir\", \"changed\": false, \"evaluated_to\": false } MSG: Assertion failed 這邊我們看到了 MSG，感覺就是可以修改 MSG 嘛！ 我們可以透過 fail_msg 跟 success_msg 來顯示對應的訊息。 - assert:that:- p.stat.exists and p.stat.isdirfail_msg:\"It's failed.\"success_msg:\"It's fine.\"","date":"2023-03-04","objectID":"/posts/ansible/07_debug/:4:0","tags":["Ansible","Infra","debug"],"title":"Ansible - Debug","uri":"/posts/ansible/07_debug/"},{"categories":["Infra"],"content":"Check playbook 在用 playbook 之前呢，我們可以先做一些檢查。 ","date":"2023-03-04","objectID":"/posts/ansible/07_debug/:5:0","tags":["Ansible","Infra","debug"],"title":"Ansible - Debug","uri":"/posts/ansible/07_debug/"},{"categories":["Infra"],"content":"語法檢查（–syntax-check） 可以使用 --syntax-check 來檢查語法是否有效： $ ansible-playbook --syntax-check show.yml ","date":"2023-03-04","objectID":"/posts/ansible/07_debug/:5:1","tags":["Ansible","Infra","debug"],"title":"Ansible - Debug","uri":"/posts/ansible/07_debug/"},{"categories":["Infra"],"content":"列出主機（–list-hosts） 透過 --list-hosts 可以列出這個 playbook 會用到的 host： $ ansible-playbook --list-hosts show.yml 那如果我是用 Dynamic 的呢？？ 那就也把他加進來一起檢查囉！你可以在我們在介紹 inventory 時所用的環境做測試。 $ ansible-playbook --list-hosts -i [script] [your.yml] ","date":"2023-03-04","objectID":"/posts/ansible/07_debug/:5:2","tags":["Ansible","Infra","debug"],"title":"Ansible - Debug","uri":"/posts/ansible/07_debug/"},{"categories":["Infra"],"content":"列出任務（–list-tasks） 透過 --list-tasks 可以列出 task : $ ansible-playbook --list-tasks show.yml ","date":"2023-03-04","objectID":"/posts/ansible/07_debug/:5:3","tags":["Ansible","Infra","debug"],"title":"Ansible - Debug","uri":"/posts/ansible/07_debug/"},{"categories":["Infra"],"content":"Diff 如果你的 playbook 會在 host 上做修改，你可以使用 diff 來觀察修改的情況，他會以 lineinfile 的方式呈現。 $ ansible-playbook -D --check playbook.yml ","date":"2023-03-04","objectID":"/posts/ansible/07_debug/:5:4","tags":["Ansible","Infra","debug"],"title":"Ansible - Debug","uri":"/posts/ansible/07_debug/"},{"categories":["Infra"],"content":"結論 這次簡單介紹了一些 troubleshooting 的方式，還有在運行 playbook 前可以做哪一些檢查。 因為 troubleshooting 的方式又是另一個世界，不同的問題需要用不同的方式來找出問題點，並進行近一步的排除，很難針對所有情況來做介紹。 先前有介紹一些工具可以協助 troubleshooting，如果有空可以去參考一下。 在 playbook 部分有說明的 assert ，可以幫助我們在開發時檢查 vars 跟 result，另外也可以在運行前透過一些方式來檢查 playbook，畢竟建立 connection 也是需要時間。 最後希望大家可以不常常做故障排除。傷心傷身 ","date":"2023-03-04","objectID":"/posts/ansible/07_debug/:6:0","tags":["Ansible","Infra","debug"],"title":"Ansible - Debug","uri":"/posts/ansible/07_debug/"},{"categories":["Infra"],"content":"參考資料 Ansible: Up and Running: Automating Configuration Management and Deployment the Easy Way (3rd edition) ansible.builtin.assert module – Asserts given expressions are true All modules ","date":"2023-03-04","objectID":"/posts/ansible/07_debug/:7:0","tags":["Ansible","Infra","debug"],"title":"Ansible - Debug","uri":"/posts/ansible/07_debug/"},{"categories":["Infra"],"content":"本篇文章將介紹在 Ansible 中的 Variables 跟 facts，並簡單介紹一下 Magic Variable。 ","date":"2023-02-20","objectID":"/posts/ansible/06_variables/:0:0","tags":["Ansible","Infra","Magic Variables"],"title":"Ansible - Variables","uri":"/posts/ansible/06_variables/"},{"categories":["Infra"],"content":"定義 在其他程式語言中也是有變數，而 Ansible 中也有，變數可以讓我們更靈活的使用。 基本上最簡單的方法就是宣告一個變數名稱，跟你想賦予該變數的數值： vars:tls_dir:/etc/nginx/ssl/key_file:nginx.keycert_file:nginx.crtconf_file:/etc/nginx/sites-available/defaultserver_name:localhost以上面這個例子來說明： tls_dir : 就是我們宣告的變數名稱。 /etc/nginx/ssl/ : 我們要賦予該變數的數值。 我們也可以另外將變數放到一個或是多個檔案中， var:- nginx.ymlnginx.yml tls_dir:/etc/nginx/ssl/key_file:nginx.keycert_file:nginx.crtconf_file:/etc/nginx/sites-available/defaultserver_name:localhost這種方式可以讓我們分離一些較敏感的資訊，像是 key, token 之類的。 這些敏感資訊就可以另外存放在一個檔案，透過 gitignore 或是其他類似工具，依據自己的需求做使用，使這些敏感資訊不被記錄。 Question 那我們把變數都放在同一個檔案，有沒有較好管理的方法？ 其實 Ansible 允許我們定義 groups 或是 hosts 關聯的變數，這些變數需要在特定的目錄下操作，分別為 group_vars 跟 host_vars，根據這些名稱，應該就能知道哪個目錄是跟 groups 搭配，哪個是跟 hosts 搭配了吧？ ","date":"2023-02-20","objectID":"/posts/ansible/06_variables/:1:0","tags":["Ansible","Infra","Magic Variables"],"title":"Ansible - Variables","uri":"/posts/ansible/06_variables/"},{"categories":["Infra"],"content":"debug, register and stat ","date":"2023-02-20","objectID":"/posts/ansible/06_variables/:2:0","tags":["Ansible","Infra","Magic Variables"],"title":"Ansible - Variables","uri":"/posts/ansible/06_variables/"},{"categories":["Infra"],"content":"debug 那要如何查看變數實際是什麼數值呢？我們需要使用 debug 這個指令： - debug:var=myVarName如果需要加上一些訊息，那就要用兩個大括弧包起來： 這讓我想到用 hugo 開發的回憶… - debug:\"【Info】 debug : {{ myVarname }}\"","date":"2023-02-20","objectID":"/posts/ansible/06_variables/:2:1","tags":["Ansible","Infra","Magic Variables"],"title":"Ansible - Variables","uri":"/posts/ansible/06_variables/"},{"categories":["Infra"],"content":"register 另外，我們會經常將 task 的結果，用來設置一個變數的數值，這個時候我們就可以使用 register 建立一個變數，並將 task 的結果設為該變數的數值。 我們在上一章 Dynamic Inventory 其實就有使用到了，那這邊再提供一個新的 playbook 做使用好了，環境可以保留之前的就好。這邊我把它命名為 show.yml。 下面的例子中你可以看到他是以 JSON 格式回傳結果的。 ---- name:Do something to hosthosts:vagrant1become:truetasks:- name:Show idcommand:id -unregister:login- name:print stdoutdebug:msg:\"login info : {{ login.stdout }}\"$ ansible-playbook show.yml TASK [Show id] ************************************************************************** changed: [vagrant1] TASK [print stdout] ********************************************************************* ok: [vagrant1] =\u003e { \"msg\": \"login info : root\" } PLAY RECAP ****************************************************************************** vagrant1 : ok=3 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 在 task 失敗時，debug 跟 ignore_errors 也是很常用的工具。 (名稱那麼明顯…) 例如在 task 失敗時， ansible 就會因為 task 失敗而停止。 透過 ignore_errors 可以忽略這個錯誤，再透過 debug 將結果顯示出來，以利後續的故障排除，而又不會因為這個錯誤影響到後面的 tasks。 ---- name:Do something to hosthosts:vagrant1become:truetasks:# 這個 task 會有問題，因為沒有 ifconfig 這個 command 做使用。可以自己改 ignore_errors 的數值來觀察結果。- name:Show ipcommand:ifconfigregister:infoignore_errors:true- name:print stdoutdebug:msg:\"login info : {{ info.stdout }}\"- name:Show idcommand:id -unregister:login- name:print stdoutdebug:msg:\"login info : {{ login.stdout }}\"","date":"2023-02-20","objectID":"/posts/ansible/06_variables/:2:2","tags":["Ansible","Infra","Magic Variables"],"title":"Ansible - Variables","uri":"/posts/ansible/06_variables/"},{"categories":["Infra"],"content":"stat 在 debug 時，我們也可以透過 stat 來取得檔案的資訊做進一步的分析。 ansible 仍會以 JSON 格式回傳該檔案的資訊。 ---- name:Do something to hosthosts:vagrant1become:truetasks:- name:Get statstat:path:/etc/passwdregister:file- name:print statdebug:msg:\"file info : {{ file.stat }}\"## Output TASK [Get stat] ************************************************************************* ok: [vagrant1] TASK [print stat] *********************************************************************** ok: [vagrant1] =\u003e { \"msg\": \"file info : {'exists': True, 'path': '/etc/passwd', 'mode': '0644', 'isdir': False, 'ischr': False, 'isblk': False, 'isreg': True, 'isfifo': False, 'islnk': False, 'issock': False, 'uid': 0, 'gid': 0, 'size': 1808, 'inode': 71460, 'dev': 2049, 'nlink': 1, 'atime': 1676858098.308, 'mtime': 1670307804.2306128, 'ctime': 1670307804.2306128, 'wusr': True, 'rusr': True, 'xusr': False, 'wgrp': False, 'rgrp': True, 'xgrp': False, 'woth': False, 'roth': True, 'xoth': False, 'isuid': False, 'isgid': False, 'blocks': 8, 'block_size': 4096, 'device_type': 0, 'readable': True, 'writeable': True, 'executable': False, 'pw_name': 'root', 'gr_name': 'root', 'checksum': '80b9dbad5183c2671c8a9639086593820c7988f0', 'mimetype': 'text/plain', 'charset': 'us-ascii', 'version': '2549813272', 'attributes': ['extents'], 'attr_flags': 'e'}\" } 以這個例子來說，我們可以透過 key 更進一步的存取。 例如這個結果中的 mode: 0644，你可以透過 dot 或是中括弧來存取，且兩者可以交互使用，只要不會因為一些特殊字元影響即可（像是dot, space …），所以取得這個 mode 的資訊就有四種方法。 msg:\"file mode : {{ file.stat['mode'] }}\"msg:\"file mode : {{ file.stat.mode }}\"msg:\"file mode : {{ file.['stat']['mode'] }}\"msg:\"file mode : {{ file.['stat'].mode }}\"","date":"2023-02-20","objectID":"/posts/ansible/06_variables/:2:3","tags":["Ansible","Infra","Magic Variables"],"title":"Ansible - Variables","uri":"/posts/ansible/06_variables/"},{"categories":["Infra"],"content":"facts 在我們剛剛的測試中，都可以發現一開始都會有一個情況： TASK [Gathering Facts] ****************************************************************** ok: [vagrant1] 這代表 ansible 正在連接到 hosts，並查詢有關 hosts 的各種資訊，這些資訊都可以透過開頭為 ansible_facks 的變數來讀取。 修改一下我們前面用的 show.yml : --- name:Do something to hosthosts:allgather_facts:truetasks:- name:Print system detailsdebug:msg:\u003e-os_family: {{ ansible_facts.os_family }}, distro: {{ ansible_facts.distribution }} {{ ansible_facts.distribution_version }}, kernel: {{ ansible_facts.kernel }}...## Output TASK [Gathering Facts] ****************************************************************** ok: [vagrant3] ok: [vagrant1] ok: [vagrant2] TASK [Print system details] ************************************************************* ok: [vagrant1] =\u003e { \"msg\": \"os_family: Debian, distro: Ubuntu 20.04, kernel: 5.4.0-131-generic\" } ok: [vagrant2] =\u003e { \"msg\": \"os_family: Debian, distro: Ubuntu 20.04, kernel: 5.4.0-135-generic\" } ok: [vagrant3] =\u003e { \"msg\": \"os_family: RedHat, distro: CentOS 8, kernel: 4.18.0-277.el8.x86_64\" } Question 那我要如何知道，有哪些 ansible_fact 可以使用呢？ ansible 會自動幫我們收集這些資訊，只要透過 setup 這個 module 就可以知道搜集了哪些資訊。 輸出因為很多，我就不附上了，但可以知道他會回傳一個 key 為 ansible_facts 的 dictionary。 $ ansible [hostname or groupname] -m setup ## e.g. $ ansible vagrant2 -m setup vagrant2 | SUCCESS =\u003e { \"ansible_facts\": { \"ansible_all_ipv4_addresses\": [ \"10.0.2.15\" ], (more facts ....) 因為 ansible_facts 收集了很多資訊，我們可以使用 fact name 跟 filter 來找出我們要的 fact： ## 使用我們之前用的 groupname $ ansible vagrant -m setup -a 'filter=ansible_all_ipv4_addresses' ## Output vagrant3 | SUCCESS =\u003e { \"ansible_facts\": { \"ansible_all_ipv4_addresses\": [ \"10.0.2.15\" ], \"discovered_interpreter_python\": \"/usr/libexec/platform-python\" }, \"changed\": false } vagrant2 | SUCCESS =\u003e { \"ansible_facts\": { \"ansible_all_ipv4_addresses\": [ \"10.0.2.15\" ], \"discovered_interpreter_python\": \"/usr/bin/python3\" }, \"changed\": false } vagrant1 | SUCCESS =\u003e { \"ansible_facts\": { \"ansible_all_ipv4_addresses\": [ \"10.0.2.15\" ], \"discovered_interpreter_python\": \"/usr/bin/python3\" }, \"changed\": false } ","date":"2023-02-20","objectID":"/posts/ansible/06_variables/:3:0","tags":["Ansible","Infra","Magic Variables"],"title":"Ansible - Variables","uri":"/posts/ansible/06_variables/"},{"categories":["Infra"],"content":"local facts Ansible 提供了一個機制，讓我們可以建立 facts 並放在遠端主機上，只要放在 /etc/ansible/facts.d 底下且檔案符合以下機制： 為 .ini 格式 為 JSON 格式 不需要任何參數，便可以輸出 JSON 的執行檔 隨意建立一個吧，/etc/ansible/facts.d/example.fact [info]date=20230220weather=Rainy這時候你就可以透過 ansible_local 取得自己定義的 facts： $ ansible vagrant1 -m setup -a 'filter=ansible_local' ## Output { \"ansible_local\": { \"example\": { \"info\": { \"date\" : \"20230220\", \"weather\" : \"Rainy\" } } } } ## 當然，你也可以用 playbook，透過 debug 取得。 ","date":"2023-02-20","objectID":"/posts/ansible/06_variables/:3:1","tags":["Ansible","Infra","Magic Variables"],"title":"Ansible - Variables","uri":"/posts/ansible/06_variables/"},{"categories":["Infra"],"content":"set_fact 我們也可以在 task 當中，設置 fact，這用起來就跟設定新的 variable 一樣。 - name:Set nginx statewhen:ansible_facts.services.nginx.state is definedset_fact:nginx_state:\"{{ ansible_facts.services.nginx.state }}\"fact 提供給我們許多資訊，透過 ansible_fact 可以做更多運用，也可以透過 ansible_local 在遠端主機上建立 fact。 set_fact 通常被用來重新定義，因為存取 ansible_fact 往往都會是一大串的變數名稱，透過重新定義可以較容易的做存取。 ","date":"2023-02-20","objectID":"/posts/ansible/06_variables/:3:2","tags":["Ansible","Infra","Magic Variables"],"title":"Ansible - Variables","uri":"/posts/ansible/06_variables/"},{"categories":["Infra"],"content":"Magic Variables Ansible 有定義幾個在 playbook 中可以用的變數，這些變數被稱為 Magic Variables，也有人稱為 Built-in Variables。 通常建議保留而不建議覆蓋這些變數。 以下是幾個常用的 magic variables： hostvars group_names groups environment 可以試著用 debug 來觀察 hostvars 會有什麼資訊，基本上就是各個 node 的 facts。 另外，inventory_hostname 也是經常被拿來搭配使用。 - name:Retrieve host varshosts:- vagrant1- vagrant3tasks:- name:Show IP address by hostvarsdebug:var=hostvars[inventory_hostname]['ansible_default_ipv4']這邊就不附上結果了，請自行觀察。 更多 Magic Variables 的資訊跟使用方式，可以參考下列的文件： Discovering variables: facts and magic variables 魔法變數 因為我覺得 Magic variables 又可以寫一篇，但我好懶惰所以…以後有可能補上。 ","date":"2023-02-20","objectID":"/posts/ansible/06_variables/:4:0","tags":["Ansible","Infra","Magic Variables"],"title":"Ansible - Variables","uri":"/posts/ansible/06_variables/"},{"categories":["Infra"],"content":"結論 這次簡單介紹了幾種定義變數、存取變數與存取 facts 的方法，透過 variables 跟 facts ，可以讓我們的 tasks 更加靈活，像是取得 IP address 就直接透過 facts 取得就好，不必再使用 command。 另外也使用了 debug 這個指令，可以讓我們知道 variables 內到底有什麼數值。 最後，簡單介紹了一下 Magic variables。 ","date":"2023-02-20","objectID":"/posts/ansible/06_variables/:5:0","tags":["Ansible","Infra","Magic Variables"],"title":"Ansible - Variables","uri":"/posts/ansible/06_variables/"},{"categories":["Infra"],"content":"參考資料 Ansible: Up and Running: Automating Configuration Management and Deployment the Easy Way (3rd edition) Discovering variables: facts and magic variables 魔法變數 Ansible: Working with Variables and Hostvars ","date":"2023-02-20","objectID":"/posts/ansible/06_variables/:6:0","tags":["Ansible","Infra","Magic Variables"],"title":"Ansible - Variables","uri":"/posts/ansible/06_variables/"},{"categories":["Infra"],"content":"接續上篇 Invertory 做後續的介紹。大致上會介紹動態清單(Dynamic Inventory)跟一些相關指令。 ","date":"2023-01-26","objectID":"/posts/ansible/05_inventory_part2/:0:0","tags":["Ansible","Infra","invertory","Dynamic inventory"],"title":"Ansible - Inventory(下)","uri":"/posts/ansible/05_inventory_part2/"},{"categories":["Infra"],"content":"前言 因為這個月事情比較多，又剛好遇到過年想休息，這篇文章的內容可能會少一點。(一直都很少) ","date":"2023-01-26","objectID":"/posts/ansible/05_inventory_part2/:1:0","tags":["Ansible","Infra","invertory","Dynamic inventory"],"title":"Ansible - Inventory(下)","uri":"/posts/ansible/05_inventory_part2/"},{"categories":["Infra"],"content":"Dynamic Inventory ","date":"2023-01-26","objectID":"/posts/ansible/05_inventory_part2/:2:0","tags":["Ansible","Infra","invertory","Dynamic inventory"],"title":"Ansible - Inventory(下)","uri":"/posts/ansible/05_inventory_part2/"},{"categories":["Infra"],"content":"簡介 先前都是在 inventory/hosts 中直接指定 hosts 跟 Group，Dynamic Inventory 通常是指可以透過 Script 獲得的 Inventory ，且這個 Inventory 也是符合 ansible 所需格式的。 由於一些系統資源會是動態的進行增減，像是目前眾所皆知的 Cloud，我們可以透過 Script 與相關的 API 來取得 Inventory。 ","date":"2023-01-26","objectID":"/posts/ansible/05_inventory_part2/:2:1","tags":["Ansible","Infra","invertory","Dynamic inventory"],"title":"Ansible - Inventory(下)","uri":"/posts/ansible/05_inventory_part2/"},{"categories":["Infra"],"content":"格式 ansible 所需格式是 json，那格式長什麼樣子呢？ 我們可以透過一些指令來取得： $ ansible-inventory -i inventory/hosts --list 你會獲得一個 json 格式的輸出： { \"_meta\": { \"hostvars\": { \"vagrant1\": { \"ansible_port\": 2222 }, \"vagrant2\": { \"ansible_port\": 2200 }, \"vagrant3\": { \"ansible_port\": 2201 } } }, \"all\": { \"children\": [ \"ungrouped\", \"vagrant\" ] }, \"vagrant\": { \"hosts\": [ \"vagrant1\", \"vagrant2\", \"vagrant3\" ] } } _meta 這邊會包含所有 host 的資訊。 如果你只想觀察單台 host ，可以使用 --host 這個參數： $ ansible-inventory -i inventory/hosts --host=vagrant3 { \"ansible_port\": 2201 } ","date":"2023-01-26","objectID":"/posts/ansible/05_inventory_part2/:2:2","tags":["Ansible","Infra","invertory","Dynamic inventory"],"title":"Ansible - Inventory(下)","uri":"/posts/ansible/05_inventory_part2/"},{"categories":["Infra"],"content":"範例 因為我們使用的環境是 vagrant，我們可以透過 vagrant 的指令取得一些資訊，以利後面的 Dynamic Inventory 做使用。 $ vagrant status Current machine states: vagrant1 running (virtualbox) vagrant2 running (virtualbox) vagrant3 running (virtualbox) This environment represents multiple VMs. The VMs are all listed above with their current state. For more information about a specific VM, run `vagrant status NAME`. # 用這個指令也會取得許多資訊，因資訊量蠻多的，就不附上 Output。 $ vagrant status --machine-readable 接著我們建立一個 .py 檔，使用網路上大佬已經寫好的 Script。來源 你可以透過執行這個 Script，來觀察 ansible 的格式。 $ python test.py --list # 或是 $ python test.py --host=vagrant 建立完之後，我們需要使用 -i 這個 flag 來傳遞這個 Script， 跟上一篇文章一樣，我想看 vagrant 這個群組內的 hosts 時間是否一致？ $ ansible -i test.py vagrant -a \"date\" [WARNING]: * Failed to parse /U/cant/see/mypath/playbook/test.py with script plugin: problem running /U/cant/see/mypath/playbook/test.py --list ([Errno 13] Permission denied: '/U/cant/see/mypath/playbook/test.py') [WARNING]: * Failed to parse /U/cant/see/mypath/playbook/test.py with ini plugin: /U/cant/see/mypath/playbook/test.py:6: Expected key=value host variable assignment, got: argparse [WARNING]: Unable to parse /U/cant/see/mypath/playbook/test.py as an inventory source [WARNING]: No inventory was parsed, only implicit localhost is available [WARNING]: Could not match supplied host pattern, ignoring: vagrant [WARNING]: No hosts matched, nothing to do 發生了什麼？？？別慌張，權限不足而已。 讓我們更改一下，發現有一台壞孩子！ $ chmod 755 test.py $ $ ansible -i test.py vagrant -a \"date\" vagrant3 | CHANGED | rc=0 \u003e\u003e Fri Jan 27 12:45:33 UTC 2023 vagrant2 | CHANGED | rc=0 \u003e\u003e Sat Jan 28 11:35:43 UTC 2023 vagrant1 | CHANGED | rc=0 \u003e\u003e Sat Jan 28 11:35:43 UTC 2023 這樣當我們往後新增或刪除主機時，透過 Dynamic Inventory 可以減少一些工作量，但就是先前準備要比較辛苦。 另外在 EC2, GCP, Azure 或我們需要的地方做使用。 Question 如果你還留著說明 playbook 時的環境， 試一下或猜一下 $ ansible-playbook -i test.py webservers.yml，會有什麼結果？ ","date":"2023-01-26","objectID":"/posts/ansible/05_inventory_part2/:2:3","tags":["Ansible","Infra","invertory","Dynamic inventory"],"title":"Ansible - Inventory(下)","uri":"/posts/ansible/05_inventory_part2/"},{"categories":["Infra"],"content":"add_host, group_by 有的時候我們在運作 playbook 時，有新的 host 上線了，即使我們使用 Dynamic Inventory 也不會偵測到這台 host，因為 Dynamic Inventory 是在 playbook 運作前執行的。 ","date":"2023-01-26","objectID":"/posts/ansible/05_inventory_part2/:3:0","tags":["Ansible","Infra","invertory","Dynamic inventory"],"title":"Ansible - Inventory(下)","uri":"/posts/ansible/05_inventory_part2/"},{"categories":["Infra"],"content":"add_host add_host 可以指定 Group 跟一些自定義變數： - name:Add the vagrant machine to the inventoryadd_host:name:defaultgroup:webansible_host:127.0.0.1ansible_port:2222ansible_user:vagrantansible_private_key_file:\u003e.vagrant/machines/default/virtualbox/private_key如果運作成功，這之後你就可以使用 hosts: default 這台 host 做後續的工作了。 ","date":"2023-01-26","objectID":"/posts/ansible/05_inventory_part2/:3:1","tags":["Ansible","Infra","invertory","Dynamic inventory"],"title":"Ansible - Inventory(下)","uri":"/posts/ansible/05_inventory_part2/"},{"categories":["Infra"],"content":"group_by 一樣的，我們也可以在運作 playbook 時建立新的 Group。 像是作業系統的位元(x86, 64)，或是作業系統版本之類的(Ubuntu, CentOS)。 以我們現在的例子來說，有 Ubuntu 跟 CentOS，就可以試試看用作業系統來建立群組： ---- name:Group hosts by distributionhosts:allgather_facts:truetasks:- name:Create groups based on distrogroup_by:key:\"{{ ansible_facts.distribution }}\"- name:Do something to Ubuntu hostshosts:Ubuntubecome:truetasks:- name:Say I am Ubuntucommand:echo \"I am Ubuntu.\"register:result- name:print stdoutdebug:msg:\"{{ result.stdout }}\"- name:Do something else to CentOS hostshosts:CentOSbecome:truetasks:- name:Say I am CentOScommand:echo \"I am CentOS.\"register:result- name:print stdoutdebug:msg:\"{{ result.stdout }}\"如果上面的 Question 你不想試，那就用下面的吧。 如果順利的話，你應該會看到 vagrant1,2 跟 vagrant3 會有不一樣的訊息，因為他們已經被用版本分成不一樣的 Group。 $ ansible-playbook -i test.py distribution.yml PLAY [Group hosts by distribution] ****************************************************** TASK [Gathering Facts] ****************************************************************** ok: [vagrant3] ok: [vagrant2] ok: [vagrant1] TASK [Create groups based on distro] **************************************************** changed: [vagrant1] changed: [vagrant2] changed: [vagrant3] PLAY [Do something to Ubuntu hosts] ***************************************************** TASK [Gathering Facts] ****************************************************************** ok: [vagrant2] ok: [vagrant1] TASK [Say I am Ubuntu] ****************************************************************** changed: [vagrant2] changed: [vagrant1] TASK [print stdout] ********************************************************************* ok: [vagrant1] =\u003e { \"msg\": \"I am Ubuntu.\" } ok: [vagrant2] =\u003e { \"msg\": \"I am Ubuntu.\" } PLAY [Do something else to CentOS hosts] ************************************************ TASK [Gathering Facts] ****************************************************************** ok: [vagrant3] TASK [Say I am CentOS] ****************************************************************** changed: [vagrant3] TASK [print stdout] ********************************************************************* ok: [vagrant3] =\u003e { \"msg\": \"I am CentOS.\" } PLAY RECAP ****************************************************************************** vagrant1 : ok=5 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 vagrant2 : ok=5 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 vagrant3 : ok=5 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 ","date":"2023-01-26","objectID":"/posts/ansible/05_inventory_part2/:3:2","tags":["Ansible","Infra","invertory","Dynamic inventory"],"title":"Ansible - Inventory(下)","uri":"/posts/ansible/05_inventory_part2/"},{"categories":["Infra"],"content":"結論 這篇文章簡單介紹了 Dynamic Inventory 跟 add_host, group_by 兩個指令。 透過 Dynamic Inventory 可以減少在 hosts 增減時的工作量，add_host, group_by 這兩個指令可以更靈活的使用 playbook。 下一篇文章會介紹 Variable 跟 facts，關於 playbook 的使用跟運作 ansible-playbook 所回饋的結果。 ","date":"2023-01-26","objectID":"/posts/ansible/05_inventory_part2/:4:0","tags":["Ansible","Infra","invertory","Dynamic inventory"],"title":"Ansible - Inventory(下)","uri":"/posts/ansible/05_inventory_part2/"},{"categories":["Infra"],"content":"參考資料 Ansible: Up and Running: Automating Configuration Management and Deployment the Easy Way (3rd edition) Dynamic Inventory by charlesreid1 ","date":"2023-01-26","objectID":"/posts/ansible/05_inventory_part2/:5:0","tags":["Ansible","Infra","invertory","Dynamic inventory"],"title":"Ansible - Inventory(下)","uri":"/posts/ansible/05_inventory_part2/"},{"categories":["Infra"],"content":"簡單介紹 inventory，我們先前是管理一台主機(hosts)，而多個主機的集合在 Ansible 中會被稱為 inventory。 ","date":"2022-12-06","objectID":"/posts/ansible/04_inventory_part1/:0:0","tags":["Ansible","Infra","inventory",""],"title":"Ansible - Inventory(上)","uri":"/posts/ansible/04_inventory_part1/"},{"categories":["Infra"],"content":"事前準備 ","date":"2022-12-06","objectID":"/posts/ansible/04_inventory_part1/:1:0","tags":["Ansible","Infra","inventory",""],"title":"Ansible - Inventory(上)","uri":"/posts/ansible/04_inventory_part1/"},{"categories":["Infra"],"content":"ansible.cfg 我們先編輯 ansible.cfg，並啟用所有的 plugin。 [defaults] inventory = inventory [inventory] enable_plugins = host_list, script, auto, yaml, ini, toml Ansible invertory 是一個非常靈活的物件，它可以是一個 file，一個 directory，甚至是 executable。 inventory 可以跟 playbook 分開儲存，意味著我們可以在本地端設計 inventory，並在遠端機器上運行，像是 EC2, GCP 等等。 ","date":"2022-12-06","objectID":"/posts/ansible/04_inventory_part1/:1:1","tags":["Ansible","Infra","inventory",""],"title":"Ansible - Inventory(上)","uri":"/posts/ansible/04_inventory_part1/"},{"categories":["Infra"],"content":"Ｍultiple Vagrant Machines 前面也提到了，我們會管理多台主機，那我們就要先弄出多台主機！ 在這裡我們會配置 Vagrant 來啟動三台主機(你要弄更多台也可以)。 在這之前，我們先把先前使用的虛擬機摧毀掉(destory)： $ vagrant destory [--force] # 如果沒有使用 --force，則會提示並請確認是否要刪除列出的虛擬機。 接下來建立新的 Vagrantfile，以建立三台虛擬機： VAGRANTFILE_API_VERSION = \"2\" Vagrant.configure(VAGRANTFILE_API_VERSION) do |config| # Use the same key for each machine config.ssh.insert_key = false config.vm.define \"vagrant1\" do |vagrant1| vagrant1.vm.box = \"ubuntu/focal64\" vagrant1.vm.network \"forwarded_port\", guest: 80, host: 8080 vagrant1.vm.network \"forwarded_port\", guest: 443, host: 8443 end config.vm.define \"vagrant2\" do |vagrant2| vagrant2.vm.box = \"ubuntu/focal64\" vagrant2.vm.network \"forwarded_port\", guest: 80, host: 8081 vagrant2.vm.network \"forwarded_port\", guest: 443, host: 8444 end config.vm.define \"vagrant3\" do |vagrant3| vagrant3.vm.box = \"centos/stream8\" vagrant3.vm.network \"forwarded_port\", guest: 80, host: 8082 vagrant3.vm.network \"forwarded_port\", guest: 443, host: 8445 end end `config.ssh.insert_key = false` 這行設定讓我們可以透過一組 key 連線多個虛擬機。 Question 既然開啟了 80 跟 443 port，所以這三台主機有很大的機率是…? 設定完成後我們就啟動吧，UP !!! 這次有一台機器是 CentOS，也需要一點時間下載。 $ vagrant up 然後我們要知道，要使用哪些 port 才可以連線到 VM。 $ vagrant ssh-config 在預設情況下，Ansible 會使用 local SSH client，我們可以編輯 ssh config 讓我們更容易存取。 雖然這個範例中只有三台，而且 config 要新增的有點多，但如果遇到 300,3000 台呢？ 編輯 ~/.ssh/config : Host vagrant* Hostname 127.0.0.1 User vagrant UserKnownHostsFile /dev/null StrictHostKeyChecking no PasswordAuthentication no IdentityFile ~/.vagrant.d/insecure_private_key IdentitiesOnly yes LogLevel FATAL 接著我們新增 hosts 在 inventory 底下 (inventory/hosts)，port number 請依照前面觀察到的填寫。 vagrant1 ansible_port=2222 vagrant2 ansible_port=2200 vagrant3 ansible_port=2201 最後我們要確認能不能存取這些虛擬機，我們可以透過取得網卡資訊來確認： $ ansible vagrant1 -a \"ip addr\" 這邊提供目前的 tree 做參考。如果你是用前面用到的目錄來做也沒關係，只要確保三台虛擬機有正確新增，並且能觀察到網卡資訊即可。 . ├── Vagrantfile ├── ansible.cfg └── inventory └── hosts 到這邊我們的事前準備已經完成。先休息吧 ","date":"2022-12-06","objectID":"/posts/ansible/04_inventory_part1/:1:2","tags":["Ansible","Infra","inventory",""],"title":"Ansible - Inventory(上)","uri":"/posts/ansible/04_inventory_part1/"},{"categories":["Infra"],"content":"Inventory parameters 我們在設定 Inventory 時，有使用 ansible_port 作為參數，在前面的文章也有用到其他的參數。 如果我們想要覆蓋一些預設值時，可以使用下列的參數。 ansible_host : 主機名稱，代表我們要透過 SSH 連接到的主機名稱(或是 IP address)。 ansible_port : port number，代表我們要透過哪個 port 來連線。 ansible_user : 使用者名稱，透過 SSH 連線時所使用的使用者名稱。 ansible_password : 密碼，用於身份驗證時的密碼。 ansible_connection : 連線方式，ansible 也可以使用 SSH 以外的連線方式。 ansible_ssh_private_key_file : key，用於身份驗證時所使用的 SSH private key。 ansible_shell_type : shell，決定 shell 的種類。 ansible_python_interpreter : python_interpreter，決定在該 host 上的 python interpreter。 另外可以透過對應的變數，在 ansible.cfg 中覆蓋特定的預設值。 Inventory parameters ansible.cfg ansible_port remote_port ansible_user remote_user ansible_ssh_private_key_file ssh_private_key_file ansible_shell_type executable ","date":"2022-12-06","objectID":"/posts/ansible/04_inventory_part1/:2:0","tags":["Ansible","Infra","inventory",""],"title":"Ansible - Inventory(上)","uri":"/posts/ansible/04_inventory_part1/"},{"categories":["Infra"],"content":"Groups 所以我說要怎麼一次管多台？？ 我們可以透過 all 或是將 inventory 裡的 hosts 做 group 來進行多台主機的同時管理。 ","date":"2022-12-06","objectID":"/posts/ansible/04_inventory_part1/:3:0","tags":["Ansible","Infra","inventory",""],"title":"Ansible - Inventory(上)","uri":"/posts/ansible/04_inventory_part1/"},{"categories":["Infra"],"content":"all 直接給他用 all 就對了！ $ ansible all -a \"date\" ### 也可以用這種方式 $ ansible '*' -a \"date\" ","date":"2022-12-06","objectID":"/posts/ansible/04_inventory_part1/:3:1","tags":["Ansible","Infra","inventory",""],"title":"Ansible - Inventory(上)","uri":"/posts/ansible/04_inventory_part1/"},{"categories":["Infra"],"content":"使用 groups 我們編輯 inventory/hosts： [vagrant] vagrant1 ansible_port=2222 vagrant2 ansible_port=2200 vagrant3 ansible_port=2201 也可以先設定主機的資訊，後面再做 group : vagrant1 ansible_port=2222 vagrant2 ansible_port=2200 vagrant3 ansible_port=2201 [vagrant] vagrant1 vagrant2 vagrant3 那假如我們有 vagrant999，這樣我建 group 不就要弄很多次？ Ansible 支援 mumeric patterns： [vagrant] vagrant[1:3] 接著我們使用 Group name 下對應的指令，應該就會有管理多台主機的效果。 怎麼樣編輯 group 就依照自己的喜好或是需求編輯即可。 # 我想看 vagrant 這個群組內的 hosts 時間是否一致？ $ ansible vagrant -a \"date\" vagrant3 | CHANGED | rc=0 \u003e\u003e Tue Dec 6 07:55:56 UTC 2022 vagrant2 | CHANGED | rc=0 \u003e\u003e Tue Dec 6 07:55:56 UTC 2022 vagrant1 | CHANGED | rc=0 \u003e\u003e Tue Dec 6 07:55:56 UTC 2022 ","date":"2022-12-06","objectID":"/posts/ansible/04_inventory_part1/:3:2","tags":["Ansible","Infra","inventory",""],"title":"Ansible - Inventory(上)","uri":"/posts/ansible/04_inventory_part1/"},{"categories":["Infra"],"content":"參考資料 Ansible: Up and Running: Automating Configuration Management and Deployment the Easy Way (3rd edition) ","date":"2022-12-06","objectID":"/posts/ansible/04_inventory_part1/:4:0","tags":["Ansible","Infra","inventory",""],"title":"Ansible - Inventory(上)","uri":"/posts/ansible/04_inventory_part1/"},{"categories":["Infra"],"content":"本篇文章將簡單說明，如何在 Ubuntu/Debian 上架設 DHCPv6 伺服器。 ","date":"2022-11-30","objectID":"/posts/infra/builddhcpv6ondebian/:0:0","tags":["DHCP","DHCPv6","DHCP Server","DHCPv6 Server"],"title":"在 Ubuntu/Debian 上架設 DHCPv6 服務","uri":"/posts/infra/builddhcpv6ondebian/"},{"categories":["Infra"],"content":"前言 基本上是因為工作遇到問題，突然要使用 DHCPv6，但網路上的資料有點亂，嘗試了不少來源才試成功，故想紀錄下來供以後做參考。 如果你進來是想看 configure 的，請直接跳到那邊就好了！ 其他相關的參數，以後有空再說明吧！ 其實原先是想建一台 Windows Server 的虛擬機器，然後在虛擬機上面做 DHCPv6 Server，因為用 GUI 可以輕鬆解決， 但因為手邊硬體關係，不太能使用 Windows Server 來做，於是選擇在 Ubuntu 上架設！（我也沒買 Windows Server …） 但因為自己順手的還是 Debian，故也有在 Debian 上架設一次，設定上並沒有差很多。 ","date":"2022-11-30","objectID":"/posts/infra/builddhcpv6ondebian/:1:0","tags":["DHCP","DHCPv6","DHCP Server","DHCPv6 Server"],"title":"在 Ubuntu/Debian 上架設 DHCPv6 服務","uri":"/posts/infra/builddhcpv6ondebian/"},{"categories":["Infra"],"content":"Environment 這邊選擇在 Ubuntu 上做架設，但我也有在 Debian 上的架設完成，方式也類似， 這邊會使用 isc-dhcp-server 做架設。 環境: $ user@ubuntu:~$ lsb_release -a No LSB modules are avariable. Distributor ID: Ubuntu Description: Ubuntu 22.04.1 LTS Release: 22.04 Codename: jammy ","date":"2022-11-30","objectID":"/posts/infra/builddhcpv6ondebian/:2:0","tags":["DHCP","DHCPv6","DHCP Server","DHCPv6 Server"],"title":"在 Ubuntu/Debian 上架設 DHCPv6 服務","uri":"/posts/infra/builddhcpv6ondebian/"},{"categories":["Infra"],"content":"Install 我們透過 apt 來安裝 isc-dhcp-server 這個套件。 $ sudo apt-get install isc-dhcp-server -y 因為現在的 Ubuntu 好像預設不會裝 net-tools，這邊也一併裝起來好了。主要是因為我們後續要在介面上設定一個 static IP address。其實因為習慣了 ifconfig。 如果你有其他習慣使用的工具，你可以跳過這一步！ $ sudo apt-get install net-tools -y 接著在介面上設定 static IP address。 enp0s3 是我的介面名稱。6666::a/64 是我要設定的 IPv6 address。 當然，你要依據你的環境來做適當的設定。 $ sudo ifconfig enp0s3 inet6 add 6666::a/64 大概到這邊，基本的環境已經安裝與設置完成。 ","date":"2022-11-30","objectID":"/posts/infra/builddhcpv6ondebian/:3:0","tags":["DHCP","DHCPv6","DHCP Server","DHCPv6 Server"],"title":"在 Ubuntu/Debian 上架設 DHCPv6 服務","uri":"/posts/infra/builddhcpv6ondebian/"},{"categories":["Infra"],"content":"Configure 在 /etc/dhcp 底下有一個 dhcpd6.conf 的檔案，這個檔案就做為參考用即可，我們將它備份然後建立一個 dhcpd6.conf， 我喜歡在備份的檔案後面加上 .bak。 $ cd /etc/dhcp $ mv dhcpd6.conf dhcpd6.conf.bak $ touch dhcpd6.conf 接著編輯 dhcpd6.conf，可以參考下面的 config。 default-lease-time 600; max-lease-time 7200; log-facility local7; subnet6 6666::/64 { range6 6666::1 6666::9; } default-lease-time : 預設租期時間長度(秒) max-lease-time : 最大租期時間長度(秒) log-facility : 決定 facility 的等級(level)，這邊採用 local 7 即可。透過 log 可以較容易除錯。 subnet6 : 網段的部分自行決定即可。 接著要讓 dhcpd6 有修改 dhcpd6.leases 的權限，我們使用 chown 來做設定。 dhcpd6.leases 的路徑在 /var/lib/dhcp 底下。 # 先注意一下你的環境中有沒有 /var/lib/dhcp/dhcpd6.leases # 我的環境中是有這個檔案，如果你的環境中沒有，請你用 touch 建立一個！ $ touch /var/lib/dhcp/dhcpd6.leases # 設定一下擁有者跟擁有群組。 $ chown dhcpd:dhcpd /var/lib/dhcp/dhcpd6.leases # Debian 中可能會遇到沒有 dhcpd 這個 user 跟 group， # 那就要控制擁有者跟群組對檔案的存取權限，使用 chmod。 $ chmod 666 /var/lib/dhcp/dhcpd6.leases 接著使用下面這行指令，進行手動啟動測試，他會套用你的設定檔與網路介面提供 DHCPv6 的服務。 我們可以透過下面這個指令來觀察你的設備有沒有取得 IPv6 address 並且是在設定的範圍內，如果沒有問題就接續後面的步驟。 $ sudo dhcpd -6 -f -cf /etc/dhcp/dhcpd6.conf enp0s3 另外如果有遇到問題，可以使用 journalctl -u isc-dhcp-server -e 來觀察 log ，通常會告訴你哪裡有問題，處理掉該問題即可。 最後一步，我們要設定哪一個介面來處理 DHCP request。 $ sudo vim /etc/default/isc-dhcp-server # 編輯最下面的 INTERFACEv6 INTERFACEv6=\"enp0s3\" # 重新啟動吧！ $ sudo service isc-dhcp-server restart ","date":"2022-11-30","objectID":"/posts/infra/builddhcpv6ondebian/:4:0","tags":["DHCP","DHCPv6","DHCP Server","DHCPv6 Server"],"title":"在 Ubuntu/Debian 上架設 DHCPv6 服務","uri":"/posts/infra/builddhcpv6ondebian/"},{"categories":["Infra"],"content":"leases 最後，要如何在 server 上看到我們 leases 了哪些 IP 給 client 呢？ 就在我們前面設定的 /var/lib/dhcp/dhcpd6.leases 裡面唷，用編輯器或是 cat 之類的工具瀏覽即可。 ","date":"2022-11-30","objectID":"/posts/infra/builddhcpv6ondebian/:5:0","tags":["DHCP","DHCPv6","DHCP Server","DHCPv6 Server"],"title":"在 Ubuntu/Debian 上架設 DHCPv6 服務","uri":"/posts/infra/builddhcpv6ondebian/"},{"categories":["Infra"],"content":"小節 其實以前就架設過 DHCPv6 Server，但是在較舊版本的 Debian 上，當時所做的筆記用到現在卻不能用。印象中以前只要設定好 dhcpd6.conf 然後 restart service 就好的說。 另外也有一些不常用的系統管理工具(systemctl, journalctl)，也藉著這個機會學習。以前都是傻傻的看 syslog，很累的 ","date":"2022-11-30","objectID":"/posts/infra/builddhcpv6ondebian/:6:0","tags":["DHCP","DHCPv6","DHCP Server","DHCPv6 Server"],"title":"在 Ubuntu/Debian 上架設 DHCPv6 服務","uri":"/posts/infra/builddhcpv6ondebian/"},{"categories":["Infra"],"content":"參考資料 “Can’t open /var/lib/dhcp/dhcpd6.leases for append.” during start of ISC DHCP IPv6 Server SUSE - journalctl ","date":"2022-11-30","objectID":"/posts/infra/builddhcpv6ondebian/:7:0","tags":["DHCP","DHCPv6","DHCP Server","DHCPv6 Server"],"title":"在 Ubuntu/Debian 上架設 DHCPv6 服務","uri":"/posts/infra/builddhcpv6ondebian/"},{"categories":["Infra"],"content":"本篇會接續上篇文章做進一步的說明與示範。 ","date":"2022-11-25","objectID":"/posts/ansible/03_playbook_part2/:0:0","tags":["Ansible","Infra","playbook"],"title":"Ansible - Playbook(下)","uri":"/posts/ansible/03_playbook_part2/"},{"categories":["Infra"],"content":"事前準備 : TLS ","date":"2022-11-25","objectID":"/posts/ansible/03_playbook_part2/:1:0","tags":["Ansible","Infra","playbook"],"title":"Ansible - Playbook(下)","uri":"/posts/ansible/03_playbook_part2/"},{"categories":["Infra"],"content":"Info 在前面的例子中，可以觀察到我們開啟了 443 port ， 這通常用在 https 的應用中，透過 SSL/TLS 進行加密達到傳輸安全。 SSL/TLS 的資訊可以參考High Performance Browser Networking - Transport Layer Security (TLS) Info 既然提到了 High Performance Browser Networking 這本書，如果對網路很有興趣的，這邊推推一下這本書給各位。 ","date":"2022-11-25","objectID":"/posts/ansible/03_playbook_part2/:1:1","tags":["Ansible","Infra","playbook"],"title":"Ansible - Playbook(下)","uri":"/posts/ansible/03_playbook_part2/"},{"categories":["Infra"],"content":"Generating a TLS Certificate 基本上證書大都是從 Certificate authority (CA) 所頒發，代表這個證書有效，但在後面的例子中我們會使用自行簽署的證書。 ## 注意下指令時的 Directory ! $ openssl req -x509 -nodes -days 365 -newkey rsa:4096 -sha256 -subj /CN=localhost -keyout files/nginx.key -out files/nginx.crt 然後我們複製上一篇所使用的 webservers.yml 並重新命名為 webservers-tls.yml ","date":"2022-11-25","objectID":"/posts/ansible/03_playbook_part2/:1:2","tags":["Ansible","Infra","playbook"],"title":"Ansible - Playbook(下)","uri":"/posts/ansible/03_playbook_part2/"},{"categories":["Infra"],"content":"Variables (vars) ","date":"2022-11-25","objectID":"/posts/ansible/03_playbook_part2/:2:0","tags":["Ansible","Infra","playbook"],"title":"Ansible - Playbook(下)","uri":"/posts/ansible/03_playbook_part2/"},{"categories":["Infra"],"content":"Example 在這個範例中，會定義五個變數，並為每個變數賦值： vars:tls_dir:/etc/nginx/ssl/key_file:nginx.keycert_file:nginx.crtconf_file:/etc/nginx/site-available/defaultserver_name:localhost在這個範例中，每一個值都是字串，但也能使用 boolean, list 跟 dictionary。 這些變數都是在 nginx 中與 https 有關的參數。 接著，加入這個 task 到 playbook 中： - name:Manage nginx config templatetemplate:src:nginx.conf.j2dest:\"{{ conf_file }}\"mode:'0644'notify:Restart nginx在執行這個 task 的時候，dest 就會被更改為我們前面所設定的 /etc/nginx/site-available/default。 ","date":"2022-11-25","objectID":"/posts/ansible/03_playbook_part2/:2:1","tags":["Ansible","Infra","playbook"],"title":"Ansible - Playbook(下)","uri":"/posts/ansible/03_playbook_part2/"},{"categories":["Infra"],"content":"Quoting in Ansible Strings 有時候我們會想在變數後面直接做一些事情： - name:Perform some taskcommand :{{key_file}} -a foo但這樣子，Ansible 會將其視為 dictionary 而返回錯誤，我們必須使用引號： - name:Perform some taskcommand :\"{{key_file}} -a foo\"另外，如果我們的參數中有冒號 : ，也需要使用引號： - name:Show msgdebug:msg:\"Error : wrong parameter ...\"","date":"2022-11-25","objectID":"/posts/ansible/03_playbook_part2/:2:2","tags":["Ansible","Infra","playbook"],"title":"Ansible - Playbook(下)","uri":"/posts/ansible/03_playbook_part2/"},{"categories":["Infra"],"content":"Template ","date":"2022-11-25","objectID":"/posts/ansible/03_playbook_part2/:3:0","tags":["Ansible","Infra","playbook"],"title":"Ansible - Playbook(下)","uri":"/posts/ansible/03_playbook_part2/"},{"categories":["Infra"],"content":"Intro Ansible 主要是做 configure，如果可以避免，大家都不會希望手動編輯一堆 config(cfg)，如果說多個 config 中有重複使用的特定欄位或是數據的位置，會建議另外取得這些資訊，並記錄在一個位置，透過 template 來生成需要這個資訊的 config。 Ansible 使用 Jinia2 來實現範本化(templating)，就像 Flask、ERB 與 Django 一樣。 Nginx 的設定檔中，需要 TLS 金鑰與證書的路徑，這邊將透過 Ansible 的範本功能來定義這個設定檔。 $ touch template/nginx.conf.j2 $ vim nginx.conf.j2 ## 修改為下面的內容 server { listen 80 default_server; listen [::]:80 default_server ipv6only=on; listen 443 ssl; ssl_protocols TLSv1.2; ssl_prefer_server_ciphers on; root /usr/share/nginx/html; index index.html; server_tokens off; add_header X-Frame-Options DENY; add_header X-Content-Type-Options nosniff; server_name {{ server_name }}; ssl_certificate {{ tls_dir }}{{ cert_file }}; ssl_certificate_key {{ tls_dir }}{{ key_file }}; location / { try_files $uri $uri/ =404; } } 我們在範本檔後面加上 .j2 是來表示這是 jinja2 template，但其實不使用 .j2 也不會影響。 在這個檔案中，我們定義了先前定義的四個參數。 ","date":"2022-11-25","objectID":"/posts/ansible/03_playbook_part2/:3:1","tags":["Ansible","Infra","playbook"],"title":"Ansible - Playbook(下)","uri":"/posts/ansible/03_playbook_part2/"},{"categories":["Infra"],"content":"Loop 當我們想對 list 中的每一項執行一個 task 時，可以使用 loop，循環多次執行 task，並且每一次都會使用所指定的 list 中的不同值來執行。 - name:Copy TLS filescopy:src:\"{{ item }}\"dest:\"{{ tls_dir }}\"mode:'0600'loop:- \"{{ key_file }}\"- \"{{ cert_file }}\"notify:Restart nginx","date":"2022-11-25","objectID":"/posts/ansible/03_playbook_part2/:3:2","tags":["Ansible","Infra","playbook"],"title":"Ansible - Playbook(下)","uri":"/posts/ansible/03_playbook_part2/"},{"categories":["Infra"],"content":"Handler 我們在 playbook 中加入 handler : handlers:- name:Restart nginxservice:name:nginxstate:restartedhandler 他類似 task ，但只有在 task 通知後才會運作。通常用在重新啟動服務的時候。 如果 Ansible 識別出， task 已經更改系統的狀態。那 task 就會發出通知，並將處理程序的名稱做為參數來傳遞。 在這個例子中，處理程序的名稱是 nginx，如果有下列情況發生，則會重新啟動 nginx： TLS key 改變。 TLS certificate 改變。 configuration file 改變。 站台(site)中的內容改變。 因為在更改服務或系統的設定或是檔案時，大部分的情況需要重新啟動讓服務或系統重新讀取這些設定檔。 後續我們會在每個 task 的後面，加上 notify 讓這些 task 可以做通知。 另外我們可以在 playbook 後面無條件的重新啟動服務，重新啟動服務並不會浪費很多時間，但要注意服務的性質，例如 nginx 重啟的話，會影響到客戶的 session。 這個方式也可以在自己想要的位置使用，執行某個或某些 task 之後就強制使用 handler。 - name:Restart nginxmeta:flush_handlers最後應該會有一個類似這樣的結果： ---- name:Configure webserver with nginxhosts:webserversbecome:True# 關掉這個可以讓他跑快一點！gather_facts:falsevars:tls_dir:/etc/nginx/ssl/key_file:nginx.keycert_file:nginx.crtconf_file:/etc/nginx/sites-available/defaultserver_name:localhosthandlers:- name:Restart nginxservice:name:nginxstate:restartedtasks:- name:Ensure nginx is installedpackage:name:nginx update_cache:truenotify:Restart nginx- name:Create directories for TLS certificatesfile:path:\"{{ tls_dir }}\"state:directorymode:'0750'notify:Restart nginx- name:Copy TLS filescopy:src:\"{{ item }}\"dest:\"{{ tls_dir }}\"mode:'0600'loop:- \"{{ key_file }}\"- \"{{ cert_file }}\"notify:Restart nginx- name:Copy nginx config filecopy:src:nginx.confdest:/etc/nginx/sites-available/default- name:Manage nginx config templatetemplate:src:nginx.conf.j2dest:\"{{ conf_file }}\"mode:'0644'notify:Restart nginx- name:Enable configurationfile:dest:/etc/nginx/sites-enabled/defaultsrc:/etc/nginx/sites-available/defaultstate:link- name:Install home pagetemplate:src:index.html.j2dest:/usr/share/nginx/html/index.htmlmode:'0644'- name:Restart nginxmeta:flush_handlers...","date":"2022-11-25","objectID":"/posts/ansible/03_playbook_part2/:4:0","tags":["Ansible","Infra","playbook"],"title":"Ansible - Playbook(下)","uri":"/posts/ansible/03_playbook_part2/"},{"categories":["Infra"],"content":"測試 在進行測試以前，我們應該先檢查語法！ $ ansible-playbook --syntax-check webservers-tls.yml $ ansible-lint webservers-tls.yml $ yamllint webservers-tls.yml $ ansible-inventory --host testserver -i inventory/vagrant.ini $ vagrant validate 檢查一下目錄！ . ├── Vagrantfile ├── ansible.cfg ├── files │ ├── nginx.conf │ ├── nginx.crt │ └── nginx.key ├── inventory │ └── vagrant.ini ├── templates │ ├── index.html.j2 │ └── nginx.conf.j2 ├── webservers-tls.yml └── webservers.yml 如果沒有問題，跟以前一樣！ $ ansible-playbook webservers-tls.yml 應該能夠透過 https://localhost:8443 看到網頁，只是說因為我們是用自簽署憑證。瀏覽器會有警告訊息！ ","date":"2022-11-25","objectID":"/posts/ansible/03_playbook_part2/:5:0","tags":["Ansible","Infra","playbook"],"title":"Ansible - Playbook(下)","uri":"/posts/ansible/03_playbook_part2/"},{"categories":["Infra"],"content":"結論 本篇文章簡單說明了 vars 跟 handler，並建立了簡單的 template 來運行。 其實這邊應該是要跟上一篇一起寫完的，只是覺得內容有點多，就分成了兩篇來寫。 下一篇應該會介紹 Inventory 吧，應該吧。 ","date":"2022-11-25","objectID":"/posts/ansible/03_playbook_part2/:6:0","tags":["Ansible","Infra","playbook"],"title":"Ansible - Playbook(下)","uri":"/posts/ansible/03_playbook_part2/"},{"categories":["Infra"],"content":"參考資料 Ansible: Up and Running: Automating Configuration Management and Deployment the Easy Way (3rd edition) High Performance Browser Networking ","date":"2022-11-25","objectID":"/posts/ansible/03_playbook_part2/:7:0","tags":["Ansible","Infra","playbook"],"title":"Ansible - Playbook(下)","uri":"/posts/ansible/03_playbook_part2/"},{"categories":["Infra"],"content":"使用 ansible 第一步就是編寫 playbook，本篇文章會簡單介紹 playbook。 會以設定一台主機，並透過 nginx 運作一個簡單的 HTTP 伺服器作為範例。運作完成後再進行介紹。 ","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:0:0","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"事前準備 : 安裝 VirtualBox, Vagrant 雖然沒提到，但前一篇文章我是使用 VMware workstation 並建立虛擬機做測試，後來因為某些原因，我自己的電腦出了問題而無法使用，直到最近才重新弄回來，想說要重新建環境，那試試看新的方式好了。 VirtualBox 的安裝很簡單，到官網直接下載就好！！ VirtualBox Vagrant 的安裝方式，我是在 MacOS 上，直接用 brew 搞定 ！ $ brew install vagrant 如果很順利的話，我們來建立一個目錄，等等要放我們會用到的 playbook 與相關文件。首先來建立 Vagrant configuration file 並測試我們剛剛安裝的 Virtualbox 與 Vagrant 是否運作正常。 $ mkdir playbooks $ cd playbooks $ vagrant init ubuntu/focal64 # 會建立一個 Vrgrantfile $ vagrant up # 第一次做這件事情會花一些時間！ $ vagramt ssh ### 如果安裝好了，使用這個指令，應該會看到類似下面的畫面 Welcome to Ubuntu 20.04.5 LTS (GNU/Linux 5.4.0-131-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Fri Oct 21 05:32:26 UTC 2022 System load: 0.59 Processes: 122 Usage of /: 3.5% of 38.70GB Users logged in: 0 Memory usage: 21% IPv4 address for enp0s3: 10.0.2.15 Swap usage: 0% 0 updates can be applied immediately. New release '22.04.1 LTS' available. Run 'do-release-upgrade' to upgrade to it. vagrant@ubuntu-focal:~$ 如果可以看到上述畫面，代表我們的 VirtualBox 跟 Vagrant 是運作正常的！ 接著修改 Vrgrantfile 如下，以利做後續的實作。主要是要做 forwarding，以 http 來說明，就是把127.0.0.1:8080 映射到 VM 的 443 埠。 Vagrant.configure(2) do |config| config.vm.box = \"ubuntu/focal64\" config.vm.hostname = \"testserver\" config.vm.network \"forwarded_port\", id: 'ssh', guest: 22, host: 2202, host_ip: \"127.0.0.1\", auto_correct: false config.vm.network \"forwarded_port\", id: 'http', guest: 80, host: 8080, host_ip: \"127.0.0.1\" config.vm.network \"forwarded_port\", id: 'https', guest: 443, host: 8443, host_ip: \"127.0.0.1\" # disable updating guest additions if Vagrant.has_plugin?(\"vagrant-vbguest\") config.vbguest.auto_update = false end config.vm.provider \"virtualbox\" do |virtualbox| virtualbox.name = \"test\" end end 修改完之後，請使用 vagrant up 來實現這些修改。應該會看到下面的輸出。 ==\u003e default: Forwarding ports... default: 22 (guest) =\u003e 2202 (host) (adapter 1) default: 80 (guest) =\u003e 8080 (host) (adapter 1) default: 443 (guest) =\u003e 8443 (host) (adapter 1) 到這邊，我們的虛擬機環境建立完成，接下來可以開始寫 playbook 了 ！ ","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:1:0","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"初體驗 建立 playbooks/webservers.yml，並貼上下列內容。 --- - name: Configure webserver with nginx hosts: webservers become: True tasks: - name: Ensure nginx is installed package: name=nginx update_cache=yes - name: Copy nginx config file copy: src: nginx.conf dest: /etc/nginx/sites-available/default - name: Enable configuration file: \u003e dest=/etc/nginx/sites-enabled/default src=/etc/nginx/sites-available/default state=link - name: Copy index.html template: \u003e src=index.html.j2 dest=/usr/share/nginx/html/index.html - name: Restart nginx service: name=nginx state=restarted ... 另外，因為運行 nginx 需要設定檔，這裡也一並附上。 需要什麼檔案，我們需要另外放在 file 目錄底下。 $ mkdir file $ cd file $ touch nginx.conf $ vim nginx.conf 這裡也先附上一個簡單的 nginx.conf。 server { listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /usr/share/nginx/html; index index.html index.htm; server_name localhost; location / { try_files $uri $uri/ =404; } } 接下來我們要建立一個簡單的網頁範本。如果沒有網頁，我們要看什麼？ 把這個範本放在 playbooks/templates 底下，命名為 index.html.j2 \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eWelcome to ansible\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eNginx, configured by Ansible\u003c/h1\u003e \u003cp\u003eIf you can see this, Ansible successfully installed nginx.\u003c/p\u003e \u003cp\u003eRunning on {{ inventory_hostname }}\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 建立 inventory，存放這台 VM 的遠端資訊。 我們把這個檔案命名為 vagrant.ini，放在 playbooks/inventory 底下 [webservers] testserver ansible_port=2202 [webservers:vars] ansible_user = vagrant ansible_host = 127.0.0.1 ansible_private_key_file = .vagrant/machines/default/virtualbox/private_key 最後，把我們前一章所用到的 ansible.cfg 修改一下後放到 playbooks 裏面。 [defaults] inventory = inventory/vagrant.ini host_key_checking = False stdout_callback = yaml callback_enabled = timer 現在我們的目錄應該要有這些檔案： . ├── Vagrantfile ├── ansible.cfg ├── files │ └── nginx.conf ├── inventory │ └── vagrant.ini ├── templates │ └── index.html.j2 └── webservers.yml 確認沒問題之後，我們執行這個指令： $ ansible-playbook webservers.yml 接著我們打開瀏覽器，連線到 http://localhost:8080 ，應該能看到 html 的畫面！ 順利完成啦～ 觀察一下 templates 內的 inventory_hostname 在哪，內容又是什麼？\" 順利完成啦～ 觀察一下 templates 內的 inventory_hostname 在哪，內容又是什麼？ ","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:2:0","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"YAML ","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:3:0","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"開頭、結尾 YAML 會以 ---跟...作為開頭與結尾，每一個 Ansible flie 都只會有一個 YAML document。 習慣上會以這兩個作為開頭與結尾，但就算沒有使用，在 Ansible 中是不會出問題的。 ","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:3:1","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"註解 註解的方式與許多程式語言相識，使用 # 開頭作為註解。 # This is comment","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:3:2","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"縮排 沒有硬性規定，經常使用兩個空格（space） 做縮排。 ","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:3:3","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"字串 與許多程式語言不同，字串不需要特別加上單引號或是雙引號。 This is STRING但在 Ansible 的環境中，某些情況下會建議替字串加上引號，後面將會對這些內容進行說明。 ","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:3:4","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"布林值 在 YAML 中， Boolean 有許多種表示方法，使用上非常靈活。 # These are truetrue,True,TRUE,yes,Yes,YES,on,On,ON# These are falsefalse,False,FALSE,no,No,NO,off,Off,OFF","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:3:5","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"清單（list） 他其實就像陣列，或是 python 的 list，基本上會用縮排與 - 做分隔，而名稱的後面會加上分號： Dinner:- Hamburger- French fries- Cola也可以用這種表示方式： Dinner:[Hamburger, French fries, Cola]","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:3:6","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"字典 (Dictionary) 基本上就像 hashes 或是其他程式語言的 dictionary。 Dinner:main :Hamburgerside dish :French friesdrink :Cola或是這種表示方法： Dinner:{main : Hamburger , side dish : French fries, drink :Cola}","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:3:7","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"Anatomy ","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:4:0","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"YAML Format 網路上有許多 ansible file 的寫法說明，但以我自己在 Github actions 的經驗中，會建議使用純 YAML 樣式，因為可以透過工具 yamllist 做檢查。 以前面的 webservers.yml 為例子： # Before- name:Ensure nginx is installedpackage:name=nginx update_cache=true# After- name:Ensure nginx is installedpackage:name:nginx update_cache:true來修改一下 webserver.yml 吧： ---- name:Configure webserver with nginxhosts:webserversbecome:truetasks:- name:Ensure nginx is installedpackage:name:nginxupdate_cache:true- name:Copy nginx config filecopy:src:nginx.confdest:/etc/nginx/sites-available/default- name:Enable configurationfile:src:/etc/nginx/sites-available/defaultdest:/etc/nginx/sites-enabled/defaultstate:link- name:Copy home page templatetemplate:src:index.html.j2dest:/usr/share/nginx/html/index.html- name:Restart nginxservice:name:nginxstate:restarted...在這個檔案中，用到了許多 configure，透過這些 configure 來設計我們要在這台 host 上要做的事情。 這邊先提一下常見的三個參數： name: 描述這個 play 所做的內容，會建議用大寫字母作為開頭。 become: 如果這個參數為 True，代表要運行 tasks，另外可以用 become_user 來設定為有權限的 user。 vars: 變數或是數值的清單。 ","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:4:1","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"Modules Modules 是隨著 Ansible 在主機上執行某種操作的 script(?) 不同的 Modules 之間有巨大的差異，以前面的例子來說就用了不少 Modules，也處理不同的事情。 package : 使用 host 的 package manager 安裝或是刪除 package。 copy : 把檔案從用作 ansible 的 host 複製到遠端 host file : 設置檔案、目錄的屬性 service : 啟動、停止或重新啟動服務 template : 從 template 產生檔案，並複製到遠端 host。 如果想要了解 Module 更深入的使用方式，可以使用 ansible-doc [module name] 來看說明文件並作進一步的使用： ## Example : $ ansible-doc service ","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:4:2","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"Structure playboos 包含一個或多個 play，而 play 將 host 與 Task 做關聯，每個 Task 只與一個 Module 做關聯，如果以圖來表示關係的話，大概會是像下圖這樣子： 關係圖\" 關係圖 ","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:4:3","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"Status 當開始運作 Ansible 時，會發現某些任務有狀態，以稍早我們操作的結果，會看到 ok 與 Change 兩種狀態，在最後也會有一個關於 status 的統計： $ ansible-playbook webservers.yml PLAY [Configure webserver with nginx] ****************************************** TASK [Gathering Facts] ********************************************************* ok: [testserver] TASK [Ensure nginx is installed] *********************************************** changed: [testserver] TASK [Copy nginx config file] ************************************************** changed: [testserver] TASK [Enable configuration] **************************************************** ok: [testserver] TASK [Copy index.html] ********************************************************* changed: [testserver] TASK [Restart nginx] *********************************************************** changed: [testserver] PLAY RECAP ********************************************************************* testserver : ok=6 changed=4 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 ok : 如果遠端主機跟 module 的設置匹配，則不會進行任何操作，會以 ok 來表示。 change : 與 ok 不同，如果遠端主機跟 module 的設置不匹配， Ansible 會更改遠端主機的狀態，並以 change 來表示。 另外還有 unreachable、failed、skipped、rescued 和 ignored 等狀態，當錯誤或是特定狀況發生時，會以這些 status 來表示，並提供相對的訊息。 也因此，ansible 不僅可以更改遠端主機上的配置，也可以透過 status 來觀察遠端主機的配置內容，或是檢查配置內容是否有改變。 ","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:5:0","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"小結 基本上透過這個 playbook 與環境設置，應該能夠建立並設定 nginx 來提供服務，下篇文章會再透過 vars 做進一步的介紹。 ","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:6:0","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["Infra"],"content":"參考資料 Ansible: Up and Running: Automating Configuration Management and Deployment the Easy Way (3rd edition) Vagrant VirtualBox ","date":"2022-10-24","objectID":"/posts/ansible/02_playbook/:7:0","tags":["Ansible","Infra","vagrant","playbook"],"title":"Ansible - Playbook(上)","uri":"/posts/ansible/02_playbook/"},{"categories":["SRE"],"content":"前言 這邊是我自己想寫的廢話，可以 skip 不看。 基本上現在處於一種 Chaos 的狀態吧，一邊點著 coding 的技能，另一邊又不願意放開 system \u0026 networking administration(management) 的技能樹，有一陣子去看了 SRE 的書籍，坦白說可能也不是很適合自己，但仍以學習新知識的角度來學習這項技能(或是知識)。 參考書籍 Google 已經提供，我有附在後面的參考資料。 基本上會是以 Site Reliability Engineering 這本書來作筆記。(其實是有想起來這本書看了一半，就乾脆把書看完吧) ","date":"2022-08-30","objectID":"/posts/infra/sre_1/:1:0","tags":["Infra","SRE"],"title":"Site Reliability Engineering - Introduction","uri":"/posts/infra/sre_1/"},{"categories":["SRE"],"content":"Tradition 公司透過系統來提供服務，而這些系統並不會自動運作，歷史上來看會需要雇用系統管理員(Administrator, Admin)來運行或維護系統(IT,MIS)，Admin的任務基本上是做部屬，讓系統之間能協同工作並提供服務，還有在問題發生時進行處理(Update, troubleshooting …)，由於技能樹點的不同，基本上在大部分的公司中，軟體或服務開發人員，與系統管理員，會分為兩個團隊。 目前在系統管理上，有許多現成的工具，並且網路上也有許多例子可以做學習，我們不必花費太多時間在重造輪子上。 然而當系統成長時，管理的成本也逐漸提高。例如原先手動一次就可以完成的事項，在系統成長後需要做到 100 次，甚至 1000 次。或是團隊之間對服務的看法不同，這經常發生在開發團隊與管理團隊之間。這是會影響團隊之間是合作或是分裂的成本。 開發團隊想推出新功能，管理團隊想要穩定服務(誰知道你的新功能會不會出包) 安全性，可靠性，服務是否在這次更新後正常運作，有沒有 bug，會不會造成其他功能 crash ? 我自己的經驗真的是這樣，兩個團隊的目標不一樣，之前我在管理團隊中就是不太想去做 patch update，只希望服務能夠穩定提供，甚至是這台伺服器就都不要去動他。但在開發團隊時，又很想趕快做出新功能後，進行更新並提供給使用者做使用。(工讀時兩個團隊都待過。) 但不可能都不推出新功能阿，只是，為了服務的可靠性，管理團隊會使用許多方式來檢查、驗證或測試新的功能是否有問題，或是會造成其他問題的可能。 開發團隊也可以透過發布更少的 patch、flag flips、incremental updates 與 cherrypicks 來減緩或降低這些事情發生的次數。 Info 即使兩個團隊的價值觀不盡相同，但大家都是為了提供更好且穩定的服務，請盡量不要因為目標不同而真的吵起來… ","date":"2022-08-30","objectID":"/posts/infra/sre_1/:2:0","tags":["Infra","SRE"],"title":"Site Reliability Engineering - Introduction","uri":"/posts/infra/sre_1/"},{"categories":["SRE"],"content":"In Google 基本上在 Google 內部是透過軟體工程師建立系統來運行由系統管理員手動執行的工作。 這個 SRE 團隊一半是軟體工程師，一半是具備 SRE 技能的工程師，SRE技能基本上是 Linux internals 與 networking(TCP/IP)(但也會軟體工程)。 基本上是以軟體工程的方式，來處理系統管理的問題，盡可能的使用軟體設計實現自動化以降低手動執行的工作，甚至是獲得自動化的系統，這個系統能夠自動運行並自我修復。 限定 50% 的時間會用在管理，另外的時間會用於實際開發，一來是可以參與主要工程，了解這次的開發是為了甚麼，是如何運作的，有沒有能再更好的地方，當知道系統怎麼維運時，在進行開發上就會知道那些地方是要注意的，並且這些經驗可以與開發團隊分享，達到提升整體的技能之目的。 偷渡個 SRE 的技能書 (面試用書)，但請記得，軟體開發仍是最重要的技能。 Algorithms and data structures : Book: Cracking the Coding Interview, 6th Edition, ISBN 0984782869 (arrays, stacks, linked lists, binary trees, graphs, recursion) System design : Book: System Design Interview – An insider’s guide, 2nd Edition, ISBN 979-8664653403 Linux internals : Book: Advanced Programming in the UNIX Environment, 3rd Edition, ISBN 0321637739 TCP/IP : Book: TCP/IP Illustrated, Volume 1: The Protocols, ISBN 0321336313 ","date":"2022-08-30","objectID":"/posts/infra/sre_1/:3:0","tags":["Infra","SRE"],"title":"Site Reliability Engineering - Introduction","uri":"/posts/infra/sre_1/"},{"categories":["SRE"],"content":"SRE 宗旨 負責並專注在服務的可用性、延遲、性能、效率、變更管理、監控、緊急事項回應與容量規劃。 不僅僅是專注在系統服務環境，還包含開發團隊、測試團隊與使用者等。 ","date":"2022-08-30","objectID":"/posts/infra/sre_1/:4:0","tags":["Infra","SRE"],"title":"Site Reliability Engineering - Introduction","uri":"/posts/infra/sre_1/"},{"categories":["SRE"],"content":"參考資料 SRE-Books ","date":"2022-08-30","objectID":"/posts/infra/sre_1/:5:0","tags":["Infra","SRE"],"title":"Site Reliability Engineering - Introduction","uri":"/posts/infra/sre_1/"},{"categories":["TroubleShooting"],"content":"簡單提一下網路緩慢時的處理方式與工具。 ","date":"2022-07-28","objectID":"/posts/troubleshooting/tools_3/:0:0","tags":["Infra","Troubleshooting","debug","tools","mtr","tcpdump","iperf","wireshark"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--Slowly","uri":"/posts/troubleshooting/tools_3/"},{"categories":["TroubleShooting"],"content":"前言 自己在處理網路緩慢的問題經驗並不多，但基本上自己會先往幾個方向去思考問題點在哪： 高延遲（High Latency），想一想我們前面提到 3 way handshake 時，假設一來一往，每一個步驟都要花 1000ms，建立一個連線要 3 秒鐘，這樣當然會慢啦。 使用較小的 MSS，意味著在同樣的時間內所輸的資料較少，這樣也會感覺慢慢的。 太多人使用，壅塞了！ 其他我可能沒想到的原因。 因為緩慢可能會有很多原因，可以透過一些工具來幫助自己釐清這些問題。 以下會對這些工具做一些簡單的介紹。 mtr tcpdump, wireshark iperf ","date":"2022-07-28","objectID":"/posts/troubleshooting/tools_3/:1:0","tags":["Infra","Troubleshooting","debug","tools","mtr","tcpdump","iperf","wireshark"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--Slowly","uri":"/posts/troubleshooting/tools_3/"},{"categories":["TroubleShooting"],"content":"mtr mtr 就是把 traceroute(tracert) 跟 ping 組合起來，主要是用來觀察 latancy 或是 packet loss% 的工具。 其實就很像 traceroute，但 mtr 顯示的資訊更豐富，並會計算所有 hop 回應的百分比與回應時間。 $ mtr 8.8.8.8 那他會帶你進入一個介面做觀察，按 q 可以離開。 第一次看到 mtr 大概是這樣子\" 第一次看到 mtr 大概是這樣子 主要可以觀察到 packet 的遺失率，如果說有幾個不連續的幾個 node 掉了幾個封包，其實是不會造成太大的影響，但如果是某一個 node 後所有的 node 都有封包遺失，那一個 node 則會對整個傳輸造成影響，也就會讓使用者感受到緩慢，可以推測那個 node 上有問題。 另外可以觀察 icmp 封包的傳輸延遲，雖然 traceroute 也做得到，但 mtr 他提供的資訊比較多啦。 Last : 最後一次的延遲數值 Avg : 平均的延遲數值 Best : 最佳的延遲數值（最短） Wrst : 最糟的延遲數值（最長） StDev : 標準偏差（Standard Deviation），愈大代表這個 node 愈不穩定。 以上圖的例子來說，第二個點的延遲就有點糟且不太穩定。 另外可以加入一些參數做不同的使用： ## -n 可以強制以 IP address 顯示所有 node $ mtr -n 8.8.8.8 前面我們提到 tcptraceroute，那在 mtr 上可以使用 tcp 或 udp 嗎？ 可以的 !! 有時候也需要觀察 tcp 或 udp 資料在這段網路上的傳輸品質。 $ mtr --tcp 8.8.8.8 $ mtr --udp 8.8.8.8 我想改變封包的 size 可以嗎？ -s 會幫助你！ 可以透過更改封包的大小來觀察網路使用狀況。 $ mtr -s [PACKETSIZE] 8.8.8.8 最後，可以透過 -r 這個參數做紀錄。 ### 預設會送 10 次做觀察。 $ mtr -r 8.8.8.8 \u003e [filename] ### 透過 -c 調整次數，這樣他就會送 100 次。 $ mtr -r -c 100 8.8.8.8 \u003e [filename] ### 這樣他就會在背景送 1000 次，然後你可以去喝咖啡。 $ mtr -r -c 1000 8.8.8.8 \u003e [filename] \u0026 ","date":"2022-07-28","objectID":"/posts/troubleshooting/tools_3/:2:0","tags":["Infra","Troubleshooting","debug","tools","mtr","tcpdump","iperf","wireshark"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--Slowly","uri":"/posts/troubleshooting/tools_3/"},{"categories":["TroubleShooting"],"content":"tcpdump, Wireshark tcpdump 是一個功能強大的，而且也是使用最廣泛的 sniffer 與分析工具，用來捕捉或過濾在特定介面上接收或傳輸的 TCP/IP packet。 基本上在多數的環境中都可以使用，並且可以將捕捉的結果儲存為 .pcap 格式，可以透過 Wireshark 做更進一步的分析。 坦白說，tcpdump 也是會在網路無法連線時使用到，像是 ssl 無法建立，或是 VLAN tag 設定錯之類的情形，我會把它放在這是因為，我自己在看 MSS 時會用到。MMS 的大小會影響傳輸效能。或觀察封包的往來時間。 Wireshark 也具有相同的功能，並提供圖形化介面做更容易的使用。 這邊只會介紹 tcpdump，基本上，環境預設是不會有這個工具，所以我們要先自行安裝。 # macOS(OSX) $ brew install tcpdump # Debian, Ubuntu $ sudo apt-get install tcpdump 首先，我們可以選擇指定的介面捕捉封包。透過 -i 這個參數可以指定介面。 $ tcpdump -i eth0 16:59:22.920016 IP 172.20.10.4.50011 \u003e a104-115-254-134.deploy.static.akamaitechnologies.com.https: Flags [.], ack 213539838, win 2048, length 0 16:59:22.920017 IP 172.20.10.4.50007 \u003e a173-222-181-125.deploy.static.akamaitechnologies.com.https: Flags [.], ack 2165220779, win 2048, length 0 16:59:22.920017 IP 172.20.10.4.50003 \u003e 137.155.120.34.bc.googleusercontent.com.https: Flags [.], ack 281486443, win 2048, length 0 那我們要如何知道，有哪些介面可以監聽呢？ifconfig tcpdump 提供 -D 這個參數，讓我們可以知道可以使用哪些介面。 $ tcpdump -D 1.en0 [Up, Running, Wireless, Associated] 2.p2p0 [Up, Running, Wireless, Not associated] 3.awdl0 [Up, Running, Wireless, Associated] 4.llw0 [Up, Running, Wireless, Associated] 5.utun0 [Up, Running] 6.utun1 [Up, Running] 7.lo0 [Up, Running, Loopback] 8.en1 [Up, Running, Disconnected] 9.en2 [Up, Running, Disconnected] 10.gif0 [none] 11.stf0 [none] 12.XHC20 [none] 13.bridge0 [none, Disconnected] 14.en4 [none, Disconnected] 並可以透過 -n 再進一步，只捕獲這個介面上 IP 的封包。 $ tcpdump -n -i en0 另外還可以透過 -XX 這個參數，顯示封包的數據內容，並以 HEX 與 ASCII 格式顯示。 $ tcpdump -XX -i en0 17:04:15.996062 IP6 2001-b400-e35d-11b9-e87c-0c6e-2d6e-27bf.emome-ip6.hinet.net.50145 \u003e 2403:300:a41:b02::7.https: Flags [P.], seq 3353679317:3353679348, ack 252170061, win 2048, options [nop,nop,TS val 2584095760 ecr 718123086], length 31 0x0000: feaa 8116 f864 80e6 501d eed8 86dd 602b .....d..P.....`+ 0x0010: 0700 003f 0640 2001 b400 e35d 11b9 e87c ...?.@.....]...| 0x0020: 0c6e 2d6e 27bf 2403 0300 0a41 0b02 0000 .n-n'.$....A.... 0x0030: 0000 0000 0007 c3e1 01bb c7e5 15d5 0f07 ................ 0x0040: cf4d 8018 0800 0bba 0000 0101 080a 9a06 .M.............. 0x0050: 2c10 2acd b04e 1503 0300 1a00 0000 0000 ,.*..N.......... 0x0060: 0000 022b 2353 39dc 701e eb0a d4f2 219e ...+#S9.p.....!. 0x0070: 6eca 679d 37 n.g.7 前面提到，可以將這些紀錄儲存為 .pcap 格式，只需要透過 -w 即可使用。 $ tcpdump -w myFileName.pcap -i en0 既然可以寫入，那應該也可以讀取吧？ 沒錯，透過 -r 這個參數可以讀取 .pcap 檔案。 $ tcpdump -r myFileName.pcap 接下來是一些更細部的參數，可以讓我們根據情境做調整： # 只抓 TCP $ tcpdump -i en0 tcp # 只抓某個 port number $ tcpdump -i en0 port 22 # 只抓來源 IP 為 8.8.8.8 的 $ tcpdump -i en0 src 8.8.8.8 # 只抓目的 IP 為 168.95.1.1 的 $ tcpdump -i en0 src 168.95.1.1 因為這篇文章，主要是工具的使用，更細一步的分析，往後有時間會再撰寫吧。 ","date":"2022-07-28","objectID":"/posts/troubleshooting/tools_3/:3:0","tags":["Infra","Troubleshooting","debug","tools","mtr","tcpdump","iperf","wireshark"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--Slowly","uri":"/posts/troubleshooting/tools_3/"},{"categories":["TroubleShooting"],"content":"iperf iperf 是一種測量網路上最大頻寬的工具，可以調整 timing, buffer 與 protocol(TCP, UDP, ICMP …)，並產生頻寬與損耗等相關報告。 一般來說，使用 iperf 要有兩個端點(node)，透過兩個端點進行測量。(Server, Client) # Server $ iperf3 -s # Client $ iperf3 -c [Server IP address] 可…可是我只有一台電腦，那也可以透過公開的 iperf server 做測試。連結 不過我自己用了幾個，都是在忙碌中… 比較常用的參數有 -p, -u 與 -t 等。 $ iperf -p 8888 -c [server] # 改 port number $ iperf -u 8888 -c [server] # 改用 UDP，預設是 TCP $ iperf -t 60 -c [server] # 更改傳輸的總時間 但這個工具我會建議用在做單個點的驗證，因為多個點時，使用 iperf 只會容易知道整體鏈路情況，但實際哪個點或哪幾個點有問題，可能還是要用 mtr 或類似的工具做補助。 ","date":"2022-07-28","objectID":"/posts/troubleshooting/tools_3/:4:0","tags":["Infra","Troubleshooting","debug","tools","mtr","tcpdump","iperf","wireshark"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--Slowly","uri":"/posts/troubleshooting/tools_3/"},{"categories":["TroubleShooting"],"content":"參考資料 mtr tcpdump wireshark iperf 各個工具的 -h, --help 指令，man 的說明。 ","date":"2022-07-28","objectID":"/posts/troubleshooting/tools_3/:5:0","tags":["Infra","Troubleshooting","debug","tools","mtr","tcpdump","iperf","wireshark"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--Slowly","uri":"/posts/troubleshooting/tools_3/"},{"categories":["TroubleShooting"],"content":"這篇會簡單提一下自己在網路正常卻無法存取服務時，自己會使用的工具與使用方式。 ","date":"2022-06-17","objectID":"/posts/troubleshooting/tools_2/:0:0","tags":["Infra","Troubleshooting","debug","tools","netstat","nmap","nc"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/troubleshooting/tools_2/"},{"categories":["TroubleShooting"],"content":"前言 上一篇文章基本上是自己在找網路中斷的問題時會用到的工具，但許多時候網路是正常的，問題點則是在伺服器或服務上。 我通常會看服務是否有啟用，並根據相對應的服務做後續的處理，下面是我在這種情境中，我經常用到的工具。 netstat(ss) nmap nc ","date":"2022-06-17","objectID":"/posts/troubleshooting/tools_2/:1:0","tags":["Infra","Troubleshooting","debug","tools","netstat","nmap","nc"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/troubleshooting/tools_2/"},{"categories":["TroubleShooting"],"content":"netstat 基本上許多作業系統都已預設安裝 netstat 這個工具，用來顯示目前網路連結的狀態 (connetion)。 -s : 會顯示統計數據。可以在後面加上 t(tcp)或是u(udp) 對於協定做進一步的查詢。 $ netstat -st IcmpMsg: InType0: 33 InType11: 319 OutType3: 7 OutType8: 352 Tcp: 50 active connection openings 14 passive connection openings 0 failed connection attempts 1 connection resets received 19 connections established 7193 segments received 7100 segments sent out 0 segments retransmitted 0 bad segments received 2 resets sent UdpLite: TcpExt: 39 TCP sockets finished time wait in fast timer 31 delayed acks sent 1818 packet headers predicted 2219 acknowledgments not containing data payload received 1497 predicted acknowledgments TCPBacklogCoalesce: 11 TCPRcvCoalesce: 293 TCPAutoCorking: 28 TCPOrigDataSent: 1900 TCPKeepAlive: 1830 TCPDelivered: 1950 IpExt: InOctets: 1865047 OutOctets: 207989 InNoECTPkts: 2521 -r : 可以顯示目前的路由表(routing table)。也可以透過 route 指令去顯示。(依據作業系統可能會是 route PRINT 或 route -n) $ netstat -r Kernel IP routing table Destination Gateway Genmask Flags MSS Window irtt Iface default 10.0.2.2 0.0.0.0 UG 0 0 0 enp0s3 10.0.2.0 0.0.0.0 255.255.255.0 U 0 0 0 enp0s3 -p : 可以觀察到是哪個 process 在存取。在 Windows 上的會是選擇觀察哪種協定(TCP, UDP)。 netstat 還有許多參數可以使用，請依據自己遇到的情境挑選適合的參數。 ","date":"2022-06-17","objectID":"/posts/troubleshooting/tools_2/:2:0","tags":["Infra","Troubleshooting","debug","tools","netstat","nmap","nc"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/troubleshooting/tools_2/"},{"categories":["TroubleShooting"],"content":"ss 基本上他就是 netstat 的加強版，基本上參數的使用也跟 netstat 差不多，個人覺得 ss 比較好用，看起來比較舒服一點，但 netstat 通常會是預設安裝，而 ss 則不是。 ss 目前在 iproute2 中，要使用請安裝 iproute2 : $ sudo apt-get install iproute2 ","date":"2022-06-17","objectID":"/posts/troubleshooting/tools_2/:2:1","tags":["Infra","Troubleshooting","debug","tools","netstat","nmap","nc"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/troubleshooting/tools_2/"},{"categories":["TroubleShooting"],"content":"TCP states 請你暫時忍耐一下，關閉夜間模式 ! 如同聖經般的 TCP 狀態圖。\" 如同聖經般的 TCP 狀態圖。 之所以會放這張圖是因為，有時候是 Service 在設計上時有問題，又或者是遇到服務被攻擊而造成的 breakdown，此時可以透過狀態來分析並進行後一步的處理。 好比說我在 Server 上看到許多 SYN_RECV 狀態，可能代表在 3-way handshake 上遇到問題，Server 收到了 Client 發送的 SYN packet，於是 Server 的狀態為 SYN_RECV 並回傳一個 SYN+ACK 的封包並等待對方回傳 ACK，然而一直沒收到就保持在這個狀態許久。 通常遇到這種情形，可以先懷疑是 TCP SYN FLOOD 攻擊。 ","date":"2022-06-17","objectID":"/posts/troubleshooting/tools_2/:2:2","tags":["Infra","Troubleshooting","debug","tools","netstat","nmap","nc"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/troubleshooting/tools_2/"},{"categories":["TroubleShooting"],"content":"nmap 坦白說他是掃描 port 的工具，是自己以前在接觸 cyber security 時所學到的。 我會提到 nmap 是因為他可以讓我快速知道遠端機器是否存活，服務是否有掛上。 除此之外，nmap 也很常使用在網路安全上，並可以透過 script 和微調設定，掃瞄系統並檢查常見的漏洞，或是找到在常用的伺服器上具有的致命設定。(Web, Database and Mail … etc) 有點扯太遠了，我還是拿來看 port 有沒有開即可 … Warning 請不要對某個特定目標用 nmap 執行大量的 scan，你有可能因此被 block。 # 最常使用的 scan command. $ nmap -sS example.com # UDP Scan $ nmap -sU example.com # 針對某幾個 port number 做 Scan $ nmap -sS -p 80,443 8.8.8.8 Starting Nmap 7.80 ( https://nmap.org ) at 2022-06-16 19:34 HST Nmap scan report for dns.google (8.8.8.8) Host is up (0.0014s latency). PORT STATE SERVICE 80/tcp filtered http 443/tcp open https Nmap done: 1 IP address (1 host up) scanned in 1.23 seconds ","date":"2022-06-17","objectID":"/posts/troubleshooting/tools_2/:3:0","tags":["Infra","Troubleshooting","debug","tools","netstat","nmap","nc"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/troubleshooting/tools_2/"},{"categories":["TroubleShooting"],"content":"nc (netcat) 一個很強但我不太會用的工具。(功能太多) 會簡單提一下我比較常用的功能: 確認 Port 是否有開啟： $ nc -v example.com 80 Warning: inverse host lookup failed for 93.184.216.34: Unknown host example.com [93.184.216.34] 80 (http) open 如果沒有開啟則會得到這個結果： $ nc -v example.com 2022 nc: connect to 192.168.233.208 2022 (tcp) failed: Connection refused ### 也有可能像到進黑洞，下完指令後就卡在那邊\u003e\u003c ### 這時要看你的目標的防火牆或是相關的規則，進而導致有不同的結果。 也因此 nc 可以用來做 port scanning ! 不過這不代表可以取代 nmap，我覺得工具各有優缺點，像我做 scanning 應該還是會用 nmap。 Warning 再一次提醒，請不要對某個特定目標執行大量的 scan，你有可能被 block。 # nc -vnz [parameter] [Target IP address] [port range] # e.g. $ nc -vz -w 1 8.8.8.8 2000-3000 ## -w 是 timeout。 ## 這樣會是測 TCP 的，如果想要測 UDP ，就給他個 U 吧 !! # e.g. $ nc -vzu 8.8.8.8 2000-3000 如果你能同時控制兩台電腦，nc 也很常被用來傳輸檔案， 這邊要注意一下優先順序， Receiver 要先開啟後再由 Transmitter 傳輸。 (冰箱沒有打開，要怎麼把大象放進去???) ## Receiver $ nc -l -p 3333 \u003e name.file ## Transmitter $ nc [receiver IP address] 3333 \u003c name.file 自己比較常常用來把系統的日誌檔扔到自己的電腦，做一些分析~~(抱歉我的 grep, awk, sed 沒學好)~~ 或許用 scp 與其他的 command 會比較快一點，但多學一個方式也不是壞處。 可以偷偷把 Linux 上的 shadow 跟 passwd 拿出去然後做一些壞壞的事情(? 也可以連線到服務，做簡單的測試： $ nc example.com 80 GET / HTTP/1.1 # 這一行是要自己 key in 的。 # 但如果要測網頁，我會建議你用 curl, wget 或是我們常用的 browser 會比較快速也比較方便一點。 ","date":"2022-06-17","objectID":"/posts/troubleshooting/tools_2/:4:0","tags":["Infra","Troubleshooting","debug","tools","netstat","nmap","nc"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/troubleshooting/tools_2/"},{"categories":["TroubleShooting"],"content":"小結論 在確定網路正常，但使用者仍無法連線至服務的情況下，我會使用上述的工具，快速檢查伺服器端的上的 service port 是否正常開啟，若不是正常開啟，又會是甚麼原因造成的。 並根據不同的服務，進一步使用不同的工具來做故障排除。 像是 DNS 就再用 dig 看一下紀錄是否正常，Web 就用 curl, wget 等。 當然，還有很多原因會造成網路正常但服務無法存取，至少希望能透過這些工具進一步的判斷故障點在何處，或是大概的範圍。 最後，nmap 與 netcat(nc)都是很有力的工具，甚至可以單獨為一本書，在參考資料我會提到相關書籍可以參考。 ","date":"2022-06-17","objectID":"/posts/troubleshooting/tools_2/:5:0","tags":["Infra","Troubleshooting","debug","tools","netstat","nmap","nc"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/troubleshooting/tools_2/"},{"categories":["TroubleShooting"],"content":"參考資料 Windows-commands: netstat manpages-ss, Debian testing Nmap Network Exploration and Security Auditing Cookbook Netcat Power Tools ","date":"2022-06-17","objectID":"/posts/troubleshooting/tools_2/:6:0","tags":["Infra","Troubleshooting","debug","tools","netstat","nmap","nc"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--服務中斷","uri":"/posts/troubleshooting/tools_2/"},{"categories":["TroubleShooting"],"content":"基本上分享自己在進行網路中斷的故障排除時，經常使用到的工具與使用方式。 ","date":"2022-06-11","objectID":"/posts/troubleshooting/tools_1/:0:0","tags":["Infra","Troubleshooting","debug","tools"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/troubleshooting/tools_1/"},{"categories":["TroubleShooting"],"content":"前言 在網路中斷或是緩慢時，總需要有人去處理，緩慢還可以用 Google 大法協助，不過個人認為緩慢比中斷還要難排除。 這篇會先單純以網路斷線為主題撰寫，分享幾個自己常用的工具。 (只要修好網路斷線，剩下的問題就拿去問 Google !!!) ifconfig, ipconfig, ip addr ping traceroute(tracert), tcptraceroute dig, nslookup mtr netstat nmap nc curl, wget tcpdump, wireshark 這邊基本上會先說明一些工具，來驗證兩地之間的網路是正常連線，還沒考慮到應用層與緩慢的問題。 關於應用層與緩慢的問題，會在後續的文章中加以說明。 ","date":"2022-06-11","objectID":"/posts/troubleshooting/tools_1/:1:0","tags":["Infra","Troubleshooting","debug","tools"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/troubleshooting/tools_1/"},{"categories":["TroubleShooting"],"content":"ifconfig (ip addr, ipconfig on Windows) 我一直以來都是喜歡用 ifconfig ，或是在 Windows 上使用 ipconfig，因為這兩個指令相近，自然而然就會在 Windows 上使用 ifconfig （不要笑） 後來 Debian 改版之後，不再預安裝 net-tools，所以改用 ip addr 這個指令。 Windows 上的 ipconfig 會建議再加上 -all 一次獲得更多資訊。 基本上這些指令都可以看網路卡的 IP 資訊，有時是 DHCP Server 故障沒有取到 IP address，或是 IP address 設錯等問題，改一下就排除了。 ","date":"2022-06-11","objectID":"/posts/troubleshooting/tools_1/:2:0","tags":["Infra","Troubleshooting","debug","tools"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/troubleshooting/tools_1/"},{"categories":["TroubleShooting"],"content":"ping ping 應該是最常被用到的工具之一，我相信很多人做過這件事： $ ping 8.8.8.8 如果我們的 DNS 正常，也可以透過 FQDN 進行： $ ping aws.amazon.com PING dr49lng3n1n2s.cloudfront.net (143.204.75.75): 56 data bytes 64 bytes from 143.204.75.75: icmp_seq=0 ttl=233 time=49.306 ms 64 bytes from 143.204.75.75: icmp_seq=1 ttl=233 time=561.229 ms 64 bytes from 143.204.75.75: icmp_seq=2 ttl=233 time=53.671 ms 64 bytes from 143.204.75.75: icmp_seq=3 ttl=233 time=68.874 ms 64 bytes from 143.204.75.75: icmp_seq=4 ttl=233 time=49.972 ms 至於為什麼變成是 PING dr49lng3n1n2s.cloudfront.net 呢，CNAME什麼的下回解析 我自己比較加上的參數應該是 -c or -m，畢竟使用 ping 通常只是用來驗證網路是否有連線而已。 $ ping -c 10 1.1.1.1 # 對 1.1.1.1 進行 10 次 icmp 封包的傳送並等待回覆。 $ ping -m 10 1.1.1.1 # 將 ttl 改為 10 後進行 10 次 icmp 封包的傳送並等待回覆。 我自己是用 ping 的法則大概是這樣的順序，基本上就是由 Client 慢慢到 Server： ping localhost ping [host IP address] ping [Gateway IP address] ping [Server IP Address] 但沒有一定的方法，我覺得依據個人喜歡的方式使用即可，畢竟我們的目標是故障排除而不是在那邊計較先後順序。 ","date":"2022-06-11","objectID":"/posts/troubleshooting/tools_1/:3:0","tags":["Infra","Troubleshooting","debug","tools"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/troubleshooting/tools_1/"},{"categories":["TroubleShooting"],"content":"traceroute (tracert on Windows) 透過更改 ttl 的方式，去 trace 網路路徑的工具，可以讓我們較容易知道網路到哪個 node 時出問題： $ traceroute 8.8.8.8 traceroute to 8.8.8.8 (8.8.8.8), 64 hops max, 52 byte packets 1 172.20.10.1 (172.20.10.1) 1.182 ms 0.606 ms 0.580 ms 2 * * * 3 * * * 4 * * * 5 tpdb-3312.hinet.net (210.65.126.98) 38.918 ms 19.277 ms 25.854 ms 6 tpdb-3031.hinet.net (220.128.1.254) 25.584 ms tpdb-3031.hinet.net (220.128.1.114) 17.709 ms tpdb-3031.hinet.net (220.128.1.254) 23.210 ms 7 220-128-9-121.hinet-ip.hinet.net (220.128.9.121) 21.327 ms * 57.736 ms 8 tpdt-3302.hinet.net (220.128.12.61) 29.946 ms pcpd-4102.hinet.net (220.128.13.109) 28.238 ms 220-128-13-169.hinet-ip.hinet.net (220.128.13.169) 20.401 ms 9 72.14.202.178 (72.14.202.178) 19.526 ms 72.14.209.178 (72.14.209.178) 34.970 ms 142.250.169.122 (142.250.169.122) 26.003 ms 10 * * * 11 dns.google (8.8.8.8) 24.621 ms 19.687 ms 209.85.245.64 (209.85.245.64) 21.766 ms ","date":"2022-06-11","objectID":"/posts/troubleshooting/tools_1/:4:0","tags":["Infra","Troubleshooting","debug","tools"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/troubleshooting/tools_1/"},{"categories":["TroubleShooting"],"content":"tcptraceroute 相較於 traceroute 使用 icmp，這是使用 tcp 去進行 trace 的工具。 因為在現代網路上，防火牆通常會阻擋 icmp 的封包進入， 然而我們在瀏覽網頁或是發送信件時，防火牆大都會讓 tcp 封包進入，為了進行 3-way handshake 進行後續的連線建立，client 首先會發送 SYN 封包。 而 tcptraceroute 就是透過這個 TCP-SYN 封包進行 trace 而實現。讓你可以做更深入的測試? 通常你的電腦內不會有這個工具，必須自己去下載安裝。 使用方式也很簡單，基本上怎麼用 traceroute 就怎麼使用 tcptraceroute。 比較常用的方式是在加上 port number ，針對你遇到的問題，或是你想針對特定的某個服務，去進行 trace。 \u0026 sudo traceroute -p 443 example.com Note 可以自己找個目標，嘗試並比較 traceroute 與 tcptraceroute 的差異。 ","date":"2022-06-11","objectID":"/posts/troubleshooting/tools_1/:4:1","tags":["Infra","Troubleshooting","debug","tools"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/troubleshooting/tools_1/"},{"categories":["TroubleShooting"],"content":"dig (nslookup) 這邊會提到 dig 是因為有時候是 DNS 紀錄錯誤，導致 host 一直連到別的 IP address，當然就無法連線囉！！ 基本上我在網路連線中斷排除時，會用這個單純看目標 IP address 看是否正確而已。 其實兩個工具很類似，但我認為 dig 給的資訊量較大，也有較多的功能可以使用，所以這邊只會講 dig。 dig 也不是預先安裝的工具，那要怎麼用？？ (安裝啊) ### macOS $ brew install bind ### Debian (你可能會遇到更新與權限問題) $ apt install dnsutils 裝好了我們就趕快測試一下！！ $ dig example.com ; \u003c\u003c\u003e\u003e DiG 9.10.6 \u003c\u003c\u003e\u003e example.com ;; global options: +cmd ;; Got answer: ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: NOERROR, id: 41551 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: ;example.com. IN A ;; ANSWER SECTION: example.com. 4502 IN A 93.184.216.34 ;; Query time: 20 msec ;; SERVER: 172.20.10.1#53(172.20.10.1) ;; WHEN: Sun Jun 12 21:38:04 CST 2022 ;; MSG SIZE rcvd: 56 我們可以透過 @ 來指定某台 DNS server 做查詢。 $ dig example.com @168.95.1.1 或是指令紀錄的種類去查詢： $ dig gmail.com MX Note 試試看吧！ $ dig example.com +trace ","date":"2022-06-11","objectID":"/posts/troubleshooting/tools_1/:5:0","tags":["Infra","Troubleshooting","debug","tools"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/troubleshooting/tools_1/"},{"categories":["TroubleShooting"],"content":"小結論 這篇的工具大部分是我用來驗證，我的 host 是否能到達我想去的目標。 當我們可以到達目標時，問題大多數會是在 Application Layer 或是 Transport layer 上。 此時就會使用別的工具去做故障排除了。 ","date":"2022-06-11","objectID":"/posts/troubleshooting/tools_1/:6:0","tags":["Infra","Troubleshooting","debug","tools"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/troubleshooting/tools_1/"},{"categories":["TroubleShooting"],"content":"參考資料 tcptraceroute Dig Command in Linux (DNS Lookup) ","date":"2022-06-11","objectID":"/posts/troubleshooting/tools_1/:7:0","tags":["Infra","Troubleshooting","debug","tools"],"title":"【TroubleShooting】故障排除的工具介紹與使用方式--網路中斷","uri":"/posts/troubleshooting/tools_1/"},{"categories":["Infra"],"content":"本篇文章會簡單介紹 ansible 在做什麼與他的優勢，並介紹安裝方式與環境架設。 ","date":"2022-04-19","objectID":"/posts/ansible/01_introduction/:0:0","tags":["Ansible","Infra"],"title":"Ansible - Intro","uri":"/posts/ansible/01_introduction/"},{"categories":["Infra"],"content":"前言 基本上會看 ansible 是因為以前接觸過，但沒有深入去研究，不過 ansible 仍然為自己想學習的技能之一，故這次想透過這本書做進一步的學習。 這系列的文章應該會更新的很慢，因為手邊還有一些事情要處理，並不像之前更新 Go 系列，有較頻繁的更新頻率。 （ 而且 Go 系列到後面都在亂寫…） 基本上因為雲的高擴展性與容易性（相較容易使用），許多服務逐漸放上雲去運作，包含常見的 Web server、應用程式伺服器與資料庫等，基本上 IT 人員要負責這些服務的運作，監控與紀錄並進一步分析，甚至要安排冗餘，使得故障時，服務能不受大影響。 為了維護這些服務，可以手動處理，但手動設定這些服務非常耗時，而且容易出錯，同樣的事情可能做個三次四次就會覺得煩躁，如果遇到困難的任務或是設定，可能還沒弄好，心情先差到極點。 透過 ansible，我們可以降低配置服務時的時間，降低出錯的機率，並且這是自動化的，只要一開始願意花時間配置 ansible，後面就會多一些時間喝咖啡（但不要灑出來） Note 我們要效能。 看看就好\" 看看就好 ","date":"2022-04-19","objectID":"/posts/ansible/01_introduction/:1:0","tags":["Ansible","Infra"],"title":"Ansible - Intro","uri":"/posts/ansible/01_introduction/"},{"categories":["Infra"],"content":"簡介 Ansible 通常被稱為 配置管理工具 (configuration management tool)，通常在談論配置管理時，代表我們會替伺服器編寫特定的狀態描述，並以工具使伺服器確實處在該狀態。 Ansible 也能幫助我們進行部署的工作，像是開發時產生的編譯檔，將這個編譯檔部署至伺服器上並運行。 另外也經常用來配置新的伺服器，簡單來說我需要一台安裝好 python 並且已經設定好 vim 參數的虛擬機，可以透過 ansible 協助我們產生這樣的虛擬機。另外也可以配置關於雲的服務等（包括 EC2、Azure、Digital Ocean、Google Compute Engine、Linode 和 Rackspace，以及任何支持 OpenStack API 的雲。） ","date":"2022-04-19","objectID":"/posts/ansible/01_introduction/:2:0","tags":["Ansible","Infra"],"title":"Ansible - Intro","uri":"/posts/ansible/01_introduction/"},{"categories":["Infra"],"content":"工作原理 舉個例子： 有個使用者需要透過 ansible，在三台 Ubuntu 上安裝 nginx，三台分別稱為 web1, web2 與 web3，使用者編寫了一個名為 webservers.yml 的 Ansible 腳本。在 Ansible 中，腳本稱為 playbook。playbook 描述了要配置的主機（Ansible 稱之為遠端伺服器），以及要在這些主機上執行的任務的有序列表。 webservers.yml 的內容會在後面提到，這邊只是單純說明原理。使用者寫好 webservers.yml 後會透過 ansible-playbook 運行 playbook： $ ansible-playbook webservers.yml 基本上任務會像這樣： - name:Install nginxpackage:name:nginxAnsible 將執行以下操作： 生成安裝 Nginx package 的 Python 腳本 將腳本複製到 web1、web2 和 web3 在 web1、web2 和 web3 上執行腳本 等待腳本在所有主機上完成執行 Tips 注意以下幾點： Ansible 在所有主機上並行運行每個任務。 Ansible 會等到所有主機都完成一個任務，然後再移動到下一個任務。 Ansible 按照您指定的順序運行任務。 ","date":"2022-04-19","objectID":"/posts/ansible/01_introduction/:3:0","tags":["Ansible","Infra"],"title":"Ansible - Intro","uri":"/posts/ansible/01_introduction/"},{"categories":["Infra"],"content":"優勢 相較於其他配置管理工具， ansible 學習起來較容易些。 ansible 使用 yaml 與 Jinja2 模板，兩者都很容易上手。 yaml 我在使用 github actions 就有經驗了，非常的直觀。 可以透過多種方式檢查 ansible playbook，例如列出所有涉及操作的主機。如果要測試 playbook，可以使用 ansible-playbook --check 來測試，並且有 log 可以觀察誰在哪裡做了什麼。 遠端伺服器也不需要預先安裝許多服務，在 Linux 上只需要安裝 SSH 與 python，而在 Windows 上需要啟用 WinRM。 可以在 Raspberry Pi 或是舊電腦上運作，不需要很好的硬體資源。 有社群可以分享自己的 playbook ，或是參考別人的 playbook。 使用抽象的方式運作： e.g. 使用 shell 建立目錄並設定權限： mkdir -p /etc/skel/.ssh chown root:root /etc/skel/.ssh chmod go-wrx /etc/skel/.ssh 透過 ansible 運作： - name:Create .ssh directory in user skeletonfile:path:/etc/skel/.sshmode:0700owner:rootgroup:rootstate:directory","date":"2022-04-19","objectID":"/posts/ansible/01_introduction/:4:0","tags":["Ansible","Infra"],"title":"Ansible - Intro","uri":"/posts/ansible/01_introduction/"},{"categories":["Infra"],"content":"需要的基本技能 基本上要熟悉至少一種 Linux ，像是 Ubuntu, CentOS 等，並了解以下技能或資訊： 使用 SSH 連接到遠端設備 Bash ,shell 交互（pipes and redirection） 安裝 package sudo 檢查和設置文件權限 啟動和停止服務(service) 設置環境變數(env) 編寫 script ","date":"2022-04-19","objectID":"/posts/ansible/01_introduction/:5:0","tags":["Ansible","Infra"],"title":"Ansible - Intro","uri":"/posts/ansible/01_introduction/"},{"categories":["Infra"],"content":"安裝 基本上安裝相當簡單： ## macOS $ brew install ansible 或是使用 pip 進行安裝： ## Unix/Linux/macOS $ python -m pip install --user ansible 雖然 ansible 可以管理 windows，但不能在 windows 上運行 ansible。 ","date":"2022-04-19","objectID":"/posts/ansible/01_introduction/:6:0","tags":["Ansible","Infra"],"title":"Ansible - Intro","uri":"/posts/ansible/01_introduction/"},{"categories":["Infra"],"content":"inventory 基本上我們會建立一個 inventory 目錄來存放遠端設備的相關資訊。 並依據不同的設備名稱，儲存不同的資訊： ### inventory/webserver.ini [webservers] testserver ansible_port=2222 [webservers:vars] ansible_host = 192.168.0.1 ansible_user = user ansible_private_key_file = /path/of/private_key Note ansible 支援 ssh-agent，所以我們不需要明確指定密鑰。 接著我們就可以進行測試，像是連結到遠端伺服器並使用 ping： $ ansible testserver -i inventory/vagrant.ini -m ping ","date":"2022-04-19","objectID":"/posts/ansible/01_introduction/:7:0","tags":["Ansible","Infra"],"title":"Ansible - Intro","uri":"/posts/ansible/01_introduction/"},{"categories":["Infra"],"content":"ansible.cfg 然而在上一節最後的部分，那個指令還是太長了，我們還是要記一些參數才能使用。 透過預先設定好的 ansible.cfg，我們在往後使用時可以更加快速。 ansible.cfg 通常會建議與 playbook 放在一起，這樣做版本控制時較好管理。 [defaults] inventory = inventory/webserver.ini host_key_checking = False stdout_callback = yaml callback_enabled = timer 接著我們就可以用這個方式連結到遠端伺服器並使用 ping： $ ansible testserver -m ping ","date":"2022-04-19","objectID":"/posts/ansible/01_introduction/:8:0","tags":["Ansible","Infra"],"title":"Ansible - Intro","uri":"/posts/ansible/01_introduction/"},{"categories":["Infra"],"content":"一些參數 透過 command，我們可以在遠端設備上執行指令： ### 這樣遠端設備上會執行 uptime $ ansible testserver -m command -a uptime 如果說我們的指令有空格，請使用雙引號傳送整個字串： $ ansible testserver -m command -a \"tail /var/log/syslog\" 如果說這個指令需要 root 權限，請加上 -b $ ansible testserver -m command -b -a \"tail /var/log/syslog\" ","date":"2022-04-19","objectID":"/posts/ansible/01_introduction/:9:0","tags":["Ansible","Infra"],"title":"Ansible - Intro","uri":"/posts/ansible/01_introduction/"},{"categories":["Infra"],"content":"小結論 基本上介紹了 Ansible 的基本概念，包括它如何與遠端設備連線以及它與其他配置管理工具的不同之處。 剛開始都先確保環境沒問題之後，進行 1 對 1 的連線測試，完成後再進行後續的學習。 ","date":"2022-04-19","objectID":"/posts/ansible/01_introduction/:10:0","tags":["Ansible","Infra"],"title":"Ansible - Intro","uri":"/posts/ansible/01_introduction/"},{"categories":["Infra"],"content":"參考資料 Ansible: Up and Running: Automating Configuration Management and Deployment the Easy Way (3rd edition) ","date":"2022-04-19","objectID":"/posts/ansible/01_introduction/:11:0","tags":["Ansible","Infra"],"title":"Ansible - Intro","uri":"/posts/ansible/01_introduction/"},{"categories":["Infra"],"content":"簡單介紹 Github Actions，因為有人看了星期一就憂鬱那篇文章而詢問 Github Actions 的使用，故想說透過這次機會簡單介紹下。 ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:0:0","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"簡介 Github Actions 可以用來自動化、自定義和執行您的軟體開發工作流程。 許多人用來做 CI/CD 使用，透過 Github Actions 進行程式的建構與測試，並進行相關的部署。 在 Github 上，可以透過 push, create issue 或是排程的方式啟動 workflow。 並提供了多種 Runner，依據不同的需求使用不同的 Runner，能夠輕易的在不同的平台上做測試或是建構。 使用上也可以透過 log 觀察運作的情形並進行修改；且提供了 secret 的功能，讓一些需要 token 或是 key 的應用能夠安全的運作。 Github Actions 也有相關的社群，且能夠透過 Marketplace 取得其他開發者設計完成的 Actions，或者是發布自己的 Actions。 簡單來說，Github 給你一個平台，你可以在上面進行 CI/CD。 Warning Github Actions 有使用時間與容量限制，使用上請注意。(Billing for Github Actions) ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:1:0","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"基本使用 ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:2:0","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"建立 workflow 基本上點選專案上方的 Actions，會進入到這個畫面： 修改前的檔案\" 修改前的檔案 Github 會推薦給您一些 Actions，如果有需要的人可以點選做使用，就不必再重造一次輪子，但這次是要做個簡單介紹與使用，這邊我們點選上方的 set up a workflow yourself。會提供一個範例檔案： # This is a basic workflow to help you get started with Actionsname:CI# Controls when the workflow will runon:# Triggers the workflow on push or pull request events but only for the master branchpush:branches:[master ]pull_request:branches:[master ]# Allows you to run this workflow manually from the Actions tabworkflow_dispatch:# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs:# This workflow contains a single job called \"build\"build:# The type of runner that the job will run onruns-on:ubuntu-latest# Steps represent a sequence of tasks that will be executed as part of the jobsteps:# Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it- uses:actions/checkout@v3# Runs a single command using the runners shell- name:Run a one-line scriptrun:echo Hello, world!# Runs a set of commands using the runners shell- name:Run a multi-line scriptrun:|echo Add other actions to build, echo test, and deploy your project.當滿足 push 或是 pull_request 時，都會在 Github actions 內看到相關的資訊與 echo 出來的文字。 基本上我會把這個 main.yml 分成三個部分： name on job name : 代表這個 workflow 的名稱，就單純是個名稱，這個欄位可以省略不寫，省略時會使用 *.yml 的名稱。 on : 控制這個 workflow 如何觸發或是何時要運作。 job : 就是我們希望他能幫我們運作的工作，job 可以依序進行，或是以平行方式同時進行。 除了 name 以外， on 與 jobs 會簡單介紹與使用。 ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:2:1","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"on 觸發方式有很多種，我目前是比較常使用 schedule 與 push 兩種方式。 schedule 通常會搭配 cron 做排程使用，但我自己的經驗是觸發時間不太準確，如果專案很在意觸發時間的請使用其他方式。 push 則是當你推送內容至 branch 時，就會觸發，我編輯 yaml 並測試時是採用這個方式進行測試。 on:push:branches:[\"main\"]schedule:- cron:'0 1 * * 1'Github 有個說明文件提供了可使用的觸發方法：Events that trigger workflows cron 的使用方式，就像你在 Linux 上使用 crontab 是一樣的，這邊提供時間設定的方式參考：crontab guru ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:2:2","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"jobs 由許多個 step 所組成，step 則是實際要運作的指令，job 之間是平行處理，若 job 之間有依賴性，需要透過 need 進行設定。 如下列的程式碼， deploy 需要等待 build 完成後才會進行。 進一步的話可以透過 if 判斷要依賴的 jobs 的狀態再進一步處理。 jobs:build:steps:// steps, steps and steps.deploy:needs:buildif:needs.build.result == 'success'steps:// steps, steps and steps.另外，我們使用的 runner 也是在這邊透過 runs-on 做設定： jobs:build:runs-on:ubuntu-latestruns-on 可以設定要使用 Github 提供的 runner 其中之一，或是自行提供相關設備連線進行使用。 關於更多 runs-on 的使用方式，可以參考官方文件：Hosting your own runners ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:2:3","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"steps 基本上運行 steps 都會先建議用一次 actions/checkout，看設定是否有問題，這邊我們會透過 uses: actions/checkout@v3 做這件事情，uses 可以讓我們使用在 github 上，其他開發者寫好的 action。 Tips 有些 actions 在 actions/checkout@v3 會發生問題，可以採用 actions/checkout@v2 ，或是看用的 actions 是否有釋出新版本來解決這個問題。 或是自行定義，以 github 提供的範本做說明： - name:Run a one-line scriptrun:echo Hello, world!我定義了一個名稱為 Run a one-line script 的 workflow，並讓他執行 echo Hello, world! 這行指令。 當我們透過這種方式定義時，還可以使用一些參數協助設定，像是從 secrets 中取出我們的 secret 並放到環境變數中。(env) - name:Export Variablesenv:BEARER_TOKEN:${{ secrets.TWITTER_BEARER_TOKEN }}或是透過 with 加入更多的變數做使用。 - name:send tweet content for telegram messageuses:appleboy/telegram-action@master# These are environments secrets.with:to:${{ secrets.TELEGRAM_TO }}token:${{ secrets.TELEGRAM_TOKEN }}message:${{ steps.tweet.outputs.result }}更多 workflow 的使用方式，可以參考官方文件：Using workflows ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:3:0","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"Secret 有一些敏感的資訊，不能放在程式碼內，因為會被他人看到進而被做其他利用。 Github 提供了 secret 的功能，讓我們可以存放這些敏感資訊並使用。 進入專案的 setting，並點選左側的 Secret 標籤即可設定。 修改前的檔案\" 修改前的檔案 secret 分成兩種： Environment secrets Repository secrets Environment secrets 主要是給 Github actions 作為環境參數使用，而 Repository secrets 則是給 Repository 做使用。 依據需求建立即可，另外設定好的 secrets 自己要另外儲存一份，因為儲存過後的 secrets 就真的是秘密，看不到了！ ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:4:0","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Infra"],"content":"參考資料 Github Actions Events that trigger workflows crontab guru Hosting your own runners GitHub Marketplace · Actions to improve your workflow ","date":"2022-04-01","objectID":"/posts/infra/github_actions_guide/:5:0","tags":["Github Actions"],"title":"自己動起來！ Github Actions 極簡單介紹與使用","uri":"/posts/infra/github_actions_guide/"},{"categories":["Misc"],"content":"簡單分享一下看完 Learning Go 的心得，與未來對該語言的想法。 ","date":"2022-03-30","objectID":"/posts/misc/learning_go_summary/:0:0","tags":["Misc"],"title":"Learning Go 讀後感(Summary)","uri":"/posts/misc/learning_go_summary/"},{"categories":["Misc"],"content":"心得 因為 Hugo 的關係，體會到 Go 的速度非常快，且有一些有名的專案(Docker, K8s, Terraform) 是由 Go 實現的，故才會想花些時間去了解 Golang。 基本上對於 Go 的使用方法有一定的了解，雖然從 interface 就認為有點苦手，但後面的像是 standard library 或是 test 等，基本上還算可以理解。 後續花時間寫自己想做的東西，應該能了解的快一些吧。 ","date":"2022-03-30","objectID":"/posts/misc/learning_go_summary/:1:0","tags":["Misc"],"title":"Learning Go 讀後感(Summary)","uri":"/posts/misc/learning_go_summary/"},{"categories":["Misc"],"content":"未來 在我閱讀這本書，與撰寫筆記的這段期間，Go 釋出了 1.18 的更新，我認為很重要的兩項： 泛型(Generics) 模糊測試(Fuzzing) 書裡面是有 Generics ，原先想說還沒發佈，且我現在是使用 1.15 版，就想說等發佈了再看。之後補上 另外像 Concurrency 與 Context，以及一些欠債要還的資訊(e.g. garbage collector) 都會再補上。 還有我在第八篇說過，後面品質不太好的部分，都會再做補充。如果有空 過一陣子再回來看自己寫的，也會比較容易發現說當初哪裡寫得不太恰當或是錯誤的，再行修改。 不過，會暫時休息，換去網路跑道跑一陣子之後再回來繼續學習。 感謝自己這陣子願意花時間去學習 golang。 所以我就帶自己去吃個小螃蟹(?\" 所以我就帶自己去吃個小螃蟹(? ","date":"2022-03-30","objectID":"/posts/misc/learning_go_summary/:2:0","tags":["Misc"],"title":"Learning Go 讀後感(Summary)","uri":"/posts/misc/learning_go_summary/"},{"categories":["Misc"],"content":"參考資料(Reference) Learning Go (書籍) Go 1.18 is released! ","date":"2022-03-30","objectID":"/posts/misc/learning_go_summary/:3:0","tags":["Misc"],"title":"Learning Go 讀後感(Summary)","uri":"/posts/misc/learning_go_summary/"},{"categories":["Go"],"content":"簡單說明 reflect, unsafe 與 cgo。 ","date":"2022-03-26","objectID":"/posts/go/13_reflect_unsafe_cgo/:0:0","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/13_reflect_unsafe_cgo/"},{"categories":["Go"],"content":"Reflect Go 是靜態強型態語言，因此類型是 Go 很重要的一個部分。 但有些時候我們會不清楚該資料的型態，或是想設計支援多個類型的函式，Go 提供了 Reflect 讓我們在程式運作中檢查類型，甚至能進一步修改與建立函式、結構的能力。 一個很經典的例子： fmt.Println ","date":"2022-03-26","objectID":"/posts/go/13_reflect_unsafe_cgo/:1:0","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/13_reflect_unsafe_cgo/"},{"categories":["Go"],"content":"TypeOf 我們可以用 TypeOf 取得類型的名稱，但像 slice 或是 map 等指標類型，會回傳一個空字串 \"\"。 var v int vType := reflect.TypeOf(v) fmt.Println(vType.Name()) // Output int Kind 會回傳類型是由什麼組成的，通常用在 slice 或是 map 等指標類型。 有些類型引用了其他類型，我們可以透過 Elem 找出被引用的類型是什麼： var v int vType := reflect.TypeOf(\u0026v) fmt.Println(vType.Name()) fmt.Println(vType.Kind()) fmt.Println(vType.Elem().Name()) fmt.Println(vType.Elem().Kind()) reflect 也可以反映結構，透過 NumField 取得架構內部的字段個數，並透過 Field 取得架構內的字段，如果架構內有 tag 的話，可以透過 Get 取得 tag 的資訊： type Foo struct { A int `myTag:\"value\"` B string `myTag:\"value2\"` } var f Foo ft := reflect.TypeOf(f) for i := 0; i \u003c ft.NumField(); i++ { curField := ft.Field(i) fmt.Println(curField.Name, curField.Type.Name(), curField.Tag.Get(\"myTag\")) } ","date":"2022-03-26","objectID":"/posts/go/13_reflect_unsafe_cgo/:1:1","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/13_reflect_unsafe_cgo/"},{"categories":["Go"],"content":"Value 我們可以透過 reflect.ValueOf 實現 reflect.Value: vValue := reflect.ValueOf(v) 透過這個與 Set，我們也可以用來設定變數的數值： i := 10 iv := reflect.ValueOf(\u0026i) ivv := iv.Elem() ivv.SetInt(20) ","date":"2022-03-26","objectID":"/posts/go/13_reflect_unsafe_cgo/:1:2","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/13_reflect_unsafe_cgo/"},{"categories":["Go"],"content":"New New 透過 Type 返回一個指定類型的 pointer，我們可以透過修改這個 pointer 與使用 Interface 將修改過後的數值給一個變數： package main import ( \"fmt\" \"reflect\" ) func main() { a := 1 intPtr := reflect.New(reflect.TypeOf(a)) intPtr.Elem().SetInt(2) b := intPtr.Elem().Interface().(int) fmt.Println(b) } ","date":"2022-03-26","objectID":"/posts/go/13_reflect_unsafe_cgo/:1:3","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/13_reflect_unsafe_cgo/"},{"categories":["Go"],"content":"Unsafe unsafe，可以讓我們操作記憶體，反過來說，操作記憶體不安全，所以叫做 unsafe。 為何要使用 unsafe 呢？ 許多 package 內使用過。 大部分是要操作系統而使用。 使用 unsafe 可以有更好的 performance。 基本上有三種函數與一種類型： SizeOf : 回傳變數所使用的記憶體大小 AlignOf : 回傳在記憶體中進行記憶體對齊需要的倍數。 OffsetOf : 回傳兩個變數之間的位址差距。 unsafe.pointer : 任何類型的 pointer 都可以轉換為 unsafe.Pointer ","date":"2022-03-26","objectID":"/posts/go/13_reflect_unsafe_cgo/:2:0","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/13_reflect_unsafe_cgo/"},{"categories":["Go"],"content":"cgo C 語言已經有很久的歷史，但至今仍是重要的程式語言之一。許多的作業系統是以C/C++實現的，這也意味著許多程式語言都提供了使用 C 的函式庫之方法（FFI）。 Go 語言將這個外部函數介面稱為 cgo。 基本上要先 import \"C\"，這行會讓 Go 編譯前先運行 cgo。cgo 會運行與前面有關的註解。並將 C 的程式碼( .c, .h )放置到同一個目錄中，另外要安裝 C 的編譯器，最後再透過 go build 即可。 package main import \"fmt\" /* #cgo LDFLAGS: -lm #include \u003cstdio.h\u003e #include \u003cmath.h\u003e #include \"mylib.h\" int add(int a, int b) { int sum = a + b; printf(\"a: %d, b: %d, sum %d\\n\", a, b, sum); return sum; } */ import \"C\" func main() { sum := C.add(3, 2) fmt.Println(sum) fmt.Println(C.sqrt(100)) fmt.Println(C.multiply(10, 20)) } 不過因為兩種語言的不同之處，cgo 在使用上有極大機率造成效能降低： Go 會收集 garbage，但 C 不會。 一些以 pointer 傳遞的類型無法在兩種語言之間運作。 部分 C library 不支援(e.g. printf)。 除非是已經有一個很好的 C 函式庫需要使用，不然不建議使用。 ","date":"2022-03-26","objectID":"/posts/go/13_reflect_unsafe_cgo/:3:0","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/13_reflect_unsafe_cgo/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) StackOverFlow - How do you create a new instance of a struct from its type at run time in Go? ","date":"2022-03-26","objectID":"/posts/go/13_reflect_unsafe_cgo/:4:0","tags":["go","golang"],"title":"Golang - 反射，不安全與Cgo (Reflect, Unsafe, and Cgo)","uri":"/posts/go/13_reflect_unsafe_cgo/"},{"categories":["Go"],"content":"簡單說明如何進行程式碼測試，介紹檢查代碼覆蓋率與編寫基準測試。 ","date":"2022-03-25","objectID":"/posts/go/12_tests/:0:0","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/12_tests/"},{"categories":["Go"],"content":"Basic 測試分成兩個部分： package : testing tool : go test testing 提供了測試的類型與函數，而 go test 則是將相關工具綁在一起進行測試後產生報告。 另外， Go 的測試與程式碼會放在同一個目錄，或是同一個 package 當中，也因為在同一個 package 中，所以可以測試未導出的變數與函數。 一個簡單的測試，先寫好一個要被測試的函數，並存放在 adder/adder.go 中： package adder func addNumbers(x, y int) int { return x + x } 每個測試都寫在一個以 _test.go 結尾的檔案中。 因此，測試會放在 adder/adder_test.go： package adder import ( \"testing\" ) func Test_Adder(t *testing.T){ result := addNumbers(2,3) if result != 5{ t.Error(\"incorrect result\") } } 測試函數開頭，會以 Test 為開頭，並傳入 *testing.T。 測試函數不會返回任何數值。這個測試中會使用 t.Error 返回錯誤訊息，用法與 fmt.Println 類似。 完成之後使用 go test 進行測試： $ go test PASS ok test_examples/adder 0.006s ","date":"2022-03-25","objectID":"/posts/go/12_tests/:1:0","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/12_tests/"},{"categories":["Go"],"content":"測試失敗 剛剛使用的 t.Error 是報告的其中一個方法，也可使用 t.Errorf 格式化輸出。 另外也可以使用 t.Fatal或是 t.Fatalf，它會在錯誤發生時，中斷測試，而使用 t.Error 則不會。 看自己要怎麼應用測試而使用。 ","date":"2022-03-25","objectID":"/posts/go/12_tests/:1:1","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/12_tests/"},{"categories":["Go"],"content":"TestMain 有時候在測試時，要先設定一些環境或變數再開始進行測試，透過 TestMain 可以讓我們在測試前或測試後做一些事情，像是我要從 database 或是外部撈數據之後，透過這些事情的結果再進行測試。 var testTime time.Time func TestMain(m *testing.M) { fmt.Println(\"Set up stuff for tests here\") testTime = time.Now() exitVal := m.Run() fmt.Println(\"Clean up stuff after tests here\") os.Exit(exitVal) } func TestFirst(t *testing.T) { fmt.Println(\"TestFirst uses stuff set up in TestMain\", testTime) } func TestSecond(t *testing.T) { fmt.Println(\"TestSecond also uses stuff set up in TestMain\", testTime) } 我們建立了一個 TestMain，在裡面初始化了需要使用的變數，完成後使用 Run 去執行 test，這時就會開始進行測試。 要注意一點是，最後必須從 Run 裡面使用 os.Exit 來結束測試。 TestMain 他不會單獨的在測試函式前後執行，另外要注意的是，每個 package 內只能有一個 TestMain。 ","date":"2022-03-25","objectID":"/posts/go/12_tests/:2:0","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/12_tests/"},{"categories":["Go"],"content":"testdata Go 有保留這個目錄名稱，作為存放初始測試資料的目錄，從這個目錄存取檔案時，請使用相對路徑。 ","date":"2022-03-25","objectID":"/posts/go/12_tests/:2:1","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/12_tests/"},{"categories":["Go"],"content":"測試 public api 前面我們提到過，函數的大小寫字首決定他是否為 public，如果我們只想測試 public api，透過下列的方法即可，一樣會以前面的 adder 為例子。 adder.go package adder // public : 字首大寫 func AddNumbers(x, y int) int { return x + x } adder_test.go // Package 的名稱後面加上 _test package adder_test import ( \"testing\" // 導入 adder，使用時注意路徑 \"adder\" ) func Test_Adder(t *testing.T){ result := adder.AddNumbers(2,3) if result != 5{ t.Error(\"incorrect result\") } } ","date":"2022-03-25","objectID":"/posts/go/12_tests/:2:2","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/12_tests/"},{"categories":["Go"],"content":"Code Coverage Code Coverage 可以幫助我們了解，程式中是否有遺漏明顯的地方，雖然覆蓋率 100% 不代表程式運作 100% 正常，但至少可以降低錯誤發生的機率(吧) 透過 go test -v -cover 可以顯示覆蓋率，如果再加上 -coverprofile=[filename] 可以把訊息輸出。 $ go test -v -cover -coverprofile=test.out 輸出後可以用 html 的方式開啟，會告訴你哪邊有被覆蓋，哪邊尚未被覆蓋。 $ go tool cover -html=test.out ","date":"2022-03-25","objectID":"/posts/go/12_tests/:3:0","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/12_tests/"},{"categories":["Go"],"content":"Benchmarks 當我們的程式都沒問題了之後，下一步要測試的可能是程式的快慢，Go 提供了 test_examples/bench 讓我們可以進行一些基準測試： 要以 Benchmark 作為開頭。 接收一個 *testing.B 類型的參數 func BenchmarkSay(b *testing.B){ for i:= 0; i\u003c b.N; i++ { adder.Say(\"Hi\") } } 每個 Go 基準測試都必須有一個從 0 迭代到 b.N，測試框架一遍又一遍地用越來越大的 N 值調用我們的基準函數，直到確定計時結果準確為止。 測試時使用 -bench=. 執行所有的基準測試，再加上 -benchmem 會顯示記憶體的資訊。 如果測試程式中有一般的測試(*testing.T)與基準測試，則會先執行一般的測試再進行基準測試。 $ go test -bench=. -benchmem goos: darwin goarch: amd64 pkg: adder BenchmarkSay-4 2 512890848 ns/op 48 B/op 1 allocs/op PASS ok adder 1.555s BenchmarkSay-4 : 名稱 2 : 測試運行已產生穩定結果的次數 512890848 ns/op : 執行一次測試需要花費的時間 48 B/op : 每次測試使用的記憶體空間 1 allocs/op : 每次測試發生了多少由 heap 分配的次數。 ","date":"2022-03-25","objectID":"/posts/go/12_tests/:4:0","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/12_tests/"},{"categories":["Go"],"content":"Stubs 因為函數之間通常會有依賴關係，在測試中可能會因為某個函數需要前一個動作處理後的結果，才能進行測試，比方說，我需要從 database 取得資料，故我要先與 database 進行連線，但我只是要測試取得資料這個函式而已，能不能不要與 database 進行連線？ 在前面我們提到了 function type 與 interface type，我們可以透過這兩種類型降低測試時的函式依賴。 範例待補 ","date":"2022-03-25","objectID":"/posts/go/12_tests/:5:0","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/12_tests/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) ","date":"2022-03-25","objectID":"/posts/go/12_tests/:6:0","tags":["go","golang"],"title":"Golang - 測試(Tests)","uri":"/posts/go/12_tests/"},{"categories":["Go"],"content":"本篇文章將簡單介紹 Standard Library 內的幾個較重要的 package，像是io, time, encoding/json, net/http。 ","date":"2022-03-24","objectID":"/posts/go/11_standardlib/:0:0","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/11_standardlib/"},{"categories":["Go"],"content":"io io 是個很常被使用的 package，尤其是 io.Reader 與 io.Writer。 看到 er 結尾了嗎？所以他應該是… interface ? type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } Read 會將資料讀入 p，一個 byte 類型的 slice，並傳回讀取的 byte 數量，也就是 n，另外還會返回遇到的錯誤。 Write 則會將 p 輸出並回傳寫入的 byte 數量與遇到的錯誤。 io.reader 表示 data stream 的讀取端，標準函式庫已經有許多包含此 interface 的 implement。當 stream 結束時會返回 io.EOF 的錯誤。 package main import ( \"fmt\" \"io\" \"strings\" ) func main() { r := strings.NewReader(\"Hello, Reader!\") b := make([]byte, 8) for { n, err := r.Read(b) fmt.Printf(\"n = %v err = %v b = %v\\n\", n, err, b) fmt.Printf(\"b[:n] = %q\\n\", b[:n]) if err == io.EOF { break } } } io.writer 則是反過來，把 data 寫進 stream。 package main import ( \"fmt\" \"os\" ) func main() { f, err := os.OpenFile(\"/tmp/123.txt\", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0600) if err != nil { panic(err) } defer f.Close() // Here n, err := f.Write([]byte(\"writing some data into a file\")) if err != nil { panic(err) } fmt.Println(\"wrote %d bytes\", n) } 另外，io 還有一些像是 io.Closer, io.seeker 等 interface。使用上其實都很容易。 ","date":"2022-03-24","objectID":"/posts/go/11_standardlib/:1:0","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/11_standardlib/"},{"categories":["Go"],"content":"ioutil ioutil 則實現了更多更方便的函數。 ReadAll : 一次性讀取 io.reader 內的數據。 ReadDir : 讀取目錄底下所有的文件與子資料夾名稱。 ReadFile : 讀取檔案。 WriteFile : 寫入檔案。 還有一些像是 TempDir, TempFile 等函數，有興趣的可以用 go doc ioutil 觀看。 ","date":"2022-03-24","objectID":"/posts/go/11_standardlib/:1:1","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/11_standardlib/"},{"categories":["Go"],"content":"time 基本上有兩種類型表示時間： time.Duration time.Time time.Duration 用來表示一段時間，基於 int64 實現的，也可以使用 time.ParseDuration，用字串來表示時間。 例如我寫這篇文章花費了五小時又三十分鐘： cost := 5 * time.Hour + 30 * time.Minute costStr, _ := time.ParseDuration(\"5h30m\") 另外，time.Duration 已經滿足了 fmt.Stringer，所以會返回一個格式化過的字串。 fmt.Println(cost) // Output 5H30M0S time.Time，可以用使用 time.Now 取得現在時間，或是填入想設定的時間 type Time struct{ ... } func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time func Now() Time 最後，Go 是使用 monotonic clock 來跟蹤時間的。 ","date":"2022-03-24","objectID":"/posts/go/11_standardlib/:2:0","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/11_standardlib/"},{"categories":["Go"],"content":"Timer and Ticker Timer 基本上就是計時器，通常用在 select 對於多個 channel 的超時，或是一些讀寫行為的超時情形，他是一次性的，這也是與 Ticker 不同的地方，Ticker 是每隔一段時間就進行一次。 type Timer struct{ ... } func AfterFunc(d Duration, f func()) *Timer func NewTimer(d Duration) *Timer type Ticker struct{ ... } func NewTicker(d Duration) *Ticker ","date":"2022-03-24","objectID":"/posts/go/11_standardlib/:2:1","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/11_standardlib/"},{"categories":["Go"],"content":"encoding/json RESTful API 讓 json 成為資料傳遞的重要格式，也因此 Go 也支援將 Go 的數據類型轉換成 json，或是由 json 轉換回來。 假設說我們有筆 json 資料： { \"id\":\"12345\", \"date_ordered\":\"2020-05-01T13:01:02Z\", \"customer_id\":\"3\", \"items\":[{\"id\":\"xyz123\",\"name\":\"Thing 1\"},{\"id\":\"abc789\",\"name\":\"Thing 2\"}] } 那我們就需要建立 struct 去對應名稱與類型，進行轉換。 type Order struct { ID string `json:\"id\"` DateOrdered time.Time `json:\"date_ordered\"` CustomerID string `json:\"customer_id\"` Items Item `json:\"items\"` } type Item struct { ID string `json:\"id\"` Name string `json:\"name\"` } 有一些地方要注意的： 名稱前要加上 json 標籤。 要使用反引號刮起來。 如果輸出 json 時，因為某些欄位沒有數值而要忽略某些欄位，請在後方加上 ,omitempty type Item struct { ID string `json:\"id\"` Name string `json:\"name,omitempty\"` } 使用 ,omitempty 要注意到 struct 的 zero value 不是代表空值，所以 ,omitempty 仍然會轉換成 json，如果 struct 內部有 struct 類型的資料，又想在沒資料時忽略該欄位，請在 struct 上使用 pointer。 type Order struct { ID string `json:\"id\"` DateOrdered time.Time `json:\"date_ordered\"` CustomerID string `json:\"customer_id\"` Items *Item `json:\"items\"` } type Item struct { ID string `json:\"id\"` Name string `json:\"name\"` } ","date":"2022-03-24","objectID":"/posts/go/11_standardlib/:3:0","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/11_standardlib/"},{"categories":["Go"],"content":"編碼與解碼 透過 json.Unmarshal 與 json.Marshal 進行 json 與 struct 之間的轉換。 json.Unmarshal 可以把 json 字串轉成 struct，而 json.Marshal 可以將 struct 轉成 json。 var o Order err := json.Unmarshal([]byte(data), \u0026o) if err != nil { return err } out, err := json.Marshal(o) 另外也可以透過 json.Decoder 與 json.Encoder ，對檔案進行解碼與編碼，這樣就可以用 io.Reader 與 io.Writer 進行 io 讀取與寫入的操作。 err1 = json.NewEncoder(tmpFile1).Encode(toFile) err2 = json.NewDecoder(tmpFile2).Decode(\u0026fromFile) ","date":"2022-03-24","objectID":"/posts/go/11_standardlib/:3:1","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/11_standardlib/"},{"categories":["Go"],"content":"net/http 我覺得 go 提供的一個很棒的 package，它可以讓我們開發 http server 與 client 相關的程式！！ ","date":"2022-03-24","objectID":"/posts/go/11_standardlib/:4:0","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/11_standardlib/"},{"categories":["Go"],"content":"Client 我們可以建立一個 http.Client，並透過 http.Request 等方式進行用戶端的需求。如果說沒有 context 要傳送的話，請記得使用 nil。 Method 也有常見的 GET, POST, PATCH 可以使用。 client := \u0026http.Client{ Timeout: 30 * time.Second, } req, err := http.NewRequestWithContext(context.Background(), http.MethodGet, \"https://google.com\", nil) if err != nil { panic(err) } 我們也還可以添加一些關於 header 的資訊，添加後使用 Do 去處理，會得到相對的 response： req.Header.Add(\"X-My-Client\", \"Learning Go\") res, err := client.Do(req) if err != nil { panic(err) } Response 則會有許多資料： status statusCode header body ","date":"2022-03-24","objectID":"/posts/go/11_standardlib/:4:1","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/11_standardlib/"},{"categories":["Go"],"content":"Server Server 的用途就是監聽 http 的請求，另外他也支援 tls 與 http/2。好神 package main import ( \"fmt\" \"net/http\" ) func indexHandler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"hello world\") } func main() { http.HandleFunc(\"/\", indexHandler) http.ListenAndServe(\":8080\", nil) } 這樣我們會在 “/” 上面建立一個 indexHandler，當有 Request 時，則會進行 ResponseWriter ，產生 response。 但這樣子只能處理單個 request，因此標準函式庫內有一個請求路由器 (*http.ServeMux)，並透過 http.NewServeMux 實現，透過ServeMux，我們可以傳入路徑與 handler，當 mux 收到對應的請求時，會根據路徑而使用對應的 handler 進行處理。 package main import ( \"net/http\" ) func main() { cat := http.NewServeMux() cat.HandleFunc(\"/voice\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"meow!\\n\")) }) dog := http.NewServeMux() dog.HandleFunc(\"/voice\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"wow!\\n\")) }) mux := http.NewServeMux() mux.Handle(\"/cat/\", http.StripPrefix(\"/cat\", cat)) mux.Handle(\"/dog/\", http.StripPrefix(\"/dog\", dog)) http.ListenAndServe(\":3000\", mux) } ","date":"2022-03-24","objectID":"/posts/go/11_standardlib/:4:2","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/11_standardlib/"},{"categories":["Go"],"content":"補充 更多的使用方式，go doc [package name] 或是問 Google，畢竟標準函式庫提供了不少函式可以使用… ","date":"2022-03-24","objectID":"/posts/go/11_standardlib/:5:0","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/11_standardlib/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) An Introduction to Handlers and Servemuxes in Go Golang 的 “omitempty” 关键字略解 Golang Reader Example ","date":"2022-03-24","objectID":"/posts/go/11_standardlib/:6:0","tags":["go","golang"],"title":"Golang - 標準函式庫(Standard Library)","uri":"/posts/go/11_standardlib/"},{"categories":["Go"],"content":"本篇文章將簡單介紹 Concurrency，並說明 goroutine, channel 和 select。 ","date":"2022-03-23","objectID":"/posts/go/10_concurrency/:0:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/10_concurrency/"},{"categories":["Go"],"content":"Concurrency 可能有聽過 “asynchronous”,“Parallelism” 或是 “threaded”，雖然很像但有點不太一樣。 主要可以解釋成，一個或多個 processes 同時發生的 process，好比說你正在看我的筆記，而其他人正在世界上做自己的事情，這些人同時與您存在。 但我認為一樣的都是，很難正確處理。 ","date":"2022-03-23","objectID":"/posts/go/10_concurrency/:1:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/10_concurrency/"},{"categories":["Go"],"content":"什麼時候使用 首先要確定，使用並發會讓效能變好再使用，因為並發並不是並行(Parallelism)，過多的並發只會導致程式難以理解，並發的數量也不會與效能成真正的正比關係。 基本上程式的邏輯是： 獲取數據 計算 輸出結果 基本上要使用並發，取決於數據如何通過程式的步驟流動，有時候多個步驟可以並發，因為他們沒有需要別的步驟執行後才能執行，反過來說，如果步驟是像串聯一般地執行，則不應使用並發。 另外，如果並發運行的程式不會花費太多時間，也不推薦使用並發，因為硬體資源並不是免費的，如果不確定使用並發會不會提升效能，可以透過寫測試的方式驗證。 ","date":"2022-03-23","objectID":"/posts/go/10_concurrency/:1:1","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/10_concurrency/"},{"categories":["Go"],"content":"Goroutine Goroutine 是 Go 在運行時管理的輕量化 processes。 當程式啟動時，運行中會建立許多 thread 並運行一個 goroutine 來運行我們所寫的程式。 程式所建立的所有 goroutine（包含一開始的），都會由 go 去調度並分配給 thread，類似我們設計跨 CPU kernel 的程式。 但作業系統已經能做到這件事，為什麼 Go 還要再實現類似的機制呢？ Goroutine 建立的比 thread 還快。 Goroutine 初始化 stack 比 thread stack 還小，代表相同的記憶體空間下可以放更多的 goroutine。 Goroutine 之間切換的速度比 thread 還快，因為 Goroutine 完全發生在 process 內。 Go 有 scheduler 能做最佳化。 ","date":"2022-03-23","objectID":"/posts/go/10_concurrency/:2:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/10_concurrency/"},{"categories":["Go"],"content":"如何使用 我們在函數前面輸入 go 就能夠啟動了，只是這個函式的返回值會被忽略。 任何函式都能夠這樣子啟用並發，但通常會在 closure 內執行，這樣會使程式較容易測試與模組化，並使得 API 不具有並發性。 // 我們要並發的函式 func process(val int) int { // do something with val } // 透過一個函式去呼叫 func runThingConcurrently(in \u003c-chan int, out chan\u003c- int) { // closure go func() { for val := range in { result := process(val) out \u003c- result } }() } ","date":"2022-03-23","objectID":"/posts/go/10_concurrency/:2:1","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/10_concurrency/"},{"categories":["Go"],"content":"Channel goroutine 透過 channel 進行溝通。 聲明 chan 後透過 make 實現： ch := make(chan int) channel 是參考類型(reference)，與 map, slice一樣，傳遞時是傳遞 channel 的 pointer。 channel 的 zero value 是 nil。 ","date":"2022-03-23","objectID":"/posts/go/10_concurrency/:3:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/10_concurrency/"},{"categories":["Go"],"content":"讀取與寫入 透過一個 \u003c-運算符進行讀取與寫入的動作，與C++的 -\u003e 是相反過來的。 a := \u003c-ch // reads a value from ch and assigns it to a ch \u003c- b // write the value in b to ch 另外我們也可以用 for-range 從 channel 中讀取，這種讀取方式，會一直持續到 channel 關閉，或是遇到 break 與 return 才會結束。 for v := range ch { fmt.Println(v) } 每個被寫入 channel 的數值只能被讀取一次。如果有多個 goroutine 從同一個 channel 讀取，寫入 channel 的數值只會被其中一個 goroutine 讀取。 Channel 也可以設定為單向讀取或是單向寫入： var writeOnly chan \u003c- int = ch1 var readOnly \u003c- chan int = ch2 Channel 預設是無緩衝的，每一次寫入了一個開放的無緩衝 channel，都會導致寫入 goroutine 暫停，直到另一個 goroutine 從這個 channel 讀取，反過來說，每一次讀取這個 channel，都會導致讀取 goroutine 暫停，一直到有一個 goroutine 寫入這個 channel，也就是說至少要有兩個 goroutine 才能寫入與讀取 channel。 Go 也有緩衝的 channel，如果在讀取這個 channel 前， channel 的緩衝區已經滿了，則後面的寫入將會暫停寫入，一直到讀取這個 channel 為止。就已經滿了你不給他空間不然你是想怎樣！？ 有緩衝區的 channel 怎麼實現呢？ ch := make(chan int, 10) 最後，大部分的時候會建議使用無緩衝區的 channel。 ","date":"2022-03-23","objectID":"/posts/go/10_concurrency/:3:1","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/10_concurrency/"},{"categories":["Go"],"content":"關閉 關閉，就是使用，close。 close(ch) 這樣就能夠關閉 channel，此時再寫入這個 channel 或是再次關閉都會造成 panic，但關閉後的 channel 是可以讀取的，若裡面還有未讀取的值，則會依序返回，如果沒有未讀取的值，則會返回 zero value。 但這樣當我們讀取到 zero value 時，我們要怎麼知道，這個 zero value 是被關閉的 channel 的，還是還沒讀取的值？ 偷看第三篇 v, ok := \u003c-ch ","date":"2022-03-23","objectID":"/posts/go/10_concurrency/:3:2","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/10_concurrency/"},{"categories":["Go"],"content":"select select 是並發的控制結構。 透過 select 可以允許 goroutine 讀取或寫入一組多個 channel 中的一個，他用起來很像 switch。 select { case v := \u003c-ch1: fmt.Println(v) case ch2 \u003c- x: fmt.Println(\"wrote\", x) case \u003c-ch3: fmt.Println(\"got value on ch4, but ignored it\") } 如果有多個 case 可以讀取或寫入的話，會發生什麼？ Go 的設計上會隨機選擇一個進行，可以防止飢餓的問題發生，另外也可以預防一種 deadlock 的發生：acquiring locks in an inconsistent order。 因為 select 用來負責讓多個 channel 進行聯繫，因此會用在一個 for-loop 中，這裡也被稱為 for-select 循環，使用 for-select 記得必須要有退出的方法。 for{ select { case v := \u003c-ch1: fmt.Println(v) case ch2 \u003c- x: fmt.Println(\"wrote\", x) case \u003c-ch3: fmt.Println(\"got value on ch4, but ignored it\") } case \u003c-done: return } ","date":"2022-03-23","objectID":"/posts/go/10_concurrency/:4:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/10_concurrency/"},{"categories":["Go"],"content":"Remenber 保持 API 沒有並發： 前面也提到了，盡量在 closure 內設計並發，並盡量隱藏，當使用者知道可以使用 API 來執行並發時。摁… 每當您的 goroutine 使用的數值是可能會改變的變量時，請將變量的當前值傳遞給 goroutine。 for _, v := range a { go func(val int) { ch \u003c- val * 2 }(v) } // 下面這個就沒傳值，goroutine內的v會是迴圈結束後的v值 for _, v := range a { go func() { ch \u003c- v * 2 }() } 清理與關閉 goroutine： 如果一個 goroutine 沒有退出，scheduler仍然會定期給它時間，但他可能什麼都不做，這會降低程式的效能。 何時使用緩衝與非緩衝 channel： 當知道已經啟動了多少個 goroutine，想要限制將啟動的 goroutine 的數量，或者想要限制排隊的工作量時，可以使用緩衝 channel。 ","date":"2022-03-23","objectID":"/posts/go/10_concurrency/:5:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/10_concurrency/"},{"categories":["Go"],"content":"備註 還有一些像是 Backpressure, sync.Waitgroup, sync.Once 跟 Mutex 的作用與用法想做筆記，但一時之間還想不到該怎麼寫，可能等之後有時間再來補充。 更多關於 Concurrency 的資訊，可以參考 Katherine Cox-Buday 所寫的 Concurrency in Go。（歐萊禮也有這本所以…又是坑） 另外，後續還會有一篇 Context 的筆記，但我會想看完 Concurrency in Go 再來寫筆記分享。 ","date":"2022-03-23","objectID":"/posts/go/10_concurrency/:6:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/10_concurrency/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) Concurrency in Go (書籍) Concurrency與Parallelism的不同之處 ","date":"2022-03-23","objectID":"/posts/go/10_concurrency/:7:0","tags":["go","golang"],"title":"Golang - 並發(Concurrency)","uri":"/posts/go/10_concurrency/"},{"categories":["Go"],"content":"本篇文章會介紹如何使用 module 與 package 組織程式碼，並如何 import。 ","date":"2022-03-23","objectID":"/posts/go/09_modules_packages_imports/:0:0","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/09_modules_packages_imports/"},{"categories":["Go"],"content":"Repositories, Modules, and Packages Repo 大家應該都很熟悉，版本控制中儲存程式碼的地方。 Modules 像是程式碼或應用程式的根目錄，包括一個或多個 package ，存放在 Repo 中。 如果這個根目錄有 go.mod，則代表這些程式碼的集合為一個 module，這個檔案請由指令去形成： $ go mod init \u003cMODULE_PATH\u003e 裡面則會有 module 的名稱， go 的版本，需要哪些 module 等等的資訊。 ","date":"2022-03-23","objectID":"/posts/go/09_modules_packages_imports/:1:0","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/09_modules_packages_imports/"},{"categories":["Go"],"content":"Import import 可以讓我們使用另一個 package 的 constants, variables, functions 與 types，另外 identifier 是大寫開頭的才能由外部存取，如果是小寫開頭的則只能於內部進行存取，我們很常用的 fmt.Println() 就是一個好例子。 ","date":"2022-03-23","objectID":"/posts/go/09_modules_packages_imports/:2:0","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/09_modules_packages_imports/"},{"categories":["Go"],"content":"Package ","date":"2022-03-23","objectID":"/posts/go/09_modules_packages_imports/:3:0","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/09_modules_packages_imports/"},{"categories":["Go"],"content":"Create Package 透過 package clause 實現，package clause 都會在檔案的第一行，且是非空白的非注釋行。 package test func Plus(a int, b int) int { return a+b } ","date":"2022-03-23","objectID":"/posts/go/09_modules_packages_imports/:3:1","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/09_modules_packages_imports/"},{"categories":["Go"],"content":"Access Package 當我們需要使用自己建立的 package 時，透過前面提到的 import 做使用，如果你不是使用 standard library 內的 package，使用時要注意 package 的 path。 package main import { \"fmt\" \"example/plus\" } func main() { num = test.Plus(1,2) fmt.Println(num) } // Output 3 另外有一些規則要注意： import 是要使用路徑，而不是 import package clause，我自己的話會想說把 package clause 與檔案名稱一致會比較好管理。除了某些情況是不需要一致的。 不要用 main 做 import， main 是程式運作的起點。 不要用一些特別的字元在 path 上。 ","date":"2022-03-23","objectID":"/posts/go/09_modules_packages_imports/:3:2","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/09_modules_packages_imports/"},{"categories":["Go"],"content":"重複 import 有時候會有 import 相同 package clause 的情形發生，例如 crypto/rand 與 math/rand，這樣我們使用 rand 時會有問題。 Go 可以讓我們 import 的 package 有別的名稱，但在維護上可能會有些問題，因為要去了解他是用別名的方式，還是直接 import 進來的。 package main import{ crand \"crypto/rand\" \"math/rand\" } func main(){ // Use crand ... } ","date":"2022-03-23","objectID":"/posts/go/09_modules_packages_imports/:3:3","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/09_modules_packages_imports/"},{"categories":["Go"],"content":"godoc 作為 package 的文件使用，其實就很像在 linux 有疑問時會用 man 或是 -H, --help 一樣。 基本上是程式的註解，沒有特殊的格式與符號。 但有一些規則要注意一下： 將註解放在對象的前面(上一行)，之間並沒有空白行。 以兩個雙斜線開頭，後面要先放對象的名稱。 透過空白行分段。 透過縮排進行註解的格式化。 package clause 則是要以 package clause 作為開頭， function 與 struct 則以名稱開頭即可。 可以實際觀察看看註解要如何撰寫。 $ go doc fmt 另外。在第一篇提到的 golangci-lint 可以幫助找出缺失註解的地方。 ","date":"2022-03-23","objectID":"/posts/go/09_modules_packages_imports/:3:4","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/09_modules_packages_imports/"},{"categories":["Go"],"content":"Modules 透過前面提到的 go mod，我們會得到一個 go.mod 的檔案，裡面可能會紀錄 package 的版本資訊。另外編譯過後，會有一個 go.sum 的檔案，裡面記錄了依賴 package 的 hash。 ","date":"2022-03-23","objectID":"/posts/go/09_modules_packages_imports/:4:0","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/09_modules_packages_imports/"},{"categories":["Go"],"content":"版本控制 我們可以透過 go list ，觀察 module 的版本，並透過 go get 取得較舊的版本。 $ go list -m -versions github.com/learning-go-book/simpletax github.com/learning-go-book/simpletax v1.0.0 v1.1.0 [!] 有v1.0.0 與 v.1.1.0，我想用舊版本... $ go get github.com/learning-go-book/simpletax@v1.0.0 [!] 此時回去看 go.mod 會發現版本已經改變了。 Hint 版本號的規則：major.minor.patch 修復錯誤時，patch 更新，增加新功能時，minor 更新並將 patch 歸零。 ","date":"2022-03-23","objectID":"/posts/go/09_modules_packages_imports/:4:1","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/09_modules_packages_imports/"},{"categories":["Go"],"content":"Vendoring 為了確保從頭到尾都能使用相同的依賴項開發，透過 go mod vendor 可以產生一個目錄，保存所有依賴項的副本。 如果又增加了新的依賴項，或是升級了依賴項，都要再執行一次 go mod vendor，否則會無法編譯。 ","date":"2022-03-23","objectID":"/posts/go/09_modules_packages_imports/:4:2","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/09_modules_packages_imports/"},{"categories":["Go"],"content":"補充 pkg.go.dev 會自動索引開源的 Go project。 ","date":"2022-03-23","objectID":"/posts/go/09_modules_packages_imports/:5:0","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/09_modules_packages_imports/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) ","date":"2022-03-23","objectID":"/posts/go/09_modules_packages_imports/:6:0","tags":["go","golang"],"title":"Golang - 模組、包與導入(Modules, Packages, and Imports)","uri":"/posts/go/09_modules_packages_imports/"},{"categories":["Go"],"content":"本篇文章會介紹如何在 Go 中處理錯誤，並簡單提一下 panic 與 recover。 ","date":"2022-03-23","objectID":"/posts/go/08_error/:0:0","tags":["go","golang"],"title":"Golang - 錯誤(Error)","uri":"/posts/go/08_error/"},{"categories":["Go"],"content":"前言 基本上這本書已經讀完一半了，給自己個小掌聲！ 但因為近期有些事情要處理，想先把這本書的筆記做完，把這邊的時間給空出來。 如果想說以後再回來寫，依照我的個性應該是會懶得寫… 近期應該會大量生產一堆品質低下的筆記。 (其實本來就沒多好) ","date":"2022-03-23","objectID":"/posts/go/08_error/:1:0","tags":["go","golang"],"title":"Golang - 錯誤(Error)","uri":"/posts/go/08_error/"},{"categories":["Go"],"content":"錯誤 Go 會透過 return 一個 error type 的數值，作為函數的最後一個返回值。如果函式正常運作並返回數值，則會返回 nil，如果發生錯誤，當然就會返回錯誤值。 func calcRemainderAndMod(numerator, denominator int) (int, int, error) { if denominator == 0 { return 0, 0, errors.New(\"denominator is 0\") } return numerator / denominator, numerator % denominator, nil } 一些小原則： 錯誤訊息不應該大寫。 不應該以標點符號結尾。 另外， Go 沒有特殊的方法去檢測，是否返回了錯誤，但可以用判斷式去判斷： if err != nil { // TODO } Go 使用返回錯誤的方式設計，而不是使用跳出異常(Exception)，一來是異常處理的方式有時會無法容易掌握，二來是程式碼遇到錯誤時可能不會崩潰，但數值會未正確初始化，修改等。 基本上我們可以使用 error.New() 與 fmt.Errorf() 兩種方式，透過 string 處理簡單的錯誤。 func doubleEven(i int) (int, error) { if i % 2 != 0 { return 0, errors.New(\"only even numbers are processed\") } return i * 2, nil } // OR func doubleEven(i int) (int, error) { if i % 2 != 0 { return 0, fmt.Errorf(\"%d isn't an even number\", i) } return i * 2, nil } ","date":"2022-03-23","objectID":"/posts/go/08_error/:2:0","tags":["go","golang"],"title":"Golang - 錯誤(Error)","uri":"/posts/go/08_error/"},{"categories":["Go"],"content":"Sentinel Errors 代表用一個特定值，來表示一個不能進一步處理的做法。 func main() { data := []byte(\"This is not a zip file\") notAZipFile := bytes.NewReader(data) _, err := zip.NewReader(notAZipFile, int64(len(data))) if err == zip.ErrFormat { fmt.Println(\"Told you so\") } } 這個程式代表要讀取 zip 格式，但傳入的參數並不是 zip，因此發生了錯誤，透過一個 ErrFormat代表傳入格式不正確時會發生的錯誤，然而當錯誤太多種時，則需要一個一個去定義錯誤的特定值並比對，撇開麻煩不說，當錯誤比對時，該錯誤沒有在自己定義的比對值，這樣會發生問題。 除了一些極端情況，不然應該會很少用 Sentinel Errors。 ","date":"2022-03-23","objectID":"/posts/go/08_error/:2:1","tags":["go","golang"],"title":"Golang - 錯誤(Error)","uri":"/posts/go/08_error/"},{"categories":["Go"],"content":"Error structure error 是一個內置的 interface： type error interface{ Error() string } 所以可以透過這個 interface ，自己定義錯誤訊息： // define status type . type Status int const ( InvalidLogin Status = iota + 1 NotFound ) // define statusErr type. type StatusErr struct { Status Status Message string } func (se StatusErr) Error() string { return se.Message } 這樣就可以透過 StatusErr 定義較多的詳細訊息： func LoginAndGetData(uid, pwd, file string) ([]byte, error) { err := login(uid, pwd) if err != nil { return nil, StatusErr{ Status: InvalidLogin, Message: fmt.Sprintf(\"invalid credentials for user %s\", uid), } } data, err := getData(file) if err != nil { return nil, StatusErr{ Status: NotFound, Message: fmt.Sprintf(\"file %s not found\", file), } } return data, nil } ","date":"2022-03-23","objectID":"/posts/go/08_error/:2:2","tags":["go","golang"],"title":"Golang - 錯誤(Error)","uri":"/posts/go/08_error/"},{"categories":["Go"],"content":"Panic and Recover Panic 主要是程式運作時，無法確定接下來應該發生什麼事，就會有 panic 的發生。另外有個內置函數稱為 panic ，可以使用任何類型，通常他會是 string。 func doPanic(msg string){ panic(msg) } 這時候在 CLI 上會顯示一些相關資訊，並執行該函式的延遲函式(defer)，如果他是被其他函式呼叫的，則會往上追蹤，一直到 main 函數為止。 Recover 則是一種處理 panic 的方式，透過 defer 來檢查是否發生了 panic： 這個例子中會發生 panic 而使得程式進入 defer，印出錯誤訊息，但因為 recover 的關係，程式會運作下去。 func div60(i int) { defer func() { if v := recover(); v != nil { fmt.Println(v) } }() fmt.Println(60 / i) } func main() { for _, val := range []int{1, 2, 0, 6} { div60(val) } } 也就是說，recover 會在 panic 發生後讓程式運作下去，很像其他語言的例外處理，但 recover 會不知道為何發生 panic，只會知道發生了 panic 之後應該做的事情。 e.g. 當我打開檔案讀取與寫入，發生 panic 了，透過 recover 會幫我處理像是關閉檔案，或是紀錄下錯誤訊息並繼續運作，而不會因為 panic 發生而導致程式終止。 ","date":"2022-03-23","objectID":"/posts/go/08_error/:3:0","tags":["go","golang"],"title":"Golang - 錯誤(Error)","uri":"/posts/go/08_error/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) ","date":"2022-03-23","objectID":"/posts/go/08_error/:4:0","tags":["go","golang"],"title":"Golang - 錯誤(Error)","uri":"/posts/go/08_error/"},{"categories":["Go"],"content":"本篇文章會介紹類型、方法和介面。 ","date":"2022-03-15","objectID":"/posts/go/07_type_methods_interfaces/:0:0","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/07_type_methods_interfaces/"},{"categories":["Go"],"content":"類型(Types) 一種基本上就像我們前面用過的，由開發者自行定義的類型。 type Person struct{ Name string Age int } 另外也可以使用原始類型，甚至是以複合的方式定義類型。 type Score int type Converter func(string)Score type TeamScore map[string]Score 基本上可以在任何的 code block 定義類型，但就只能在該 code block 的範圍內存取，唯一的例外是 exported package block level type。 ","date":"2022-03-15","objectID":"/posts/go/07_type_methods_interfaces/:1:0","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/07_type_methods_interfaces/"},{"categories":["Go"],"content":"方法(method) ","date":"2022-03-15","objectID":"/posts/go/07_type_methods_interfaces/:2:0","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/07_type_methods_interfaces/"},{"categories":["Go"],"content":"介紹 聲明方法其實很像聲明函數，只是差在多了一個 receiver specification。 type Person struct{ Name string Age int } func (p Person) String() string { return fmt.Sprintf(\"%s, age %d\", p.Name, p.Age) } receiver 的名稱通常會是該類型的縮寫，通常是該類型的第一個字母。在其他語言中經常是使用 this 或 self。 方法不能重載（overloading），這是 go 語言的特性，或許從其他語言再過來使用時，使用上可能會感到有些限制。 那這是聲明方式，使用方式呢？也很簡單： me := Person { Name : \"Wei\", Age : 26, } output = me.String() ","date":"2022-03-15","objectID":"/posts/go/07_type_methods_interfaces/:2:1","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/07_type_methods_interfaces/"},{"categories":["Go"],"content":"接收器(receiver) 前面的文章提到過，如果函數使用 pointer 類型的參數，代表這個傳入參數可能會被函式修改，相同的概念一樣在 receiver 上，receiver 有 pointer receiver 與 value receiver 兩種。 決定使用哪種 receiver 可以參考以下規則： 如果這個 method 需要修改 receiver，則必須使用 pointer receiver。 如果這個 method 要處理 nil 的情況，則必須使用 pointer receiver。 如果這個 method 不會修改 receiver，則可以使用 value receiver。 如果這個 type 內的 method 中，有一個以上的 pointer receiver，建議保持一致，讓所有的 method 都使用 pointer receiver。 ","date":"2022-03-15","objectID":"/posts/go/07_type_methods_interfaces/:2:2","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/07_type_methods_interfaces/"},{"categories":["Go"],"content":"Methods are Function Method 其實就很像前面提到的 Function，我在書中看到一個比較特別的用法是 method expression，直接從 type 中建立一個 function。 type Adder struct { start int } func (a Adder) AddTo(val int) int { return a.start + val } myAdder := Adder{start: 10} // method expression f1 = Adder.AddTo fmt.Println(f1(myAdder, 10)) // print 20 當然，從已經建立的 type 中將 method 取出來用也是可行的。 f2 = myAdder.AddTo fmt.Println(f2(15)) // print 25 Tips 複習一下：Golang 是 Call by Value. ","date":"2022-03-15","objectID":"/posts/go/07_type_methods_interfaces/:2:3","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/07_type_methods_interfaces/"},{"categories":["Go"],"content":"介面(Interface) interface 定義並描述了某些其他類型必須具有的確切方法。 聲明 Interface 也很簡單。interface 出現在 type 的名稱後方，通常會以 “er” 做為結尾命名。 我們在標準函式庫中，可以看到這個 fmt.Stringer 介面。 type Stringer interface { String() string } Tips 看到 type 了嗎？所以也有一種類型是介面類型(interface type)。 如果某個 type 有精確簽名(exact signature)的 method，就可以說他滿足該 interface， 像下面這個範例，因為他有一個 String() string 的 method。 type Book struct { Title string Author string } func (b Book) String() string { return fmt.Sprintf(\"Book: %s - %s\", b.Title, b.Author) } 下方這個 Count 類型也滿足 fmt.Stringer 介面。 type Count int func (c Count) String() string { return strconv.Itoa(int(c)) } 我們有兩種不同的類型，但他們都滿足 fmt.Stringer 介面。 反過來說，如果知道某個類型滿足 fmt.Stringer 介面，代表他有一個 method 是 String() string。 也就是說，當我們在任何地方看到具有 interface type 的聲明，都可以使用任何類型，只要他滿足該 interface。 這樣子我們不需要在意傳入的類型是什麼，我們需要在意的是該類型有什麼方法。 func Printer(s fmt.Stringer) { log.Println(s.String()) } book := Book{\"I am learing Go\", \"Wei\"} count := Count(1) Printer(book) Printer(count) // output Book: I am learing Go - Wei 1 ","date":"2022-03-15","objectID":"/posts/go/07_type_methods_interfaces/:3:0","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/07_type_methods_interfaces/"},{"categories":["Go"],"content":"使用 interface 的理由 減少重複或是樣板的程式碼。 為了更容易在單元測試中使用模擬而不是實體類型 作為一種架構工具，有助於強制執行程式碼庫各部分之間的解耦(decoupling)。 第一點有一部分是因為，函式庫內已經幫你實現了許多，就不需要再去實現。 當然，要自己實現 interface 肯定是沒問題的。 這裡附上一些常用到的 interface type 。link 第二點，當產品有時會用到 DB 或是 internet 時，測試就不太好做， 比方說，我只是要測試一個 insert 的功能，但我在測試上我得先建立一個 Database 的測試實例， 但我可以透過建立一個 interface 並模擬 Database 達到我要的目的，在測試上我就不需要使用實際的 Database。 最後也是 interface 最重要的一個特色，解耦。 降低函式庫之間的依賴關係，讓程式依賴於抽象，而不是依賴於實現。 以前面的例子來說，當我更改了 Book ，我不必去顧慮其他的程式，我只需要注意 Book 有沒有一個 method 滿足 interface 即可。 但我將 Printer 的傳入參數更改為 Book 時，一來是我要考量到 Count 需不需要使用 Printer，二來是要考量到修改 Book 會不會影響到 Printer 運作。 不過就是剛開始開發時會比較累一點，畢竟多了一個 interface 要設計。 ","date":"2022-03-15","objectID":"/posts/go/07_type_methods_interfaces/:3:1","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/07_type_methods_interfaces/"},{"categories":["Go"],"content":"nil nil 也是 interface type 的 zero value。 只是要注意一點，是 interface 的 type 與 value 都是 nil，才會被認為是 nil。 如果 interface 是 nil，使用他的 method 會造成 panic。 但就算 interface 不是 nil，如果 value 是 nil 且沒有處理好該情況，仍然有機會產生 panic。 ","date":"2022-03-15","objectID":"/posts/go/07_type_methods_interfaces/:3:2","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/07_type_methods_interfaces/"},{"categories":["Go"],"content":"Empty interface 有時候需要一種方式，代表可以儲存任何類型的 value: var i interface{} i = 20 i = \"Hi\" i = struct{ Name string Age int }{\"Wei\", 26} interface{} 可以保存任何類型的值。通常用於處理未知類型的函式， 像我們很常用的 fmt.Println()。 不過使用上要注意，因為會不知道儲存的是什麼類型的數值。而且 Golang 是強型態語言，語言特性說實在的，與 empty interface 有點衝突啦。 ","date":"2022-03-15","objectID":"/posts/go/07_type_methods_interfaces/:3:3","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/07_type_methods_interfaces/"},{"categories":["Go"],"content":"Type Assertions and Type Switches 若我們把 value 存到 interface{}，則可以透過 Type Assertions 與 Type Switches 觀察是否有特定的具體類型，或是具體類型實現了另一個 interface。 Type Assertions 實現該 interface 的類型，或是命名另一個 interface。 type MyInt int func main() { var i interface{} var mine MyInt = 20 i = mine i2 := i.(MyInt) fmt.Println(i2 + 1) } 此時 i2 的類型是 MyInt。 若我們更改成以下程式碼，會造成 panic，是因為類型不對而導致的錯誤。 i2 := i.(string) fmt.Println(i2) Type switches 則是當 interface{} 可能會儲存多種類型的值時，透過 switch 進行判斷： func doThings(i interface{}) { switch j := i.(type) { case nil: // i is nil, type of j is interface{} case int: // j is of type int case MyInt: // j is of type MyInt case io.Reader: // j is of type io.Reader case string: // j is a string case bool, rune: // i is either a bool or rune, so j is of type interface{} default: // no idea what i is, so j is of type interface{} } } ","date":"2022-03-15","objectID":"/posts/go/07_type_methods_interfaces/:3:4","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/07_type_methods_interfaces/"},{"categories":["Go"],"content":"Function Interface 前面介紹 type 與 function 時提到，function 也可以是一種類型，因此也可以用在 interface 上，透過 function type 實現 interface。 常見的例子是 http 服務： type Handler interface { ServeHTTP(ResponseWriter, *Request) } type HandlerFunc func(ResponseWriter, *Request) func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) } 透過 HandlerFunc 進行類型轉換，將函式快速轉換為 Handler 的介面類型，使得任何具有簽名的函數func(http.ResponseWriter,*http.Request)都可以用作http.Handler，透過 http.Handler 可以使用 function, method 與 closures 實現 HTTP 服務。 將符合 interface 的函數定義為 type，對這個 type 實現 interface 中的函式，使用的時候只要把自定義的函式做型態轉換就可以使用了。注意一點，原本的類型要相同才可以使用。 ","date":"2022-03-15","objectID":"/posts/go/07_type_methods_interfaces/:3:5","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/07_type_methods_interfaces/"},{"categories":["Go"],"content":"補充 關於解耦的部分，可以參考 solid 的依賴反轉原則，了解到解耦的優缺點。DIP ","date":"2022-03-15","objectID":"/posts/go/07_type_methods_interfaces/:4:0","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/07_type_methods_interfaces/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) Golang Interfaces Explained ","date":"2022-03-15","objectID":"/posts/go/07_type_methods_interfaces/:5:0","tags":["go","golang"],"title":"Golang - 類型、方法與介面(Types, Methods, and Interfaces)","uri":"/posts/go/07_type_methods_interfaces/"},{"categories":["Application"],"content":"本篇文章將說明如何透過 Github Actions、Telegram bot 與 Twitter stream，定時監聽特定的 Tweet 後發送訊息給 User。 2023/02/08 更新 : 因為 twitter API 於 2023/02/09 停止了免費存取，參考這篇文章開發時需要考慮到費用問題，或是選擇其他方式。Link 因為朋友的關係，知道 Twitter上有一位作家 比村奇石@Strangestone，而他筆下的 月曜日のたわわ 非常的好(?)。比村老師每週一早上都會在 Twitter 更新，故每週一早上都可以透過推特看到新的作品。月曜日のたわわ是我與朋友們週一時的話題，然而若當天忘記開 Twitter，當下會不知道如何與朋友們討論，或是大家直接忘記有月曜日のたわわ可以看。 為了改善這個問題。朋友開發出了 TawawaBot。使用 Telegram bot開發是因為我們主要用 Telegram 聯繫彼此，不過同學是使用 Twitter API v1.1 開發，現在已經有 v2.0 的 API。且同學使用的平台 heroku 最近不知為何，經常會發生問題而使 bot 無法正常執行，月曜日的動力就這樣不見了。 基於下列兩個原因，才有了這個應用的誕生， 第一點是想用 Twitter API v2，因為不知道 v1.1 何時會被棄用而無法運作。 第二點是想使用 Github Actions，一來是我不必另外準備環境，開發完成後，透過 Github Action 就會自動執行；二來是不用一直開啟設備，只要在週一的早上 Action 即可，降低一些資源的使用量。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:0:0","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"建立帳號 前面提到了三個服務，理所當然的要建立三個服務的帳號。 Telegram Twitter Github ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:1:0","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"Telegram bot 基本上當您建立好帳號後，我們要做兩件事情： 透過 BotFather 建立 bot。 取得自己的 UserID，或是群組的 ChatID。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:2:0","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"建立 bot 建立 bot 的方式很簡單，請找 BotFather 使用下面三招： /newbot 輸入 bot 的顯示名稱( name ) 輸入 bot 的 ID，這邊要注意的是必須以 Bot 或是 _bot 做為結尾，建立完成後會給您這個 bot 的 token，請盡量不要給任何人這個 token，當有這個 token 就可以任意存取你的 bot。 建立完成後，應該會看到這樣的訊息。\" 建立完成後，應該會看到這樣的訊息。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:2:1","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"取得 UserID 與 ChatID(group) 取得 UserID 的方式，先向自己剛剛建立的 bot 傳送一個簡單的訊息，然後更改下面的 url 並透過瀏覽器瀏覽，就可以得到 UserID。 # YourBOTToken 改成 剛剛拿到的 token，前後的\u003c\u003e符號要拿掉。 https://api.telegram.org/bot\u003cYourBOTToken\u003e/getUpdates 至於 chatID，則是要先將 bot 邀請到群組內，如果是管理員就直接加入即可，如果不是管理員，請有禮貌地向管理員說明。加入後簡單傳個訊息，並透過上述的方法，就能夠取得 chatID。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:2:2","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"建立 Twitter 開發專案 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:3:0","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"Sign up Twitter Developer Platform 我們先到這裡 Sign up，接著應該會導入您剛剛註冊 Twitter 的資訊。並填寫其他資訊。 關於 What’s your use case? 這個問題，因為我們是要製作 bot ，所以選擇 Making a bot 這個選項即可。 Info 這個選項請不要亂填，若審核沒過，這個帳號以後就不能再申請的樣子。 關於 Will you make Twitter content or derived information available to a government entity or a government affiliated entity? 這個問題，選擇 No 即可。 接著就是開發者的協議與政策，請閱讀過後點選下方的 checkbox。我知道很多人都直接點。 這個步驟結束後，應該就可以建立 project 了。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:3:1","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"建立專案並取得 bearer token 請到 Developer Portal 並建立 Project 與 APP，建立完成後應該會給您 bearer token 與其他的 token，但我們只需要使用 bearer token 即可 如果忘記了，進入 APP 後點選 Key and Tokens 的標籤頁，點選 regenerate 後會重新產生一組 bearer token 給您。 Warning token 務必保存好不要外流，有這個 token 就可以對你的 APP 做一些壞壞的事。 忘記了嗎？點黑底白字的不是點白底黑字的唷\" 忘記了嗎？點黑底白字的不是點白底黑字的唷 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:3:2","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"Github Actions Github Actions 可以用來自動化、自定義和執行您的軟體開發工作流程，許多人用來做 CI/CD使用。 基本上每一個 Job 可以執行 6 小時，透過 twitter stream 來接收比村老師的推文已經足夠了。 另外有 cron 功能，可以安排行程在我們想要的時間執行，不過時間不太準確就是了。（我設定九點執行，實際到了十點多才執行呢～） ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:4:0","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"workflow/main.yml 先在 github 上建立一個專案，待會要設定 Github Actions 進行 schedule 的相關設定。 建立完成後，請到專案的 Actions，點選 “New workflow”，會進入到 Choose a workflow 這個頁面，直接點選下方的 \" set up a workflow yourself “，此時 Github 會自動幫你建立一個新的 main.yml，待會就是要編輯這個檔案，透過 Github Actions 進行排程與相關的工作。 我這邊直接提供我的 main.yml 給各位。 連結 如果有使用我的 main.yml，建議先把下列兩行反註解，這樣每一次 push 時都會即時進行 Action，等確認沒問題再註解即可。 # push: # branches: [ main ]另外，Telegram bot 傳送的部分訊息由該檔案產生，要修改傳送的訊息，請修改這裡與後續 Twitter Stream 使用到的程式碼。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:4:1","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"Secrets and Environments 前面提到的 userID(chatID), telegram bot token 與 twitter bearer token，因為這些 token 直接放到 repo 中，就是赤裸裸地給人家看。 Github 提供了 Secret 功能，Secret 是在 repo 中的加密環境變數，可以在 Github Actions 中做使用而不被其他人知道。 請到專案中的 setting 並點選左方的 Secrets -\u003e Actions，並依照以下名稱建立三個 secrets。 TELEGRAM_TO : Your telegram userId or chatId. TELEGRAM_TOKEN : Your telegram bot token. TWITTER_BEARER_TOKEN : Your twitter bearer_token. Tips 因為 main.yml 我已經寫好的關係，這裡有要求名稱。使用上是可以更改名稱的，只要 main.yml 內的變數與 Repository secrets 有符合即可。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:4:2","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"Twitter Stream Twitter API 會透過 Stream 的方式，即時地把符合規則的 tweet 經過 stream 送給我們。 我直接提供我的的 code。連結 如果有要更改規則，請修改 set_rules() 這個函式內的規則。規則可以參考官方文件。 如果想對推文內容進行進一步的過濾，可以到 get_stream() 內修改成更詳細的規則。 Telegram bot 發送的訊息由這個程式產生，若想要修改的話，請修改 fp.write() 的傳入參數內容即可。 測試時，先建議把規則改成自己的 twitter ID 再上傳程式，確認 Github Actions 正常執行後，再推一篇符合規則的 tweet， Telegram bot 應該就會發送 tweet 的內容。 完成了，期待週一吧！ 如果你看到類似的訊息，代表你的程式正常。\" 如果你看到類似的訊息，代表你的程式正常。 ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:5:0","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Application"],"content":"Reference 我的朋友 : MDSK-UltraIN How to Create telegram bot StackOverflow - Telegram Bot - how to get a group chat id? Twitter developer Documentation Filtered stream Using environments for deployment Encrypted secrets 使用或參考的 packages： MDSK-UltraIN/TawawaBot_forTelegram twitterdev/Twitter-API-v2-sample-code theskumar/python-dotenv appleboy/telegram-action ","date":"2022-03-14","objectID":"/posts/application/catchtawawa/:6:0","tags":["Github Actions","Telegram bot","Twitter"],"title":"星期一就憂鬱？每週透過 Github Actions, Telegram bot 與 Twitter stream 給你豐滿的星期一","uri":"/posts/application/catchtawawa/"},{"categories":["Go"],"content":"本篇文章會簡單介紹指標，並學習如何使用指標與記憶體空間，使程式執行上能更有效能。 ","date":"2022-03-07","objectID":"/posts/go/06_pointer/:0:0","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/06_pointer/"},{"categories":["Go"],"content":"Pointer ","date":"2022-03-07","objectID":"/posts/go/06_pointer/:1:0","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/06_pointer/"},{"categories":["Go"],"content":"簡介 學習 pointer 的第一條規則 ： 不要害怕 ！！ pointer 是一種 variable，他的內容是儲存另一個 variable 的 address，Address 則是每一個 variable 儲存在一個或多個連續的記憶體位置。 不同類型的 variable 會佔用不同的記憶體空間，像是 bool 只要一個 byte 就能代表 true 或 false，(因為可以獨立尋找 address 的最小空間是 byte)，而 int32 需要 4 個 byte 的儲存空間。 雖然不同類型的 variable 可以佔用不同的記憶體空間，但每個 pointer 無論指向任何類型的 variable，都會是相同的大小。 var x int32 = 10 var y bool = true pointerX := \u0026x pointerY := \u0026y var pointerZ *string pointerX 會是 x 的 address pointerY 會是 y 的 address pointerZ 不會指向任何東西，Value 會是 Zero value。 而 pointer 的 Zero value 是 nil 而不是 0，與 C 語言的 null 不同， nil 不代表 0，故不能將 nil 轉換成 0。 ","date":"2022-03-07","objectID":"/posts/go/06_pointer/:1:1","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/06_pointer/"},{"categories":["Go"],"content":"運算符 基本上 golang 的 pointer 運算符與 C/C++ 的相似。 \u0026 : address operator，用在變數前的話，會返回該變數的 address。 * : indirection operator，用於指針變數，會返回該 pointer 指向的 value。也被稱為 dereferencing。 x := 5 pointerX := \u0026x y := 5 + *pointerX fmt.Println(y) // 10 dereferencing 要確保 pointer 不是 nil，否則會造成 panic。 var x *int fmt.Println(*x) // panic ","date":"2022-03-07","objectID":"/posts/go/06_pointer/:1:2","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/06_pointer/"},{"categories":["Go"],"content":"指標類型 其實就是有一種類型叫做指標類型啦。用來表示 pointer，基本上可以基於任何類型。 x := 10 var pointerX *int pointerX = \u0026x 另外透過 new 聲明一個指針變數時，他的初始值會是 0 而不是 nil。 var x = new(int) fmt.Println(*x) // prints 0 ","date":"2022-03-07","objectID":"/posts/go/06_pointer/:1:3","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/06_pointer/"},{"categories":["Go"],"content":"傳遞(call) ","date":"2022-03-07","objectID":"/posts/go/06_pointer/:2:0","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/06_pointer/"},{"categories":["Go"],"content":"簡介 當原始值分配給另一個變數或傳遞給 function or method 時，對其他變數所做的任何更改都不會反映在原始值中。 // Java int x = 10; int y = x; y = 20; System.out.println(x); // prints 10 然而在透過類型所建立的 instance，分配給另一個 instance 或傳遞給 function or method 時，又會是不同的結果。 // python class Foo: def __init__(self, x): self.x = x def outer(): f = Foo(10) inner1(f) print(f.x) inner2(f) print(f.x) g = None inner2(g) print(g is None) def inner1(f): f.x = 20 def inner2(f): f = Foo(30) outer() // Output 20 20 True 在許多程式語言中(e.g. Java, Python)，會有以下特性： 如果將 instance 傳遞給函式並更改 field 的值，則這次更改會反映在傳遞進去的 instance。 如果重新分配參數，則更改不會反應在傳遞進去的變數。 如果傳遞 nil/null/None 等參考值，會將傳入參數本身設定為新的數值，而不會影響原先原先的數值。 因為這些語言的 instance 是透過 pointer 實現的，當 instance 傳遞給 function 或是 method 時，被複製的數值是指向該 instance 的 pointer。在 inner1 是指向相同的 address，而在 inner2 則是建立一個新的 instance，會指向不同的 address，因此不會影響到原先傳入的 instance。 基本上在 golang 中，會有一樣的特性，但 golang 不同的是可以對原始類型與架構使用 pointer 或是 value。 ","date":"2022-03-07","objectID":"/posts/go/06_pointer/:2:1","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/06_pointer/"},{"categories":["Go"],"content":"傳遞 pointer 上篇文章提到，golang 是 call by value，但可以透過將 pointer 傳遞給函式的方式，使原始變數被函式進行修改。只不過有幾點是要注意的。 如果傳遞 nil pointer，則不能將數值修改為非 nil。如果已經將該 pointer 分配了一個數值，則只能 reassign 這個數值。因為 call by value 的關係，會複製一份 pointer 變數，並在函式內處理，而原先的 pointer 當然就不會被函式修改到。 func failedUpdate(g *int) { x := 10 g = \u0026x } func main() { var f *int // f is nil failedUpdate(f) fmt.Println(f) // prints nil } 如果希望 pointer 參數傳入後修改的值在退出函式時仍然存在，不要在函式內建立一個新的變數並透過修改 pointer 來修改，而是透過 pointer 指向要修改的數值並進行修改。 func failedUpdate(px *int) { x2 := 20 px = \u0026x2 } func update(px *int) { *px = 20 } func main() { x := 10 failedUpdate(\u0026x) fmt.Println(x) // prints 10 update(\u0026x) fmt.Println(x) // prints 20 } ","date":"2022-03-07","objectID":"/posts/go/06_pointer/:2:2","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/06_pointer/"},{"categories":["Go"],"content":"小心使用 基本上在 golang 是不建議使用 pointer，會影響數據傳遞的理解，除了在某些情況下使用會好些，例如在使用函式時需要一個 interface、部分類型需要以指針傳遞、數據類型中存在需要修改的狀態，會建議返回值使用指針類型。 ","date":"2022-03-07","objectID":"/posts/go/06_pointer/:2:3","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/06_pointer/"},{"categories":["Go"],"content":"效能 不過，pointer 的好處是無論任何的類型，pointer 都會是一樣的大小，也就是說當我們傳遞大的數值給函式時，花費的時間也會較多，但傳遞 pointer 則會減少原先所需傳遞的時間。 ","date":"2022-03-07","objectID":"/posts/go/06_pointer/:2:4","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/06_pointer/"},{"categories":["Go"],"content":"Slice 上一篇我們提到，Map 與 Slice 是以 pointer 實現的，故直接傳遞 Map 與 Slice 給函式是可以直接修改數值的，這邊提一下 Slice ，在函式內雖然可以修改內部數值，但不能修改 slice 的容量。 Slice 基本上為三個單元所組成： 資料，以 pointer 指向某一段記憶體空間。 長度，使用了多少空間。 容量，這個 slice 總共有多大。 因為 call by value 的關係，傳遞至函式內的 slice 會被複製，因為資料是以 pointer 指向某一段記憶體空間，所以可以直接修改，但容量部分只會修改函式內被複製的這份 slice，因此原先的 slice 並不會被修改到容量。 另外，slice 也很適合作為 buffer 使用，後面的文章會再提起 slice。 ","date":"2022-03-07","objectID":"/posts/go/06_pointer/:2:5","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/06_pointer/"},{"categories":["Go"],"content":"Garbage Collector Garbage 是指沒有 pointer 指向該筆數據，則代表該數據存在記憶體空間中但沒有做使用，該數據就是 Garbage，這些空間就會被拿來重新使用，避免記憶體使用量一直增加。 Golang 有 Garbage Collector，但不代表可以隨性的使用記憶體空間。因為 Garbage Collector 也是需要資源去處理這些 Garbage，會降低程式的效能。 另外， Golang 會將原始類型、結構等放至 stack 中，並順序排列，透過建立最少的 Garbage，達到低延遲的目標。 寫著寫著發現 Stack, Garbage Collector 是個坑，之後有空可能會另外寫一篇出來吧。 後面會附上一些連結，有興趣的話可以參考。 ","date":"2022-03-07","objectID":"/posts/go/06_pointer/:3:0","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/06_pointer/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) Getting to Go: The Journey of Go’s Garbage Collector Memory Bandwidth Napkin Math Language Mechanics On Stacks And Pointers Allocation efficiency in high-performance Go services ","date":"2022-03-07","objectID":"/posts/go/06_pointer/:4:0","tags":["go","golang"],"title":"Golang - 指標(Pointer)","uri":"/posts/go/06_pointer/"},{"categories":["Go"],"content":"本篇文章會說明如何使用 golang 撰寫函式，瞭解傳入值與返回值，介紹匿名函式與defer，並瞭解可以對函式所做的事情。 坦白說書對於這個章節寫的有點模糊，好啦其實是我自己理解能力差，這次看了不少 reference，若以後覺得還有要補充的地方會補上。 ","date":"2022-02-26","objectID":"/posts/go/05_functions/:0:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/05_functions/"},{"categories":["Go"],"content":"宣告與使用函式 基本上宣告函式與其他程式語言幾乎相同，聲明會有四個部分： keyword, func 函數名稱 輸入參數 返回類型 func example(input int) int { fmt.Println(\"This is example.\") return 0 } 如果說這個函式沒有傳入參數，則小括號裡面則不需要填寫任何參數；如果說這個函式不會有任何的返回值，則宣告時也不需要寫返回類型。常使用的 main() 函式就是一個很好的例子。 func main(){ fmt.Println(\"Hello world\") } 若有許多傳入參數，且都為同一種類型時，可以稍微省略一些輸入參數的類型，但我是不建議就是了，每一個參數都寫清楚，後續維護會比較好處理一些。 func example(number1, number2 int) int { return number1+number2 } ","date":"2022-02-26","objectID":"/posts/go/05_functions/:1:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/05_functions/"},{"categories":["Go"],"content":"具名與選擇性參數 (named and optional) 基本上許多程式語言都具有這兩個性質，但在 golang 中並沒有這兩個性質，基本上 golang 要求你宣告的輸入參數，全部都要使用（但也有例外）。 具名參數：用於識別傳入參數為何。許多情況下我們會傳入很類似的參數，透過具名參數的方式較容易識別。 選擇性參數：代表這個參數是選擇性傳入的，宣告函式時，選擇性參數必須擺在後面。若要選擇多個選擇性參數使用時，可以使用具名參數。 雖然 golang 無法使用這兩種參數，但可以用模擬的方式。 首先要訂一個 struct，代表這個函式會使用到的所有參數： type MyFuncOpt struct { FirstName string LastName string Age int } 接著，宣告函式時要使用前面宣告的 struct 作為傳入參數。使用時則傳入所需的數值即可。 func MyFunc(opts MyFuncOpt) error{ // do something } // 可以由外部傳入值 var i int = 55 // How to use. func main() { MyFunc(MyFuncOpts{ FirstName: \"Joe\", Age: i, }) } ","date":"2022-02-26","objectID":"/posts/go/05_functions/:2:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/05_functions/"},{"categories":["Go"],"content":"可變參數 Golang 支援可變參數，可以允許任意數量的輸入參數。可變參數必須是函式聲明時的唯一一個參數，或是最後一個參數，並在類型前面加上 ...表示，這時會以這個類型的 slice 表示這個參數。 func number(base int, value ...int) int{ //do something. } 上述的例子中， value 已經是一個類型為 int 的 slice，所以也可以傳 slice 給他，只是說傳入時要在後面加上 ... 才能使用，否則會發生編譯錯誤。 number(1, []int{2,3,4,5}...) ","date":"2022-02-26","objectID":"/posts/go/05_functions/:3:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/05_functions/"},{"categories":["Go"],"content":"多個返回值 Golang 的一個特色是，允許多個返回值。 func number(base int, value int)(int,int){ return base+value, base*value } 宣告函式時，多個返回值的類別需要以括號包起來，並以逗號隔開；函式內回傳值則是以逗號隔開即可。 多個回傳值則需要分配給多個變數，或是都被使用到，而不能像 python 一樣只分配給一個變數，因為 golang 多個回傳值就是回傳多個，不是像 python 一樣回傳一個數組。 numbers := number(1,2) // error number1, number2 := number(1,2) // success 返回值也是可以被具名的(named)，在宣告返回值類別時就都要加上括號，即便只有一個返回值也是，若只想命名部分的返回值，可以使用 _。另外具名的返回值可以分配在不同名稱的變數上，沒問題的。 func number(base int, value int)(ans1 int, ans2 int, _ int){ ans1, ans2 = base+value, base*value ans3 := 0 return ans1,ans2,ans3 } 不過，即使命名了返回值，也不代表一定要返回該值，golang 是允許不返回命名返回值的。使用上請小心，因為編譯器會將 return 的值分配給命名的返回值。 func number(base int, value int)(ans1 int, ans2 int, _ int){ ans1, ans2 = 1,2 ans3 := 0 return base+value,base*value,ans3 } func main(){ fmt.Println(number(5,2)) } // Output 7 10 0 ","date":"2022-02-26","objectID":"/posts/go/05_functions/:4:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/05_functions/"},{"categories":["Go"],"content":"空白返回 (Blank returns) 空白返回適用在當我們命名了所有的返回值時，可以直接使用 return 而返回數值，不需要在 return 後面補上變數。 func number(base int, value int) (ans1 int, ans2 int) { ans1, ans2 = 1, 2 return } 雖然會節省許多時間，但維護上會很困擾。因為要去尋找返回值是從哪裡返回的，當函式一長，或是有多個 return，由判斷式決定的函式，看到都是 return，頭會很痛。 // 舉一個超超超簡單的例子。 func number(base int, value int) (ans1 int, ans2 int) { return // ???????? 哦哦回傳 zero value } func main(){ fmt.Println(number(5,2)) } // Output 0 0 ","date":"2022-02-26","objectID":"/posts/go/05_functions/:5:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/05_functions/"},{"categories":["Go"],"content":"匿名函式 在函式中定義新函式，並將其分配給新的變數。而這些內部的新函式則是匿名函式。宣告方式基本上與一般函式相同，主要的差別在匿名函式不需要命名。使用時在後面用小括號傳入變數即可。 func main() { for i := 0; i \u003c 5; i++ { func(j int) { fmt.Println(\"printing\", j) }(i) } } //output printing 0 printing 1 printing 2 printing 3 printing 4 但我在 for loop 使用 fmt.Println() 就好了，直接使用內部的程式碼不是更好嗎？匿名函式的好處在哪裡呢？後續會在 defer 與 launching goroutines 這兩種情境中提到，匿名函式在這兩種情境中會是有用的。 ","date":"2022-02-26","objectID":"/posts/go/05_functions/:6:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/05_functions/"},{"categories":["Go"],"content":"Closures ","date":"2022-02-26","objectID":"/posts/go/05_functions/:7:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/05_functions/"},{"categories":["Go"],"content":"介紹 中文翻譯好像稱為閉包 (不喜歡)，Closures 可以限制函式的使用範圍，如果一個函式只會被另一個函式使用，但他會被多次使用，可以使用一個內部函式隱藏被使用的函式，正常函式呼叫完後內部的變數就會銷毀，但閉包卻能使本該銷毀的變數一直保留。 func intSeq() func() int { i := 0 return func() int { i++ return i } } func main() { nextInt := intSeq() fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) newInts := intSeq() fmt.Println(newInts()) } // Output 1 2 3 1 宣告一個 intSeq 的函式，返回值是函式，函式內第一個 return 使用了外部的 i，使得這個匿名函式成為了 Closures，而 i 則會被保留狀態並等待下次使用。 tips : 把函式想成一個數值會比較好理解，而運作方式也的確是如此。 ","date":"2022-02-26","objectID":"/posts/go/05_functions/:7:1","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/05_functions/"},{"categories":["Go"],"content":"從函式返回函式 不只是能返回變數的狀態，也能夠返回函式的 closure： func makeMult(base int) func(int) int { return func(factor int) int { return base * factor } } func main() { twoBase := makeMult(2) for i := 0; i \u003c 3; i++ { fmt.Println(twoBase(i)) } } // Output 0 2 4 twoBase 的值是 makeMult(2) (記得函式也是一個數值的想法)，此時賦予 base 為 2。後面的 for loop 時，因為對於 twoBase 傳入了數值，故回傳內部的匿名函式。 ","date":"2022-02-26","objectID":"/posts/go/05_functions/:7:2","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/05_functions/"},{"categories":["Go"],"content":"defer 通常使用 defer 是用來釋放資源，程式運作時需要常常釋放資源，例如開啟文件後要關閉，或是網路連線完成後，透過 defer 進行清理的工作。通常擺在函式的後面，與其他語言的 finally 相似。 func main() { f := createFile(\"/tmp/defer.txt\") defer closeFile(f) writeFile(f) } func createFile(p string) *os.File { fmt.Println(\"creating\") f, err := os.Create(p) if err != nil { panic(err) } return f } func writeFile(f *os.File) { fmt.Println(\"writing\") fmt.Fprintln(f, \"data\") } func closeFile(f *os.File) { fmt.Println(\"closing\") err := f.Close() if err != nil { fmt.Fprintf(os.Stderr, \"error: %v\\n\", err) os.Exit(1) } } // output creating writing closing 比方說要產生一個檔案，並寫入檔案後關閉對該檔案的存取，但我們在 main 中撰寫的順序是 createFile, closeFile，最後是 writeFile，但因為 defer 的關係， closeFile會在函數結束前執行。 補充一下 defer 的事情： 可以透過 defer 在函式中使用多個 closure，會以先入後出的方式進行，最後使用 defer 的會先運作。 defer 會是在 return 之後運行的。 defer 會造成延遲，若是要求速度至上的程式，請盡量減少使用。 defer 另一個好處是，可以用來檢查或修改返回值。且這也是前面提到命名返回值的理由。 // 書裡面的例子。 func DoSomeInserts(ctx context.Context, db *sql.DB, value1, value2 string) (err error) { tx, err := db.BeginTx(ctx, nil) if err != nil { return err } defer func() { if err == nil { err = tx.Commit() } if err != nil { tx.Rollback() } }() _, err = tx.ExecContext(ctx, \"INSERT INTO FOO (val) values $1\", value1) if err != nil { return err } // use tx to do more database inserts here return nil } 函式最後會回傳一個 error 類型的 err 變數，此時中間的 defer 會對這個數值進行判斷，如果沒有錯誤，則會提交，如果有錯誤的會則會 rollback。 ","date":"2022-02-26","objectID":"/posts/go/05_functions/:8:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/05_functions/"},{"categories":["Go"],"content":"Call by Value 當我們傳遞變數至函數時， Golang 會將變數的值複製並傳遞進去。函式並不會改變該變數原本的數值。與其他語言不同的地方是，即使是傳遞一個 struct 至參數內，也不會改變在外部 struct 內的數值。 然而，傳遞 map 與 slice 進入參數時，函式進行修改是會影響到外部變數內的數值的，因為 map 與 slice 是用 pointer 實現的，對這個 pointer 所指的數值進行修改，就會影響到外部變數的數值。另外，傳遞至函式內的 slice，是無法延長的。 若我們需要像是 int, string 類型的變數進入函式進行修改時，要怎麼做呢？ pointer !! ","date":"2022-02-26","objectID":"/posts/go/05_functions/:9:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/05_functions/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) 具名和選擇性引數 (C# 程式設計手冊) More on Functions 談談我所理解的閉包，js、php、golang裡的closure Go by Example: Closures Go初識-day10-閉包(closure) Go by Example: Defer ","date":"2022-02-26","objectID":"/posts/go/05_functions/:10:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/05_functions/"},{"categories":["Go"],"content":"本篇文章將介紹 Block 與 Shadows，接著會說明控制結構（if、for、goto）等。 ","date":"2022-02-25","objectID":"/posts/go/04_blocks_shadows_controlstructure/:0:0","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/04_blocks_shadows_controlstructure/"},{"categories":["Go"],"content":"Code Blocks ","date":"2022-02-25","objectID":"/posts/go/04_blocks_shadows_controlstructure/:1:0","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/04_blocks_shadows_controlstructure/"},{"categories":["Go"],"content":"Types of blocks 其實用 blocks 作為關鍵字去尋找相關資訊並不太好找，反倒是以 Code Blocks 會比較容易些，基本上有聲明的地方，都會被稱為 blocks，在任何函數以外聲明的常數、變數、類型與函數都是放在 package block 內。而使用 import 內的時statement時，這些名稱則是放在 file block。 在 golang 中，有四種 blocks： universe block，包含了整個 project 的 source code。 package block，每一個 package 都有一個包含全部 code 的 block，但並不包含聲明。 file block，每一個 file 都有一個包含全部 code 的 block，也包含了聲明。 local blocks，基本上，在一個函數中，每一個大括弧 {} 都定義了一個 block。 local blocks 又分為 explicit local blocks 與 implicit local blocks，基本上要由 {} 與控制結構識別。 ","date":"2022-02-25","objectID":"/posts/go/04_blocks_shadows_controlstructure/:1:1","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/04_blocks_shadows_controlstructure/"},{"categories":["Go"],"content":"Hierarchies 透過圖片，會更了解 block 之間的層次結構。 ","date":"2022-02-25","objectID":"/posts/go/04_blocks_shadows_controlstructure/:1:2","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/04_blocks_shadows_controlstructure/"},{"categories":["Go"],"content":"Shadows 我們隨時可以從內部 block 訪問外部 block 的 identifer，如果內部與外部有相同的 identifer 時，會發生什麼事呢？ ","date":"2022-02-25","objectID":"/posts/go/04_blocks_shadows_controlstructure/:2:0","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/04_blocks_shadows_controlstructure/"},{"categories":["Go"],"content":"Shadowing variables func main() { x := 10 if x \u003e 5 { fmt.Println(x) x := 5 fmt.Println(x) } fmt.Println(x) } 可以先想一下這個函式的 blocks，再來想一下這個程式會印出什麼。在這個函式中發生了內部與外部的 identifer 相同的情況，此時外部的 identifer 會被隱藏。印出來的結果會是： 10 5 10 Shadowing Variable 是指在 package block 中的 variable 相同名稱的 variable，只要 Shadowsing variables 存在，就不能由外部訪問 Shadowing variables。該函式首先定義了 x 為 10，後來有一個 if statement，並遇到了大括號，記得前面說的每一個大括弧會是一個 block，這個 statement 內的 x 則是 shadowing variable，當離開這個 statement 時，這個 shadowing variable 就不能被訪問，故最後的 fmt.Println() 會是訪問頂部的 x 。 若善用 shadowing variables 在測試或是懶得想變數時會很方便，但記得使用的 identifer，若使用不慎可是會出問題的。 func main() { x := 10 fmt.Println(x) fmt := \"oops\" fmt.Println(fmt) } // Output fmt.Println undefined (type string has no field or method Println) 這個例子中，fmt 被聲明為 local variable，故會隱藏原先 fmt 所擁有的函式，也因此會有錯個錯誤發生。 個人認爲在測試內使用 shadowing variable 即可，開發的專案就不建議。 ","date":"2022-02-25","objectID":"/posts/go/04_blocks_shadows_controlstructure/:2:1","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/04_blocks_shadows_controlstructure/"},{"categories":["Go"],"content":"Detect 還記得在第一章提到的 vet 與 lint 可以做檢測用，但是 go vet 與 golangci-lint 是沒有檢測 shadow 的功能的(寫這篇文章時應該是沒有吧…)，但的確是有 shadow detect 工具可以使用的。 go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow@latest ","date":"2022-02-25","objectID":"/posts/go/04_blocks_shadows_controlstructure/:2:2","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/04_blocks_shadows_controlstructure/"},{"categories":["Go"],"content":"Control Structures Control Structures 其實跟許多語言的用法極為相似，但 golang 有一個與眾不同的 goto 可以使用。 ","date":"2022-02-25","objectID":"/posts/go/04_blocks_shadows_controlstructure/:3:0","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/04_blocks_shadows_controlstructure/"},{"categories":["Go"],"content":"if if 的用法也與其他語言的用法相似 (很懶得寫)， if 的 condition 不用括號刮起來。 n := rand.Intn(10) if n == 0 { fmt.Println(\"That's too low\") } else if n \u003e 5 { fmt.Println(\"That's too big:\", n) } else { fmt.Println(\"That's a good number:\", n) } 主要提一點是，條件式內可以宣告變數的。 if n := rand.Intn(10); n == 0 { fmt.Println(\"That's too low\") } else if n \u003e 5 { fmt.Println(\"That's too big:\", n) } else { fmt.Println(\"That's a good number:\", n) } 在第一句的部分，我們新宣告了一個變數，後續的條件式則可以直接透過這個新的變數進行判斷。在某些場合會很好用。 但使用 if/else 時，請盡量將條件簡單化，另外是在 if statement 中宣告的變數，也是 shadowing variables，注意聲明的名稱與使用方式。 ","date":"2022-02-25","objectID":"/posts/go/04_blocks_shadows_controlstructure/:3:1","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/04_blocks_shadows_controlstructure/"},{"categories":["Go"],"content":"for for 基本上也與其他語言一樣，作為循環使用，在 golang 中，for 有四種使用方式 標準型 for 條件型 for 無窮型 for for-range 標準型 for for i := 0; i \u003c 10; i++{ fmt.Println(i) } 這就像許多語言的用法一樣，有一個初始值，一個需要滿足的條件式，跟一個會遞增或遞減的行為，這個行為會在每一次的迴圈結束後進行。 條件型 for i := 0 for i \u003c 100 { fmt.Println(i) i = i + 1 } 條件型的 for 省略了初始值與行為，但仍須保留條件式。 無窮型 for for{ fmt.Println(\"Hello!\") } 取消了條件，亦同這個 for 會一直滿足且運作下去，當然也可以使用標準型或是條件型 for 達到相同的目的。如果要程式運作時需要結束這個無窮型迴圈，設計時可以使用條件式與 break 跳出這個 for。 i := 0 for{ i = i + 1 if i \u003e 10 { break } } for-range 通常像其他語言的迭代器(iterator) 我以前學不好的部分， for-range 常用在 string, array, slice 和 map 上。 evenVals := []int{2, 4, 6, 8, 10, 12} for i, v := range evenVals { fmt.Println(i, v) } // Output 0 2 1 4 2 6 3 8 4 10 5 12 用 for-range 會得到兩個變量，一個通常被稱為index或是key，我在這邊稱為位置，另一個則是該位置的數值。 如果不需要位置時，可以使用下底線進行隱藏。 evenVals := []int{2, 4, 6, 8, 10, 12} for _, v := range evenVals { fmt.Println(v) } // Output 2 4 6 8 10 12 如果需要位置而不需要值時，使用下底線嗎？也可以，但可以直接省略。 evenVals := []int{2, 4, 6, 8, 10, 12} for i := range evenVals { fmt.Println(i) } // Output 0 1 2 3 4 5 for-range 在遍歷 map 上會有特別的地方，會有每一次遍歷的順序結果不同的情形，這是 go 語言為了安全的設計，每一次的 for-range 迭代在遍歷 map 會有不同的結果。 for-range 所遍歷的會是一個副本而不是原變數的值，故在這個副本內修改的，並不會影響到原本的數值。 ","date":"2022-02-25","objectID":"/posts/go/04_blocks_shadows_controlstructure/:3:2","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/04_blocks_shadows_controlstructure/"},{"categories":["Go"],"content":"Continue continue 是用來跳過剩餘的部分，並進行下一次的迭代。用起來也與其他語言相似，但有一個特別的用法，透過 OUTER 標籤進行的 for。 OUTER: for _, item := range list.Items { for _, reserved := range reserved.Items { if reserved.ID == item.ID { continue OUTER } ... do some other work ... } ... do some other work ... } 透過這種方式，可以跳出或跳過外部循環的迭代器。聽說這種方法很少用就是了 ","date":"2022-02-25","objectID":"/posts/go/04_blocks_shadows_controlstructure/:3:3","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/04_blocks_shadows_controlstructure/"},{"categories":["Go"],"content":"switch Nintendo Switch !! switch也是很常在其他語言中看到的 statement，用法也相似，很多人不喜歡使用 switch (我自己也是)，但 switch 在 go 語言中有一些令人驚訝的地方(?) words := []string{\"a\", \"cow\", \"smile\", \"gopher\",\"octopus\", \"anthropologist\"} for _, word := range words { switch size := len(word); size { case 1, 2, 3, 4: fmt.Println(word, \"is a short word!\") case 5: wordLen := len(word) fmt.Println(word, \"is exactly the right length:\", wordLen) case 6, 7, 8, 9: default: fmt.Println(word, \"is a long word!\") } } 多個 case 要進行相同的邏輯，可以在同一個 case 寫多個條件。 每一個 case 都會是一個 block，像是 case 5 的 wordLen 是一個新的 variable，只能在這邊使用。 不必再每個 case 後面加上 break， go 只會進行符合的 case。 如果沒有滿足 case，不會發生任何事。或是使用 default 決定沒有滿足 case 時需要做什麼。 通常使用 break 代表要跳出這次的 switch。但與其他語言不同，在 case 底下使用 break，go 只會認為你想跳出該 case 而不是 switch，若需要跳出 switch 需搭配 label 做使用。使用方式如下列的程式碼： loop: for i := 0; i \u003c 10; i++ { switch { case i%2 == 0: fmt.Println(i, \"is even\") case i%3 == 0: fmt.Println(i, \"is divisible by 3 but not 2\") case i%7 == 0: fmt.Println(\"exit the loop!\") break loop default: fmt.Println(i, \"is boring\") } } ","date":"2022-02-25","objectID":"/posts/go/04_blocks_shadows_controlstructure/:3:4","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/04_blocks_shadows_controlstructure/"},{"categories":["Go"],"content":"goto 簡單介紹一下就好，如同字面上的意思，會去到程式的某個地方。但因為 goto 接近為所欲為，想去哪就去哪，在撰寫程式、運作與維護頗為麻煩 (自己廢就說)，通常會被用在要跳過程式某些部分或是跳出迴圈、switch 等，並執行程式後面的部分時使用。 func main() { a := rand.Intn(10) for a \u003c 100 { if a%5 == 0 { goto done } a = a*2 + 1 } fmt.Println(\"do something when the loop completes normally\") done: fmt.Println(\"do complicated stuff no matter why we left the loop\") fmt.Println(a) } tips : 非必要，盡量盡量不要使用 goto。 函式內可以提的內容應該都說明了，這章應該還有些東西可以補充，但可能之後想到比較容易解釋的方式，或是例子，再回來補充。 ","date":"2022-02-25","objectID":"/posts/go/04_blocks_shadows_controlstructure/:3:5","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/04_blocks_shadows_controlstructure/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) Code Blocks and Identifier Scopes Continue statements with Labels in Go (golang) Golang switch case 用法 ","date":"2022-02-25","objectID":"/posts/go/04_blocks_shadows_controlstructure/:4:0","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/04_blocks_shadows_controlstructure/"},{"categories":["blog"],"content":"本篇文章會簡單介紹 algolia search，並且說明如何在 LoveIt 上啟用 Algolia search。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:0:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Algolia search ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:1:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"介紹 Algolia search的宗旨是提供一個快速的搜尋體驗，並提供適用於多種不同 stack 的文件與工具，可以快速的建構搜尋功能，且搜尋功能只要利用 API 建立，不必花費太多時間建構。 另外可以分析搜尋結果，了解用戶到自己的網站搜尋了些甚麼，透過這些結果，可以自行定義，或是由 Algolia 自動生成較佳的搜尋規則。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:1:1","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"優點 速度非常快。Algolia Search 基本上是將網站建立索引(index)，並建立了分佈式搜尋網路(Distributed Search Network,DSN)，盡可能使搜尋要求送到最近的 DataCenter，降低延遲。 提供了自動建議字、自動糾正錯別字等搜尋功能，另外也支援多種語言的搜尋。 有免費的方案可以使用，雖然有些地方有所限制，但對於小型開發者而言，這個免費方案應能滿足需求。或是使用免費的 Docsearch，他是基於 algolia 的文件搜尋，不過他只能用在技術文件或是技術Blog，但我的 Blog 審核一直沒有通過，所以沒辦法使用…(應該是因為我寫的很差) ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:1:2","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"建置 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:2:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"註冊帳號 首先到 Algolia 的官方網站註冊帳號，基本上註冊的部分就不加以描述，而且我相信大家都有 Github account，algolia 也可以使用 Github 登入。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:2:1","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Key 註冊完成後，進到 Dashboard 並點選 API Keys，會獲得 Application ID，Search-Only API Key。 切記 : Admin API Key 絕對絕對絕對不要存放在任何地方。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:2:2","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Index 從 Dashboard 點選 Search，並建立一個新的 index，這個 index 可以自己任意取一個容易識別的名稱。 接下來的步驟，會用到前述提到的 Application ID、Search-Only API Key與index。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:2:3","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Algolia search config in LoveIt LoveIt 主題已經將 Algolia search 的功能製作完成，只需要輸入相對應的設定到 config.toml 中即可。 這邊附上官方的設定檔。 [params.search] enable = true # type of search engine (\"lunr\", \"algolia\") type = \"algolia\" # max index length of the chunked content contentLength = 4000 # placeholder of the search bar placeholder = \"\" # LoveIt NEW | 0.2.1 max number of results length maxResultLength = 10 # LoveIt NEW | 0.2.3 snippet length of the result snippetLength = 30 # LoveIt NEW | 0.2.1 HTML tag name of the highlight part in results highlightTag = \"em\" # LoveIt NEW | 0.2.4 whether to use the absolute URL based on the baseURL in search index absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 預設為 lunr 搜尋，請更換成 algolia。 在下方的部分，可以看到 index、appID 與 searchKey，請依據填入前述提到的數值。這裡的設定就完成，我們可以開始搜尋了。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:3:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Record 當完成設定之後，其實這個搜尋功能已經建立起來了，但是因為我們還沒上傳相關的記錄，所以 algolia search 會回傳 0 筆結果，那要如何上傳記錄呢? ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:4:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Create records 請在您的 config.toml 新增 output 屬性 : [outputs] home = [\"HTML\",\"RSS\",\"JSON\"] # Hugo 預設會生成 HTML 與 RSS，不建議刪除該兩參數，貌似會影響 Hugo 生成網頁的樣子。 設定完成後，我們執行 hugo，讓他重新建置並輸出 json，沒有意外的話會在 public 資料夾內產生一個 index.json，這個就是我們要的記錄檔，待會我們要上傳至 algolia search。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:4:1","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Upload records Dashboard -\u003e search -\u003e index -\u003e Add records 然後把剛剛產生的 json 上傳，上傳完成後應該幾秒內，你的 algolia search 就能夠搜尋到相關的結果了。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:4:2","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Auto upload 因為這個方式，當我們的 blog 有更新時，就必須手動上傳新的記錄，那能不能使用程式上傳呢 ? Ans : 官方有提供API，當然可以。 官方文件 有詳細說明使用方式與一些 example code，基本上官方文件提供的程式碼就可以滿足我們的需求。因為都使用 Hugo 了，基本上 go 的環境應該是沒問題。我這邊就使用官方提供的 go 範例做使用。 tips : 記得要更改的參數與路徑。 package main import ( \"encoding/json\" \"io/ioutil\" \"github.com/algolia/algoliasearch-client-go/v3/algolia/search\" ) type Actor struct { Name string `json:\"name\"` Rating int `json:\"rating\"` ImagePath string `json:\"image_path\"` AlternativeName string `json:\"alternative_name\"` ObjectID string `json:\"objectID\"` } func main() { client := search.NewClient(\"appID\", \"Admin API Key\") index := client.InitIndex(\"index\") var actors []Actor data, _ := ioutil.ReadFile(\"public/index.json\") _ = json.Unmarshal(data, \u0026actors) // Batching is done automatically by the API client _, _ = index.SaveObjects(actors) } 之後在 push repo 時，一併記得要執行這個更新記錄的程式即可。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:4:3","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"參考資料(Reference) Algolia LoveIt Sending Records in Batches ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:5:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"本篇文章基本上是介紹如何用 Hugo 建置 blog，並部署至 Github pages 上。 ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:0:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"前言 基本上建置這個部落格是為了紀錄自己的筆記，與自己遇到的問題和如何解決的方式，但從無到有建置一個非常麻煩，又不太想用像是 Medium 之類的網站，會少了一點自由，故想說使用框架產生靜態網頁的方式建置。 最一開始使用 Vuepress，使用了一陣子之後覺得用起來不是很順手，過了一陣子則有了換框架的想法，於是先換了 Docusaurus，因為小恐龍很可愛，沒想到 Docusaurus 對於自己來說，更難用！不到一天的使用時間，決定再次換框架，使用了 Hugo 建置，雖然搬遷很煩躁，但開始搬遷時第一個反應是： 哇塞，太快了吧！ 應該會有很長的一段時間，使用 Hugo，因此也想紀錄這些建置過程，作為自己的筆記，也希望可以分享給大家。 ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:1:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"安裝 Hugo 官方在 macOS 底下說明了使用 brew 與 port 兩種安裝方式，我會比較推薦使用 brew，如果環境是 Windows 或是 Linux 的使用者，官方文件有提到相關的安裝方式，這裡就不再加以說明。 $ brew install hugo 安裝後，可以使用 hugo version 確認是否安裝完成。 $ hugo version hugo v0.92.2+extended darwin/amd64 BuildDate=unknown 若安裝完成後，到自己的專案路徑底下建立站台專案。 ### hugo new site [sitename] $ hugo new site quickstart ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:2:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"安裝主題 (theme) Hugo 提供了許多種主題，或是到 Google 搜尋，基本上挑選自己喜歡的即可，我這邊選擇的是 LoveIt。 進入到站台專案，並使用 git 將 LoveIt 主題下載下來。 $ cd quickstart $ git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:3:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"增加內容 通常內容都會放置在專案內的 content 資料夾中，可以手動新增，也可以使用 hugo new 的方式新增，會自動在 frontmatter 補上標題與時間的資訊。 $ hugo new posts/first.md 產生檔案後，就用 markdown 語法寫文章即可，這邊要提醒一點是使用圖片的方式，要使用 HTML tag，而不能使用 ![name](url) 的方式。 \u003c!-- 請參考下面的程式碼，使用時請手動刪除 {{與\u003c 和 \u003e與}} 之間的空格。--\u003e {{ \u003cimage src=\"folder/filename\" caption=\"This is a image.\" \u003e }} ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:4:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"瀏覽 當內容新增完後，使用 hugo server -D，然後在瀏覽器輸入 http://localhost:1313/，就可以瀏覽了。 我自己會偏好使用 hugo serve -e production，使用生產環境的方式進行預覽，畢竟是要產生靜態網頁部署至 github page 做使用。只不過當directory 或是 path 更新時，會有一些問題發生，但基本上重新編譯即可。 $ hugo server -D ### Or $ hugo serve -e production ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:5:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"部署至 github 瀏覽網站並確認完畢後，首先先執行一次 hugo，這樣會在專案資料夾底下產生一個 /public，裡面的檔案就是 hugo 產生的靜態網頁內容，進入到 /public，將這些檔案 push 到自己的 username.github.io 的專案，稍等一下下後到 https://username.github.io，應該就可以看到網頁了。 cd public git init git add . git commit -m 'my first deploy' git remote add origin git@github.com:username/repo.git git push -u origin master 若對 git 不太熟悉的話 (像我)，git 與 github 的相關資訊，會附在參考資料作為參考。 基本上上傳完成且能看到網頁內容後，自己的部落格應該就完成了，往後新增或編輯文章後，就是再使用 hugo 重新產生靜態內容，並透過 git 將靜態內容上傳後即可。 後續有時間會再說明 theme 設定與一些功能的建置(SEO、algolia 與 disqus…等)。 ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:6:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"參考資料 Hugo 官方網站 Hugo quickstart Hugo themes Github pages Git 教學：如何 Push 上傳到 GitHub？ ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:7:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["Go"],"content":"本篇文章基本上是介紹 Go 的複合類型（Array, Slice, Map）與內置函式，另外會簡單介紹 struct。 ","date":"2022-02-16","objectID":"/posts/go/03_composite/:0:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"Arrays 如同其他程式語言，Go 也有 Array，Array 中的所有元素，都必須是指定的類型。 var x [3]int 此時會建立長度為 3 的 Array，但未指定初始值，上一章提到若未指定初始值，則預設值會是 Zero Value，在這個 Array 中，類型是 int，故初始值會是 0 。 若要指定初始值，則可以使用這個方式。 var x = [3]int{10,20,30} 也可以用 index 的方式指定初始值。 // index:value var x = [10]int{1,5:2} // [1,0,0,0,0,2,0,0,0,0] 若已經很明確知道，陣列內的所有數值，在宣告時則可以用 [...] 省略陣列的長度。 var x = [...]int{10,20,30} var y = [3]int{10,20,30} // 這兩個 Array 是一樣的。 在 Go 中只有一維陣列，但可以模擬出多維陣列。 var x [5][10]int 可以透過內置函式 len() 得到 Array 的長度。 fmt.Println(len(x)) 但在 Go 中，很少使用 Array，因為 Array 的大小會被視為是 Array 類型的一部分，[3]int是一種類型，[4]int是另一種類型。 因此： 不能使用變數來指定 Array 的大小，因為類型必須在編譯前解析，而不是在運作時解析。 不能使用類型轉換，無法將不同大小的 Array 轉換成相同的類型。 最好是知道需要的長度，否則盡量不要使用 Array。 ","date":"2022-02-16","objectID":"/posts/go/03_composite/:1:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"Slices 若資料的長度會變化，且不想受到 Array 的類型限制時，應該使用 Slices，宣告的方式與 Array 極為相似，但不指定大小。 這樣會宣告一個長度為 3 的 Slice。 var x = []int{10,20,30} 也可以用 index 的方式指定初始值。 // index:value var x = []int{1,5:2,88} // [1,0,0,0,0,2,88] Slice 也可以模擬出多維的 Slice。 var x [][]int 比較大的差別在於，Slice 的 Zero Value 並不會是宣告時之類型的 Zero Value，而會是 nil，它是一種標示符號，代表某些類型缺少數值。 nil 也沒有類型，因此可以賦予值或是與其他不同類型的數值進行比較。 ","date":"2022-02-16","objectID":"/posts/go/03_composite/:2:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"Slice 內置函數 len 在前面的例子中有使用過了 len ，傳入 Array 會獲得該 Array 的長度，len 也適用於 Slice。若傳入 nil Slice 會獲得 0。 ","date":"2022-02-16","objectID":"/posts/go/03_composite/:2:1","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"append append 用於附加值至 Slice。最少要兩個傳入參數： 一個任意類型的 Slice 一個該類型的數值。 var x []int x = append(x,10)// [10] // 可以同時附加多個數值。 x = append(x,20,30,40) //[10,20,30,40] // 甚至是附加 Slice。但需要使用...這個運算符 y := []int{50,60,70} x = append(x,y...) //[10,20,30,40,50,60,70] cap (Capacity) Slice 是一系列連續的數值，每個元素被分配到連續的記憶體位置，這樣可以快速讀取或寫入這些數值。每個 Slice 都有一個 Capacity，即保留的連續記憶體位置的數量。 當使用 append 附加數值至 Slice 時，長度也會增加，當長度達到 Capacity，代表沒有空間存放資料了，若又使用 append 附加數值時，則會分配有更大 Capacity 的 Slice，並將原本 Slice 的數值複製到新的 Slice 後，將新的數值附加到 Slice 的最後，並返回新的 Slice。 cap() 可以獲得該 Slice 目前的 Capacity。 但 Capacity 增長，視 Go 語言的版本不同，基本上都會是增長原本大小的一倍，當已經知道某組數值的確切長度時，是否能指定 Capacity 的大小而不造成記憶體的浪費呢? 此時可以透過 make 內置函數建立確切 Capacity 的 Slice。 make make 可以聲明指定長度、類型與容量的 Slice。 這樣會建立一個類型為 int、長度與容量為5的slice，由於它的長度為5，故它的第0個至第4個元素是有效元素，會被初始化為 int 的 Zero Value，也就是 0 。 x := make([]int, 5) 若要指定容量，則在傳入參數內加入所需的容量大小。 x := make([]int, 5, 10) 甚至建立一個長度為 0 的 Slice 也是可行的。 x := make([]int, 0, 10) // 但後面使用，記得用 append 附加數值，長度為 0 是沒辦法做 index 的。 記住，絕對不要指定一個小於長度的 Capacity，也盡量不要使用變數指定 Capacity。 ","date":"2022-02-16","objectID":"/posts/go/03_composite/:2:2","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"宣告 Slice Slice 在宣告時有不同的方式，但最主要的目標是將 Slice 增長的次數最小化，若 Slice 不會增長，請使用 var 建立 nil slice。 var data []int 若有初始值，或是 Slice 的數值不會改變，會建議就是以賦值方式宣告。 data := []int(1, 2, 3, 4) 若很清楚 Slice 需要多大，但不清楚內部的數值會是甚麼，請使用 make 宣告 Slice。 若以 Slice 作為 buffer 使用，則指定一個非 0 長度的 Slice。 若確定 Slice 的大小，則可以指定 Slice 的長度。 在其他情況下，使用 make 宣告 0 長度與指定 Capacity 的 Slice，並使用 append 增加數值。 ","date":"2022-02-16","objectID":"/posts/go/03_composite/:2:3","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"Slicing Slices Slice 的表達式由一個起始偏移量和一個結束偏移量組成，並用 : 分隔。若省略起始偏移量，則為0，若省略結束偏移量，則為結尾。 x := []int{1, 2, 3, 4} y := x[:2] z := x[1:] d := x[1:3] e := x[:] fmt.Println(\"x:\", x) fmt.Println(\"y:\", y) fmt.Println(\"z:\", z) fmt.Println(\"d:\", d) fmt.Println(\"e:\", e) // 輸出 x: [1 2 3 4] y: [1 2] z: [2 3 4] d: [2 3] e: [1 2 3 4] 另外以上述的 Slice 表達式，他們之間是共享記憶體的。使用上請小心。 x := []int{1, 2, 3, 4} y := x[:2] z := x[1:] x[1] = 20 y[0] = 10 z[1] = 30 fmt.Println(\"x:\", x) fmt.Println(\"y:\", y) fmt.Println(\"z:\", z) // 輸出 x：[10 20 30 4] y：[10 20] z：[20 30 4] Copy 若我想要建立一個 Slice，並使用原始 Slice 的數值，但不共享記憶體的獨立 Slice 時，請使用內置的 Copy 函式。 Copy 函式有兩個參數，第一個是目標 Slice，第二個是來源 Slice，並會盡量把數值複製到目標，並返回複製的 element 數量。 x := []int{1, 2, 3, 4} y := make([]int, 4) num := copy(y, x) fmt.Println(y, num) z := make([]int, 2) num := copy(z, x) fmt.Println(z, num) // 輸出 [1 2 3 4] 4 [1 2] 2 也可以透過 Slice 表達式，複製部分的數值。 x := []int{1, 2, 3, 4} y := make([]int, 2) copy(y, x[2:]) // 若不需要返回值，不用特地設一個變數然後執行 copy()。 copy 也可以用來把 Slice 的某部分覆蓋至別的部分。 x := []int{1, 2, 3, 4} num = copy(x[:3], x[1:]) fmt.Println(x, num) // 輸出 [2 3 4 4] 3 ","date":"2022-02-16","objectID":"/posts/go/03_composite/:2:4","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"Strings and Runes and Bytes Go 使用一個 Bytes 序列代表一個 String。 var s string = \"Hello there\" var b byte = s[6] // t 前述提到的 Slice 表達式，也可以用在 String。 但建議在 String 每一個字元都是一個 Byte 大小時再使用。(e.g. emoji是4個bytes) 單個 rune 或是 byte 可以使用類型轉換成 string。 但常使用的 int ，透過類型轉換的話，會變成 ascii 而不是直接轉換，若要單純的把 int 轉換成 string，請使用 strconv.Itoa()。 參考資料 字串也可以轉成 rune slice 或是 byte slice，使用方式也不困難，通常會使用 byte slice 做轉換。 var s string = \"Hello, world!\" var bs []byte = []byte(s) var rs []rune = []rune(s) ","date":"2022-02-16","objectID":"/posts/go/03_composite/:3:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"Map ","date":"2022-02-16","objectID":"/posts/go/03_composite/:4:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"intro Map 其實與其他程式語言相似，將一個數值關聯到另一個數值的類型。Map 的 Zero Value 是 nil。 var nilMap map[string]int 但這種方式，在寫入 nil 時會導致恐慌，可以透過另一個方法建立映射變量。 myMap := map[string]int{} 若知道確切的數值，可以用賦值宣告的方式建立Map。 宣告方式為 key:value，每組數值都用 , 分隔，即使是最後一組也要加上逗號。 rank := map[string]int{ \"I\" : 1, \"you\" : 2, \"she\" : 3, } 若知道 Map 的確切大小但不清楚內部數值，可以使用 make 建立有默認大小的 map。 ages := make(map[int][]string, 10) Map 與 Slice 相似的地方： 增加 key:value pair 數據時，Map 會自動增長。 若知道會有多少筆數據，則可以使用 make 建立有初數大小的 Map。 將 Map 傳遞給 len ，可以獲得 key:value pair 的數量。 Map 的 Zero Value 是 nil。 Map 沒有可比性，只能檢查是否等於 nil，但無法檢查兩個 Map 是否有相同的 key:value pair。 另外有些要注意的點： key 必須是可以比較的類型，像是slice或是map這種無法比較，無可比性的類型就不能使用。 若數據要按照順序處理，建議使用 Slice，若數據不用嚴格按照順序處理，則可以使用 Map。 ","date":"2022-02-16","objectID":"/posts/go/03_composite/:4:1","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"Read and Write myMap := map[string]int{} myMap[\"Taipei\"] = 1 fmt.Println(totalWins[\"Taipei\"]) fmt.Println(totalWins[\"I-lan\"]) myMap[\"I-lan\"]++ fmt.Println(totalWins[\"I-lan\"]) // 輸出 1 0 1 透過 key 的方式分配 value，這邊要注意是使用 = 而不能使用 :=，若要讀取未分配 value 的 key 之 value 時，則會返回 Zero Value。 ","date":"2022-02-16","objectID":"/posts/go/03_composite/:4:2","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"The comma ok Idiom 那要如何知道 Map 中，我所需要的 key:value pair 是否在 Map 中？可以使用 comma ok Idiom 的方式區分 key:value pair 是否在 Map。 m := map[string]int{ \"hello\": 5, \"world\": 0, } v, ok := m[\"hello\"] fmt.Println(v, ok) v, ok = m[\"world\"] fmt.Println(v, ok) v, ok = m[\"goodbye\"] fmt.Println(v, ok) // 輸出 5 true 0 true 0 false ","date":"2022-02-16","objectID":"/posts/go/03_composite/:4:3","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"Deleting from Maps 刪除 key:value pair 的方式，透過內置函數 delete即可， m := map[string]int{ \"hello\": 5, \"world\": 10, } delete(m, \"hello\") 若 key 不存在於 map 內，或是說 map 是 nil，則甚麼都不會發生 !! ","date":"2022-02-16","objectID":"/posts/go/03_composite/:4:4","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"(補充 : Using Maps as Sets) 因為 Go 沒有 set 這個類型，但可以透過 Map 去實現。 intSet := map[int]bool{} vals := []int{5, 10, 2, 5, 8, 7, 3, 9, 1, 2, 10} for _, v := range vals { intSet[v] = true 透過 map 與迴圈，將設定的數值與 bool 連結，若有的數值則設定為 true，其他未在內的數值，因為 bool 的 Zero Value，都會是 false。這樣使用上就可以達到 set 的功能。 ","date":"2022-02-16","objectID":"/posts/go/03_composite/:4:5","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"Struct 若有想要組合在一起的相關數據時，應該訂意一個 struct。 type person struct{ name string age int pet string } 一個 struct 透過關鍵字 type、結構類型的名稱與struct組成。struct 內部則是field，由變數名稱與變數類型。 聲明 struct 後，就可以定義該類型的變數。 基本上這兩種方式，都會將 struct 內的所有 field 設定為 Zero Value。 var renne person lapis := person{} 若有初始值的話則是依據 field 宣告，記得按照順序，依據類型宣告。 nadia := person{ \"Nadia\", \"18\", \"cat\", } 或者是以類似 key:value pair 的方式宣告。可以不必按照順序宣告，可以指定部分變數即可，沒被指定的會被設定為 Zero Value。(建議用這種 !!) Tio := person{ name: \"Tio\", age: \"18\", pet: \"cat\", } struct 內的 field 用 . 進行訪問。 Tio.name = \"Tio Plato\" fmt.Println(Tio.name) ","date":"2022-02-16","objectID":"/posts/go/03_composite/:5:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"Anonymous Structs(匿名結構) 簡單來說，就是實現一個 struct 但不需要先命名，稱為匿名結構。通常用在將外部數據轉換成 struct，或是將 struct 轉換成外部數據(e.g. json)，這被稱為unmarshaling and marshaling data。 pet := struct { name string kind string }{ name: \"Cute\", kind: \"cat\", } ","date":"2022-02-16","objectID":"/posts/go/03_composite/:5:1","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"比較與轉換結構 不同類型的結構之變數之間，是不能比較的，除非兩個struct的field具有相同的名稱、順序與類型，才允許進行比較與類型轉換。 在 struct 的比較中，若其中至少有一個匿名結構的話，若兩個結構的 field 有相同的名稱，則可以在不進行類型轉換的情況下進行比較，若兩個結構的 field 具有相同的名稱、順序與類型，還可以在兩個結構之間進行 assign。 type firstPerson struct { name string age int } f := firstPerson{ name: \"Bob\", age: 50, } var g struct { name string age int } // compiles -- can use = and == between identical named and anonymous structs g = f fmt.Println(f == g) ","date":"2022-02-16","objectID":"/posts/go/03_composite/:5:2","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) How to convert an int value to string in go ","date":"2022-02-16","objectID":"/posts/go/03_composite/:6:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/03_composite/"},{"categories":["Go"],"content":"本篇文章將介紹類型與聲明，基本上接觸過程式語言的話，許多部份是相似的，僅有少處不同。 如同其他的程式語言，Golang 也有許多與相同的類型：Boolean、Integer、Float與String，後續會分別介紹不同的類型。 但我比較喜歡使用宣告，後面若看到宣告意同聲明。(Declarations) ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:0:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"Zero Value 在 Golang 中，會默認 Zero Value分配給已經聲明，但未分配數值的任何變數，換句話說也可以被稱為預設值，不同的類型的 Zero Value 也有所不同。這裡列出了幾個常用的變數的 Zero Value。 【Zero Value 並不是代表為 0 !! 不同類型的變數有不同的 Zero Value !!】 ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:1:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"Literal Literal 簡單來說是在程式碼中賦予的數值、字元或是字串，例如： func main(){ fmt.Println(\"Hello World\") } 這裡的 \"Hello World\" 就是字串型態的 Literal。 ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:2:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"Integer literal 若 Literal 為整數時，透過不同的前綴代表不同的進制方式。另外，當整數字串過長時，可以透過 underscore 將數字進行分組，提高閱讀的效能，但不能在該數字的開頭或結尾使用。 0b111 // 2進制 0o111 // 8進制 0x111 // 16進制 0111 // 這也是代表8進制，但容易搞混，不要使用這種方式!! //b,o,x可以用大寫B,O,X代替，會是一樣的作用。 a := 1111 b := 1_111 // 這兩組代表的是相同的數字。 ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:2:1","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"Float literal 若 Literal 為 float 時，可以使用字母 e 和數字組合出要使用的指數數值。與 Integer Literal 一樣能使用 underscore 提高閱讀的效能。 1.11e2 // 111.0 0.111_111 // 0.111111 另外， Float Literal有一種十六進制的表示方式。以 0x 作為前綴，指數後面以字母 P 為開頭進行運算。 0x1p-2 // 1.0 * (2^-2) = 1.0/4 = 0.25 0x2.p10 // 2.0 * 2^10 = 2048.0 ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:2:2","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"Rune literal 通常代表字元，會用單引號包起來，常用來表示 Unicode 字元。 'a' // Unicode '\\141' // 8進制 '\\x61' // 16進制 // 另外還有一些較特別且常使用的符號。 '\\n' // newLine '\\t' // tab '\\'' // 單引號 '\\\"' // 雙引號 '\\\\' // 反斜線 ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:2:3","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"String literal 如同前面所提到的 \"Hello world\"，會使用雙引號建立一個字串，並包含0個或多個字元，若要使用換行、反斜線與雙引號時，請記得透過反斜線進行轉義，使用方式與前面介紹 Rune literal 的符號是一樣的。 ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:2:4","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"Boolean 透過 bool 表示布林變數，布林具有 true 或 false兩種數值，bool的 Zero Value 為 false。 var flag bool var status = true ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:2:5","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"Numeric Types (數值類型) 基本上可分為三類：整數、浮點數與一些不常使用的複雜類型。 ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:3:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"整數 (integer) 基本上有各種大小的有符號數與無符號數。所有整數類型的 Zero Value 為 0 ，整數類型如下表所示： 類型名稱 數值範圍 int8 –128 to 127 int16 –32768 to 32767 int32 –2147483648 to 2147483647 int64 –9223372036854775808 to 9223372036854775807 uint8 0 to 255 uint16 0 to 65536 uint32 0 to 4294967295 uint64 0 to 18446744073709551615 另外， int 與 uint 會因為開發環境的 CPU 而會是不同類型的整數，在32位元的CPU上會是 int32,uint32，在64位元的CPU上會是int64,uint64。 然而，這麼多種的整數類型，要如何知道在何時使用其中一個呢？可以透過下述的三條規則去決定： 若開發或使用在具有特定大小的整數之格式或協議，則使用相應的整數類型。 若是撰寫一個用在任何整數類型的函式庫之函式時，請盡可能寫兩個函式，一個用 int而另一個使用uint。更加嚴謹的狀況下能規定大小會更好。(e.g. int64,uint64) 其他情況下，使用 int 即可，除非因為效能或是特定目的，已知需要明確的整數大小與有無符號，否則請使用 int。 ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:3:1","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"浮點數 (float) 基本上分為兩種， float32與float64，浮點數類型的 Zero Value 為 0。 類型名稱 最大絕對值 最小(非零) float32 3.40282346638528859811704183484516925440e+38 1.401298464324817070923729583289916131280e-45 float64 1.797693134862315708145274237317043567981e+308 4.940656458412465441765687928682213723651e-324 除非是記憶體問題，否則請使用精度較好的 float64，但精度較好也不能明確的表示十進制數值，請不要使用浮點數代表金錢或是需要精確十進制表示的數值。 ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:3:2","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"複雜 (complex) 基本上用於複數，有complex64與complex128兩種。(想到電學的交流電計算(頭痛))。但因為複數很少使用，我認為僅要知道有這個內置的類型即可。 ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:3:3","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"運算子 常見的運算子 +, -, *, /, %，整數除法的結果仍會是整數，若需要有浮點數效果，則需使用類型轉換。 另外可以將任何運算子與 = 做結合修改變數：+=, -=, *=, /=, %=。 比較的運算子則有 ==, !=, \u003e=, \u003e, \u003c, \u003c= 操作運算符則有： \u003c\u003c // shift left \u003e\u003e // shift right \u0026 // logical AND | // logical OR ^ // logical XOR \u0026^ // logical AND NOT 一樣可以與 = 結合修改變數：\u0026=, |=, ^=, \u0026^=, \u003c\u003c=, \u003e\u003e= ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:4:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"類型轉換 許多語言也有許多數字類型，且會在需要時自動類型提升，但自動轉換時可能會發生複雜的問題，並會有意想不到的結果。Go 作為嚴謹性高的語言，不允許自動類型提升，需要時要使用類型轉換才行。 var x int32 = 10 var y int64 = 20 var z int64 = int64(x) + y var w float64 = float64(y) + float64(z) ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:5:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"聲明 (var, :=) 宣告變數有許多方法，而每一種方法都傳達了有關如何使用該變數的資訊。 最冗長的方法是使用 var、類型並賦予值。 var x int = 1 若等號右側的類型，是變數的預期類型，則可以省略等號左側的類型， var x = 1 // type is int. 若宣告變數並將其設為Zero Value，則將等號右側刪除。 var x int 並可以一次宣告多個變數，可以是相同的類型，或是不同的類型。 var x,y int = 1,2 var i,j int var a,b = 1,\"Hi\" 還可以使用宣告列表(declaration list)一次宣告多個變數，但適用在函式外。 var( x int y = 1 a,b = 1,\"Hi\" i,j string ) 在函數中時，可以使用 := 替換掉 var 使用類型推斷的聲明。 var x = 10 x := 10 // 這兩行程式碼的作用是相同的。 一樣可以同時聲明多個變數，但這種不帶類型的宣告方式只能在函數中使用。 a,b := 1,\"Hi\" := 可以允許為現有的變數賦值，只要 :=左側有一個新的變數，則任何其他變數都可以存在。 x := 1 x,y := 2, \"Hi\" 在package宣告變數的話，則必須使用 var 宣告，在函式外使用 :=是不允許的。 另外有些情況下，盡量不要使用:= 將變數初始化為 Zero Value 時，請使用 var 進行宣告，因為 Zero Value 是有意的。 賦值的預設類型與變數的類型不同時，請使用 var。 x := byte(20) // 這個不好，賦值的預設類型是int，但變數是 byte。雖然可以用類型轉換處理這個議題，但用 var 直接宣告清楚會好一點。 var x byte = 20 := 可以同時宣告新變數與現有變數，但使用上可能會有 shadow variable 的狀況發生，建議宣告新的變數時用var宣告，並用 = 賦予數值。 最後，盡量不在函式外宣告變數。會難以追蹤。 ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:6:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"const 簡單來說，就是宣告一個數值，且該數值是不可變的。 const x int64 = 1 const ( a = 1 b = 2 ) ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:7:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"變數命名 基本上沒有硬性規定，但還是建議遵循以下幾點。 當變數名稱為多個單字組成時，採用駝峰式大小寫命名。 var studentScore int = 100 變數名稱的第一個字母會確定是否能在 package 外被存取。 在函式中，盡量使用較短的變數名稱，當該變數的範圍愈小，名稱就應該愈短。(e.g.跑迴圈時常使用 i 為變數(integer)) Go 是強類型語言，是不需要在變數名稱中加入預期的變數類型，與其加入變數類型，最好是再想一個更完整的名稱來宣告這個變數代表甚麼。 ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:8:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"參考資料 Learning Go(書籍) Basic Types and Basic Value Literals ","date":"2022-02-12","objectID":"/posts/go/02_type_and_declarations/:9:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/02_type_and_declarations/"},{"categories":["Go"],"content":"本篇基本上是說明golang的環境建置，編譯，環境先建置好，後續才能進行開發。另外會再提到一些程式碼的品質工具等。基本上在開發時都希望程式碼能具有較好的品質與一致的規範，降低後續維護的成本。 ","date":"2022-01-15","objectID":"/posts/go/01_environment/:0:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/01_environment/"},{"categories":["Go"],"content":"Install go 我自己的開發環境是在 macos 底下，基本上透過 brew install go 就會安裝完成。如果網路沒問題的話? $ brew install go 在 Windows 環境下，可以透過 Chocolatey 進行安裝，此外官方網站有提供相關壓縮檔與安裝檔，挑選自己使用的平台下載相關檔案後，解壓縮或是進行安裝即可。 安裝完成後，可以透過 go version指令，確定是否安裝完成。 $ go version go version go1.15.2 darwin/amd64 ","date":"2022-01-15","objectID":"/posts/go/01_environment/:1:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/01_environment/"},{"categories":["Go"],"content":"First program 建立一個檔案，通常第一支程式都會是設法在 Terminal 上顯示 Hello world!，故這程式碼的檔名先命名為 hello.go，並編輯該檔案。 $ touch hello.go $ vim hello.go 程式碼大致如下。 package main import \"fmt\" func main() { fmt.Println(\"Hello world!\") } 儲存該檔案後，在 Terminal 執行下列指令，此時應該能看到 Hello world! 顯示在Terminal上。 $ go run hello.go Hello world! go run 指令會將程式碼在臨時目錄中編譯成 binary 後執行，執行完成後刪除這個檔案，若要編譯成 binary 並使用，則使用 go build 。 $ go build hello.go 此時會產生一個hello的檔案，執行該檔案一樣會看到 Hello world! 顯示在Terminal上。 $ ./hello Hello world! ","date":"2022-01-15","objectID":"/posts/go/01_environment/:2:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/01_environment/"},{"categories":["Go"],"content":"Format go 語言對於撰寫格式相當嚴格，須嚴格使用標準格式，雖然在開發上會稍有不適，但對於多人開發與維護時，固定格式的程式碼會使這些工作更加容易。 也因為格式有嚴格標準，go也提供一個開發工具，go fmt，這個工具會自動重新格式化程式碼使齊符合標準格式。且目前有 go fmt 的加強版 goimports，有新的且更好用的工具，那就用新的工具吧。喜新厭舊 嘗試一下，修改前面提到的 hello.go，將其改成下面的程式碼，改動不大，僅是刪除一行縮排。 package main import \"fmt\" func main() { fmt.Println(\"Hello world!\") } 安裝 goimports，在 Terminal 中使用下列指令下載 goimports。 $ go install golang.org/x/tools/cmd/goimports@latest 安裝完成後，使用以下指令，重新開啟該檔案會發現那行縮排被重新加了回去。代表在函式中，程式碼要縮排為嚴格標準格式的規範。 $ goimports -l -w . -l : 告訴goimports，將格式不正確的檔案顯示在 Terminal上。 -w : 告訴goimports，直接修改該文件。 . : 路徑的意思，這邊用 . 代表目前的目錄與所有子目錄的所有檔案。 注意，盡量在編譯前執行 go fmt 或 goimports ，確保程式碼的格式沒有問題。 ","date":"2022-01-15","objectID":"/posts/go/01_environment/:3:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/01_environment/"},{"categories":["Go"],"content":"Linting and Veting goimports 能確保程式碼是大家慣用的格式，但在其他規範上則不會做檢查，像是變數命名規則，程式碼樣式與潛在錯誤等。高品質的程式碼請參考 Effective Go 與 Go Code Review Comments 兩個網站。當然，也有相關的工具能處理這些問題，目前常見的有 golint、go vet 工具。 golint，嘗試確保程式碼會依循文件，會建議更改像是變數名稱、public method 等，他的建議並不代表是錯誤，只是希望程式碼具有特定的格式並遵循特定的規則。 go vet，可以檢測一些有效的但有可能存在錯誤的程式碼。像是將錯誤數量的參數傳遞給 method，或使用不恰當的 Function。 除了這兩個工具以外，另外還有許多第三方的工具可以檢查程式碼樣式與潛在錯誤，然而愈多的工具，在進行檢查時就會花費愈多時間。其中，golangci-lint結合了上述兩項與其他相關的程式碼品質工具。golangci-lint 文件 且這個工具可以在開發目錄的根目錄中，透過一個 .golangci.yml 的檔案，根據需求設定啟用那些工具與檢查那些檔案。.golangci.yml 文件 $ golangci-lint run 注意，一樣盡量在編譯前執行 golangci-lint，或是其他相關的工具，盡可能在編譯前找出錯誤或有疑慮的部分，確保程式碼的品質。 ","date":"2022-01-15","objectID":"/posts/go/01_environment/:4:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/01_environment/"},{"categories":["Go"],"content":"Makefile 也就是說，在寫完程式後要進行編譯，我需要經常做這些事情： $ goimport -l . $ golangci-lint run $ go run [targetPath] ### 或是 $ go build [targetPath] 太麻煩了 !!! 透過 Make、shellscript 或其他的腳本語言，可以省略掉許多手動的步驟，降低重複動作的時間。 但此篇文章說的是關於程式設計，我會傾向用 make 來設計： 建立一個檔案名為Makefile，並編輯該檔案： .DEFAULT_GOAL := build fmt: goimports -l -w . .PHONY:fmt lint: golangci-lint run *.go .PHONY:lint build: lint go build hello.go .PHONY:build 並使用根目錄下使用 make 指令。 $ make 若順利的話，則會依序進行 goimports、golangci-lint 與 go build，且不用再重複下多次指令，一個 Make 就足夠了，只是要做一些前置準備。(Makefile)，另外，因為這篇主要是說明 golang 的環境建置， Makefile 的說明以後有空會再另外寫一篇說明(?) ","date":"2022-01-15","objectID":"/posts/go/01_environment/:5:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/01_environment/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go(書籍) Effective Go Go Code Review Comments goimports golangci-lint .golangci.yml ","date":"2022-01-15","objectID":"/posts/go/01_environment/:6:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/01_environment/"},{"categories":["Infra"],"content":"自己常用的 Linux 是 Debian，從 Debian 6(squeeze) 用到 Debian 10(buster)。Debian 在 2021.08.14 時釋出了 Debian 11(bullseye)，自己以往都是至官方連結下載新版的 ISO 重新安裝，這次則想說透過升級的方式進行更新，且這也是 Debian 著名的功能，故想於這次嘗試之。 (其實是有Service在運作並做一些測試，不想重弄) ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:0:0","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"準備 備份你所有的資料。（文件、圖片、設定檔、驅動程式等） 關閉所有的應用程式與服務。 關閉或刪除任何的個人套件庫(Personal Package Archive, PPA)，更新完成後再開啟或新增即可。 盡可能確保網路是穩定的。 保留一些時間進行升級。 ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:1:0","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"更新步驟 ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:2:0","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"更新現有的 package 開啟terminal，輸入 apt update \u0026\u0026 apt upgrade 更新套件索引(package indexes)與套件（packges），需要先將更新目前的packages。 root@server:~# apt update \u0026\u0026 apt upgrade ### 注意使用者身份，不是root的話，請加上sudo ### user@server:~$ sudo apt update \u0026\u0026 sudo apt upgrade ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:2:1","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"更新來源(source.list) 修改apt的source.list，將來源由buster更改為新的bullseye。修改 /etc/apt/source.list (注意編輯權限)，不一定要使用vim，用自己喜歡的編輯器即可(e.g. emacs, nano)，請記得編輯設定檔前記得備份！！！ user@server:~$ sudo cp /etc/apt/source.list /etc/apt/source.list.bak user@server:~$ sudo vim /etc/apt/source.list 修改前的檔案 修改前的檔案\" 修改前的檔案 修改後的檔案 修改後的檔案\" 修改後的檔案 這裡再補充介紹 main, contrib, non-free main: 主要為完全符合 Debian 自由軟體指南(Debian Free Software Guidelines, DFSG)的所有package。 contrib: 為開源但依賴於 non-free 的 package。 non-free: 為不符合 Debian 自由軟體指南的 package。 ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:2:2","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"升級 先使用 apt update 確認第二步的編輯是否沒有問題，若無錯誤訊息再進行 apt full-upgrade。 user@server:~$ sudo apt update user@server:~$ sudo apt full-upgrade 途中會有一些訊息需要選擇。 顯示有關packages更新的新聞。按q退出。 Information about package update\" Information about package update Package configuration，請選擇 \u003cYes\u003e Package configuration\" Package configuration 相關package的configuration，請依據需求設定，建議用 N 保留設定。 Options description : Y or I : install the package maintainer’s version (安裝維護者版本的package，會覆蓋掉該檔案的設定。) N or O : keep your currently-installed verstion (保留目前安裝的版本。) D : show the differences between the versions (顯示版本之間的差異。) Z : start a shell to examine the situation (啟動一個shell檢查情況。) 完成升級後，重新啟動系統。 user@server:~$ sudo systemctl reboot ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:2:3","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"確認 透過 lsb_release -a 指令進行確認，可以發現已經從 buster 升級至 bullseye了。 user@server:~$ lsb_release -a Distributor ID: Debian Description: Debian GNU/Linux 11 (bullseye) Release: 11 Codename: bullseye 確認完成後，使用 apt --purge autoremove 刪除不再需要且不必要的packages。 user@server:~$ sudo apt --purge autoremove ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:2:4","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"結論 第一次自己升級 Debian ，坦白說並沒有想像中的困難，有做好備份可以降低升級上的壓力。基本上都是apt在負責，只要有依據文件設定 /etc/apt/source.list，應該不會構成太大的問題。 ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:3:0","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Infra"],"content":"參考資料 man apt debian.org Debian管理者手冊 Debian自由軟體指南,DFSG main,contrib,nonfree解釋 ","date":"2021-12-29","objectID":"/posts/infra/upgradedebian/:4:0","tags":["Linux","Debian"],"title":"有新的就要嘗試！教你如何從 Debian 10 升級至 Debian 11","uri":"/posts/infra/upgradedebian/"},{"categories":["Misc"],"content":"一來是學過一些網路與系統服務的知識與技能，但一直都沒有做詳細的筆記，簡單來說這筆記只有自己看得懂，自己懂是一回事，要讓別人懂又是另一回事。 二來是以寫筆記或是技術文章的方式，可以促使自己學習好一點，深入一點，自己做開發或設定時，有些功能或參數可能就是把它 turn on turn off，而不會去想說這個是代表什麼，寫文章的話則必須要去解釋這個功能，進而讓自己深入學習。 三來是受大神同學影響，因為他真的很強，我也想跟他一樣強(? 有空會放上自己以前做過的服務或遇到的問題處理方式(troubleshooting)，往後學習新技能時或遇到新問題時，也盡量寫成文章記錄做出回饋。（主要是以技術文章寫筆記） 文筆不太好，若有問題請多指教。 ","date":"2021-12-28","objectID":"/posts/misc/start/:0:0","tags":["Misc"],"title":"Start","uri":"/posts/misc/start/"},{"categories":null,"content":"About ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Announcement Ansible 的部分暫時停更，因為 docker 跟 k8s 不熟 …（2023/09/27） 因為手骨折，緩慢更新中 (2023/07/07) ","date":"0001-01-01","objectID":"/about/:1:1","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Info 各位好，這裡是瑋瑋。 請多指教。 ","date":"0001-01-01","objectID":"/about/:1:2","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"My TimeLine Cameo Communications, Inc. Software Engineer : Develop and test Layer3 Switch firmware using C language. Develop and test the Web user interface(WebUI) for Layer3 Switch using HTML, CSS, and jQuery. Deal firmware issues on Layer3 Switch through troubleshooting and repairs. 2023 function non0plural(number, name) { if (number == 0) { return \"\" } if (number 1) { return number + \" \" + name + \"s\" } return number + \" \" +name } el = document.querySelector(\"#moment\"); function refresh() { start = dayjs(\"2022-06-06\") now = dayjs() total_months = now.diff(start, \"M\", true) months = total_months % 12 years = Math.floor((total_months) / 12) el.innerHTML = non0plural(years,\"year\")+\" \"+non0plural(months.toFixed(8),\"month\") } window.setInterval(refresh, 100); Null 6 months Learn golang. Build my blog. Review my knowledge and prepare interview… 2022 ESUN Bank Network Engineer (less than 1 month) 2021 National Taipei University of Technology 2 years M.S. Student in Wireless and Broadband Networks Lab Major in Computer Science and Information Engineering. 2021 Taiwan Network Information Center 1 year 8 months Part-time in TWCERT/CC. Implement script to process a large amount cyber security data. Optimize existing script, reduce time of processing. Management and troubleshooting Web services on Windows Server and Linux(CentOS). Analyze cyber security incidents from people. 2021 The 49th National Skills Competition Skills : 資訊網路布建 (Information Network Cabling) Awards : 備取國手 (Silver medal) Optical fibre cabling and structured cabling system. Smart Home/Office Application. Troubleshooting and Measuring for copper and fibre cabling. 2019 CHT Security Co., Ltd. 2 months Intern. ⚠️ Secret !! ⚠️ 2018 Taiwan Academic Network Roaming Center 8 months Part-time. Troubleshoot problem about RADIUS server. Build environment and service test. 2018 ","date":"0001-01-01","objectID":"/about/:1:3","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"SkillTree 下面是我在至少一個計畫、作業或工作中使用過的技能。這並不意味著我知道他們的一切。 另外也列出了學習中與正在學習的技能。 比較常用的 Framework : Hugo Language : C/C++, Python, Shell Script System \u0026 Networking : Windows Server 2008/2012, Debian-based Linux Distributions, Cisco Networking, Tool : Vim, Visual Studio Code, Iterm2, Telegram bot 學習中技能 Tool : Ansible 計畫要點的 Database : PostgreSQL, Elasticsearch System \u0026 Networking : Amazon Web Service 暫時封存的 Database : MySQL Framework : Vuepress Language : Java, Javascript, Go System \u0026 Networking : CentOS, Cabling(Optical fibre, Copper) ","date":"0001-01-01","objectID":"/about/:1:4","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"補充 E子是我的信仰，也是這個 ID 的由來。 ","date":"0001-01-01","objectID":"/about/:1:5","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"About Blog ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Info 我會在這裡放上自己寫的軟體、系統與網路相關的筆記，與自己開發或是故障排除的經驗。 除此之外的會在 medium 分享。 目前 blog 是透過 Hugo 產生，主題是修改過後的 LoveIt，並由 Github Actions 替我編譯產生靜態網頁後，push 至 Github page 上。 ","date":"0001-01-01","objectID":"/about/:2:1","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Log 2021/12/28 : 開始。 2022/02/13 : 更改 Framework，從 Vuepress 搬遷至 Docusaurus。 2022/02/14 : 更改 Framework，從 Docusaurus 搬遷至 Hugo (theme:LoveIt)。 2022/03/03 : 脫離地端建置，改用 Github Actions 建置網頁。 2022/07/06 : 更新留言服務，從 disqus 轉至 utterances。 ","date":"0001-01-01","objectID":"/about/:2:2","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"License Info Attribution-NonCommercial 4.0 International (CC BY-NC 4.0) ","date":"0001-01-01","objectID":"/about/:2:3","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Link ","date":"0001-01-01","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"友站連結 O3R ","date":"0001-01-01","objectID":"/about/:3:1","tags":null,"title":"About","uri":"/about/"}]