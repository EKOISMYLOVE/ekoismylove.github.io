[{"categories":["Go"],"content":"本篇文章基本上是介紹 Go 的複合類型（Array, Slice, Map）與內置函式，另外會簡單介紹 struct。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:0:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Arrays 如同其他程式語言，Go 也有 Array，Array 中的所有元素，都必須是指定的類型。 var x [3]int 此時會建立長度為 3 的 Array，但未指定初始值，上一章提到若未指定初始值，則預設值會是 Zero Value，在這個 Array 中，類型是 int，故初始值會是 0 。 若要指定初始值，則可以使用這個方式。 var x = [3]int{10,20,30} 也可以用 index 的方式指定初始值。 // index:value var x = [10]int{1,5:2} // [1,0,0,0,0,2,0,0,0,0] 若已經很明確知道，陣列內的所有數值，在宣告時則可以用 [...] 省略陣列的長度。 var x = [...]int{10,20,30} var y = [3]int{10,20,30} // 這兩個 Array 是一樣的。 在 Go 中只有一維陣列，但可以模擬出多維陣列。 var x [5][10]int 可以透過內置韓式 len() 得到 Array 的長度。 fmt.Println(len(x)) 但在 Go 中，很少使用 Array，因為 Array 的大小會被視為是 Array 類型的一部分，[3]int是一種類型，[4]int是另一種類型。 因此： 不能使用變數來指定 Array 的大小，因為類型必須在編譯前解析，而不是在運作時解析。 不能使用類型轉換，無法將不同大小的 Array 轉換成相同的類型。 最好是知道需要的長度，否則盡量不要使用 Array。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:1:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Slices 若資料的長度會變化，且不想受到 Array 的類型限制時，應該使用 Slices，宣告的方式與 Array 極為相似，但不指定大小。 這樣會宣告一個長度為 3 的 Slice。 var x = []int{10,20,30} 也可以用 index 的方式指定初始值。 // index:value var x = []int{1,5:2,88} // [1,0,0,0,0,2,88] Slice 也可以模擬出多維的 Slice。 var x [][]int 比較大的差別在於，Slice 的 Zero Value 並不會是宣告時之類型的 Zero Value，而會是 nil，它是一種標示符號，代表某些類型缺少數值。 nil 也沒有類型，因此可以賦予值或是與其他不同類型的數值進行比較。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:2:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Slice 內置函數 len 在前面的例子中有使用過了 len ，傳入 Array 會獲得該 Array 的長度，len 也適用於 Slice。若傳入 nil Slice 會獲得 0。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:2:1","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"append append 用於附加值至 Slice。最少要兩個傳入參數： 一個任意類型的 Slice 一個該類型的數值。 var x []int x = append(x,10)// [10] // 可以同時附加多個數值。 x = append(x,20,30,40) //[10,20,30,40] // 甚至是附加 Slice。但需要使用...這個運算符 y := []int{50,60,70} x = append(x,y...) //[10,20,30,40,50,60,70] cap (Capacity) Slice 是一系列連續的數值，每個元素被分配到連續的記憶體位置，這樣可以快速讀取或寫入這些數值。每個 Slice 都有一個 Capacity，即保留的連續記憶體位置的數量。 當使用 append 附加數值至 Slice 時，長度也會增加，當長度達到 Capacity，代表沒有空間存放資料了，若又使用 append 附加數值時，則會分配有更大 Capacity 的 Slice，並將原本 Slice 的數值複製到新的 Slice 後，將新的數值附加到 Slice 的最後，並返回新的 Slice。 cap() 可以獲得該 Slice 目前的 Capacity。 但 Capacity 增長，視 Go 語言的版本不同，基本上都會是增長原本大小的一倍，當已經知道某組數值的確切長度時，是否能指定 Capacity 的大小而不造成記憶體的浪費呢? 此時可以透過 make 內置函數建立確切 Capacity 的 Slice。 make make 可以聲明指定長度、類型與容量的 Slice。 這樣會建立一個類型為 int、長度與容量為5的slice，由於它的長度為5，故它的第0個至第4個元素是有效元素，會被初始化為 int 的 Zero Value，也就是 0 。 x := make([]int, 5) 若要指定容量，則在傳入參數內加入所需的容量大小。 x := make([]int, 5, 10) 甚至建立一個長度為 0 的 Slice 也是可行的。 x := make([]int, 0, 10) // 但後面使用，記得用 append 附加數值，長度為 0 是沒辦法做 index 的。 記住，絕對不要指定一個小於長度的 Capacity，也盡量不要使用變數指定 Capacity。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:2:2","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"宣告 Slice Slice 在宣告時有不同的方式，但最主要的目標是將 Slice 增長的次數最小化，若 Slice 不會增長，請使用 var 建立 nil slice。 var data []int 若有初始值，或是 Slice 的數值不會改變，會建議就是以賦值方式宣告。 data := []int(1, 2, 3, 4) 若很清楚 Slice 需要多大，但不清楚內部的數值會是甚麼，請使用 make 宣告 Slice。 若以 Slice 作為 buffer 使用，則指定一個非 0 長度的 Slice。 若確定 Slice 的大小，則可以指定 Slice 的長度。 在其他情況下，使用 make 宣告 0 長度與指定 Capacity 的 Slice，並使用 append 增加數值。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:2:3","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Slicing Slices Slice 的表達式由一個起始偏移量和一個結束偏移量組成，並用 : 分隔。若省略起始偏移量，則為0，若省略結束偏移量，則為結尾。 x := []int{1, 2, 3, 4} y := x[:2] z := x[1:] d := x[1:3] e := x[:] fmt.Println(\"x:\", x) fmt.Println(\"y:\", y) fmt.Println(\"z:\", z) fmt.Println(\"d:\", d) fmt.Println(\"e:\", e) // 輸出 x: [1 2 3 4] y: [1 2] z: [2 3 4] d: [2 3] e: [1 2 3 4] 另外以上述的 Slice 表達式，他們之間是共享記憶體的。使用上請小心。 x := []int{1, 2, 3, 4} y := x[:2] z := x[1:] x[1] = 20 y[0] = 10 z[1] = 30 fmt.Println(\"x:\", x) fmt.Println(\"y:\", y) fmt.Println(\"z:\", z) // 輸出 x：[10 20 30 4] y：[10 20] z：[20 30 4] Copy 若我想要建立一個 Slice，並使用原始 Slice 的數值，但不共享記憶體的獨立 Slice 時，請使用內置的 Copy 函式。 Copy 函式有兩個參數，第一個是目標 Slice，第二個是來源 Slice，並會盡量把數值複製到目標，並返回複製的 element 數量。 x := []int{1, 2, 3, 4} y := make([]int, 4) num := copy(y, x) fmt.Println(y, num) z := make([]int, 2) num := copy(z, x) fmt.Println(z, num) // 輸出 [1 2 3 4] 4 [1 2] 2 也可以透過 Slice 表達式，複製部分的數值。 x := []int{1, 2, 3, 4} y := make([]int, 2) copy(y, x[2:]) // 若不需要返回值，不用特地設一個變數然後執行 copy()。 copy 也可以用來把 Slice 的某部分覆蓋至別的部分。 x := []int{1, 2, 3, 4} num = copy(x[:3], x[1:]) fmt.Println(x, num) // 輸出 [2 3 4 4] 3 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:2:4","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Strings and Runes and Bytes Go 使用一個 Bytes 序列代表一個 String。 var s string = \"Hello there\" var b byte = s[6] // t 前述提到的 Slice 表達式，也可以用在 String。 但建議在 String 每一個字元都是一個 Byte 大小時再使用。(e.g. emoji是4個bytes) 單個 rune 或是 byte 可以使用類型轉換成 string。 但常使用的 int ，透過類型轉換的話，會變成 ascii 而不是直接轉換，若要單純的把 int 轉換成 string，請使用 strconv.Itoa()。 參考資料 字串也可以轉成 rune slice 或是 byte slice，使用方式也不困難，通常會使用 byte slice 做轉換。 var s string = \"Hello, world!\" var bs []byte = []byte(s) var rs []rune = []rune(s) ","date":"2022-02-16","objectID":"/posts/go/go_note3/:3:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Map ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"intro Map 其實與其他程式語言相似，將一個數值關聯到另一個數值的類型。Map 的 Zero Value 是 nil。 var nilMap map[string]int 但這種方式，在寫入 nil 時會導致恐慌，可以透過另一個方法建立映射變量。 myMap := map[string]int{} 若知道確切的數值，可以用賦值宣告的方式建立Map。 宣告方式為 key:value，每組數值都用 , 分隔，即使是最後一組也要加上逗號。 rank := map[string]int{ \"I\" : 1, \"you\" : 2, \"she\" : 3, } 若知道 Map 的確切大小但不清楚內部數值，可以使用 make 建立有默認大小的 map。 ages := make(map[int][]string, 10) Map 與 Slice 相似的地方： 增加 key:value pair 數據時，Map 會自動增長。 若知道會有多少筆數據，則可以使用 make 建立有初數大小的 Map。 將 Map 傳遞給 len ，可以獲得 key:value pair 的數量。 Map 的 Zero Value 是 nil。 Map 沒有可比性，只能檢查是否等於 nil，但無法檢查兩個 Map 是否有相同的 key:value pair。 另外有些要注意的點： key 必須是可以比較的類型，像是slice或是map這種無法比較，無可比性的類型就不能使用。 若數據要按照順序處理，建議使用 Slice，若數據不用嚴格按照順序處理，則可以使用 Map。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:1","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Read and Write myMap := map[string]int{} myMap[\"Taipei\"] = 1 fmt.Println(totalWins[\"Taipei\"]) fmt.Println(totalWins[\"I-lan\"]) myMap[\"I-lan\"]++ fmt.Println(totalWins[\"I-lan\"]) // 輸出 1 0 1 透過 key 的方式分配 value，這邊要注意是使用 = 而不能使用 :=，若要讀取未分配 value 的 key 之 value 時，則會返回 Zero Value。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:2","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"The comma ok Idiom 那要如何知道 Map 中，我所需要的 key:value pair 是否在 Map 中？可以使用 comma ok Idiom 的方式區分 key:value pair 是否在 Map。 m := map[string]int{ \"hello\": 5, \"world\": 0, } v, ok := m[\"hello\"] fmt.Println(v, ok) v, ok = m[\"world\"] fmt.Println(v, ok) v, ok = m[\"goodbye\"] fmt.Println(v, ok) // 輸出 5 true 0 true 0 false ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:3","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Deleting from Maps 刪除 key:value pair 的方式，透過內置函數 delete即可， m := map[string]int{ \"hello\": 5, \"world\": 10, } delete(m, \"hello\") 若 key 不存在於 map 內，或是說 map 是 nil，則甚麼都不會發生 !! ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:4","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"(補充 : Using Maps as Sets) 因為 Go 沒有 set 這個類型，但可以透過 Map 去實現。 intSet := map[int]bool{} vals := []int{5, 10, 2, 5, 8, 7, 3, 9, 1, 2, 10} for _, v := range vals { intSet[v] = true 透過 map 與迴圈，將設定的數值與 bool 連結，若有的數值則設定為 true，其他未在內的數值，因為 bool 的 Zero Value，都會是 false。這樣使用上就可以達到 set 的功能。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:5","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Struct 若有想要組合在一起的相關數據時，應該訂意一個 struct。 type person struct{ name string age int pet string } 一個 struct 透過關鍵字 type、結構類型的名稱與struct組成。struct 內部則是field，由變數名稱與變數類型。 聲明 struct 後，就可以定義該類型的變數。 基本上這兩種方式，都會將 struct 內的所有 field 設定為 Zero Value。 var renne person lapis := person{} 若有初始值的話則是依據 field 宣告，記得按照順序，依據類型宣告。 nadia := person{ \"Nadia\", \"18\", \"cat\", } 或者是以類似 key:value pair 的方式宣告。可以不必按照順序宣告，可以指定部分變數即可，沒被指定的會被設定為 Zero Value。(建議用這種 !!) Tio := person{ name: \"Tio\", age: \"18\", pet: \"cat\", } struct 內的 field 用 . 進行訪問。 Tio.name = \"Tio Plato\" fmt.Println(Tio.name) ","date":"2022-02-16","objectID":"/posts/go/go_note3/:5:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Anonymous Structs(匿名結構) 簡單來說，就是實現一個 struct 但不需要先命名，稱為匿名結構。通常用在將外部數據轉換成 struct，或是將 struct 轉換成外部數據(e.g. json)，這被稱為unmarshaling and marshaling data。 pet := struct { name string kind string }{ name: \"Cute\", kind: \"cat\", } ","date":"2022-02-16","objectID":"/posts/go/go_note3/:5:1","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"比較與轉換結構 不同類型的結構之變數之間，是不能比較的，除非兩個struct的field具有相同的名稱、順序與類型，才允許進行比較與類型轉換。 在 struct 的比較中，若其中至少有一個匿名結構的話，若兩個結構的 field 有相同的名稱，則可以在不進行類型轉換的情況下進行比較，若兩個結構的 field 具有相同的名稱、順序與類型，還可以在兩個結構之間進行 assign。 type firstPerson struct { name string age int } f := firstPerson{ name: \"Bob\", age: 50, } var g struct { name string age int } // compiles -- can use = and == between identical named and anonymous structs g = f fmt.Println(f == g) ","date":"2022-02-16","objectID":"/posts/go/go_note3/:5:2","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) How to convert an int value to string in go ","date":"2022-02-16","objectID":"/posts/go/go_note3/:6:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"本篇文章將介紹類型與聲明，基本上接觸過程式語言的話，許多部份是相似的，僅有少處不同。 如同其他的程式語言，Golang 也有許多與相同的類型：Boolean、Integer、Float與String，後續會分別介紹不同的類型。 但我比較喜歡使用宣告，後面若看到宣告意同聲明。(Declarations) ","date":"2022-02-12","objectID":"/posts/go/go_note2/:0:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Zero Value 在 Golang 中，會默認 Zero Value分配給已經聲明，但未分配數值的任何變數，換句話說也可以被稱為預設值，不同的類型的 Zero Value 也有所不同。這裡列出了幾個常用的變數的 Zero Value。 【Zero Value 並不是代表為 0 !! 不同類型的變數有不同的 Zero Value !!】 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:1:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Literal Literal 簡單來說是在程式碼中賦予的數值、字元或是字串，例如： func main(){ fmt.Println(\"Hello World\") } 這裡的 \"Hello World\" 就是字串型態的 Literal。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Integer literal 若 Literal 為整數時，透過不同的前綴代表不同的進制方式。另外，當整數字串過長時，可以透過 underscore 將數字進行分組，提高閱讀的效能，但不能在該數字的開頭或結尾使用。 0b111 // 2進制 0o111 // 8進制 0x111 // 16進制 0111 // 這也是代表8進制，但容易搞混，不要使用這種方式!! //b,o,x可以用大寫B,O,X代替，會是一樣的作用。 a := 1111 b := 1_111 // 這兩組代表的是相同的數字。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:1","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Float literal 若 Literal 為 float 時，可以使用字母 e 和數字組合出要使用的指數數值。與 Integer Literal 一樣能使用 underscore 提高閱讀的效能。 1.11e2 // 111.0 0.111_111 // 0.111111 另外， Float Literal有一種十六進制的表示方式。以 0x 作為前綴，指數後面以字母 P 為開頭進行運算。 0x1p-2 // 1.0 * (2^-2) = 1.0/4 = 0.25 0x2.p10 // 2.0 * 2^10 = 2048.0 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:2","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Rune literal 通常代表字元，會用單引號包起來，常用來表示 Unicode 字元。 'a' // Unicode '\\141' // 8進制 '\\x61' // 16進制 // 另外還有一些較特別且常使用的符號。 '\\n' // newLine '\\t' // tab '\\'' // 單引號 '\\\"' // 雙引號 '\\\\' // 反斜線 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:3","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"String literal 如同前面所提到的 \"Hello world\"，會使用雙引號建立一個字串，並包含0個或多個字元，若要使用換行、反斜線與雙引號時，請記得透過反斜線進行轉義，使用方式與前面介紹 Rune literal 的符號是一樣的。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:4","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Boolean 透過 bool 表示布林變數，布林具有 true 或 false兩種數值，bool的 Zero Value 為 false。 var flag bool var status = true ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:5","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Numeric Types (數值類型) 基本上可分為三類：整數、浮點數與一些不常使用的複雜類型。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:3:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"整數 (integer) 基本上有各種大小的有符號數與無符號數。所有整數類型的 Zero Value 為 0 ，整數類型如下表所示： 類型名稱 數值範圍 int8 –128 to 127 int16 –32768 to 32767 int32 –2147483648 to 2147483647 int64 –9223372036854775808 to 9223372036854775807 uint8 0 to 255 uint16 0 to 65536 uint32 0 to 4294967295 uint64 0 to 18446744073709551615 另外， int 與 uint 會因為開發環境的 CPU 而會是不同類型的整數，在32位元的CPU上會是 int32,uint32，在64位元的CPU上會是int64,uint64。 然而，這麼多種的整數類型，要如何知道在何時使用其中一個呢？可以透過下述的三條規則去決定： 若開發或使用在具有特定大小的整數之格式或協議，則使用相應的整數類型。 若是撰寫一個用在任何整數類型的函式庫之函式時，請盡可能寫兩個函式，一個用 int而另一個使用uint。更加嚴謹的狀況下能規定大小會更好。(e.g. int64,uint64) 其他情況下，使用 int 即可，除非因為效能或是特定目的，已知需要明確的整數大小與有無符號，否則請使用 int。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:3:1","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"浮點數 (float) 基本上分為兩種， float32與float64，浮點數類型的 Zero Value 為 0。 類型名稱 最大絕對值 最小(非零) float32 3.40282346638528859811704183484516925440e+38 1.401298464324817070923729583289916131280e-45 float64 1.797693134862315708145274237317043567981e+308 4.940656458412465441765687928682213723651e-324 除非是記憶體問題，否則請使用精度較好的 float64，但精度較好也不能明確的表示十進制數值，請不要使用浮點數代表金錢或是需要精確十進制表示的數值。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:3:2","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"複雜 (complex) 基本上用於複數，有complex64與complex128兩種。(想到電學的交流電計算(頭痛))。但因為複數很少使用，我認為僅要知道有這個內置的類型即可。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:3:3","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"運算子 常見的運算子 +, -, *, /, %，整數除法的結果仍會是整數，若需要有浮點數效果，則需使用類型轉換。 另外可以將任何運算子與 = 做結合修改變數：+=, -=, *=, /=, %=。 比較的運算子則有 ==, !=, \u003e=, \u003e, \u003c, \u003c= 操作運算符則有： \u003c\u003c // shift left \u003e\u003e // shift right \u0026 // logical AND | // logical OR ^ // logical XOR \u0026^ // logical AND NOT 一樣可以與 = 結合修改變數：\u0026=, |=, ^=, \u0026^=, \u003c\u003c=, \u003e\u003e= ","date":"2022-02-12","objectID":"/posts/go/go_note2/:4:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"類型轉換 許多語言也有許多數字類型，且會在需要時自動類型提升，但自動轉換時可能會發生複雜的問題，並會有意想不到的結果。Go 作為嚴謹性高的語言，不允許自動類型提升，需要時要使用類型轉換才行。 var x int32 = 10 var y int64 = 20 var z int64 = int64(x) + y var w float64 = float64(y) + float64(z) ","date":"2022-02-12","objectID":"/posts/go/go_note2/:5:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"聲明 (var, :=) 宣告變數有許多方法，而每一種方法都傳達了有關如何使用該變數的資訊。 最冗長的方法是使用 var、類型並賦予值。 var x int = 1 若等號右側的類型，是變數的預期類型，則可以省略等號左側的類型， var x = 1 // type is int. 若宣告變數並將其設為Zero Value，則將等號右側刪除。 var x int 並可以一次宣告多個變數，可以是相同的類型，或是不同的類型。 var x,y int = 1,2 var i,j int var a,b = 1,\"Hi\" 還可以使用宣告列表(declaration list)一次宣告多個變數，但適用在函式外。 var( x int y = 1 a,b = 1,\"Hi\" i,j string ) 在函數中時，可以使用 := 替換掉 var 使用類型推斷的聲明。 var x = 10 x := 10 // 這兩行程式碼的作用是相同的。 一樣可以同時聲明多個變數，但這種不帶類型的宣告方式只能在函數中使用。 a,b := 1,\"Hi\" := 可以允許為現有的變數賦值，只要 :=左側有一個新的變數，則任何其他變數都可以存在。 x := 1 x,y := 2, \"Hi\" 在package宣告變數的話，則必須使用 var 宣告，在函式外使用 :=是不允許的。 另外有些情況下，盡量不要使用:= 將變數初始化為 Zero Value 時，請使用 var 進行宣告，因為 Zero Value 是有意的。 賦值的預設類型與變數的類型不同時，請使用 var。 x := byte(20) // 這個不好，賦值的預設類型是int，但變數是 byte。雖然可以用類型轉換處理這個議題，但用 var 直接宣告清楚會好一點。 var x byte = 20 := 可以同時宣告新變數與現有變數，但使用上可能會有 shadow variable 的狀況發生，建議宣告新的變數時用var宣告，並用 = 賦予數值。 最後，盡量不在函式外宣告變數。會難以追蹤。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:6:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"const 簡單來說，就是宣告一個數值，且該數值是不可變的。 const x int64 = 1 const ( a = 1 b = 2 ) ","date":"2022-02-12","objectID":"/posts/go/go_note2/:7:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"變數命名 基本上沒有硬性規定，但還是建議遵循以下幾點。 當變數名稱為多個單字組成時，採用駝峰式大小寫命名。 var studentScore int = 100 變數名稱的第一個字母會確定是否能在 package 外被存取。 在函式中，盡量使用較短的變數名稱，當該變數的範圍愈小，名稱就應該愈短。(e.g.跑迴圈時常使用 i 為變數(integer)) Go 是強類型語言，是不需要在變數名稱中加入預期的變數類型，與其加入變數類型，最好是再想一個更完整的名稱來宣告這個變數代表甚麼。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:8:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"參考資料 Learning Go(書籍) Basic Types and Basic Value Literals ","date":"2022-02-12","objectID":"/posts/go/go_note2/:9:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"本篇基本上是說明golang的環境建置，編譯，環境先建置好，後續才能進行開發。另外會再提到一些程式碼的品質工具等。基本上在開發時都希望程式碼能具有較好的品質與一致的規範，降低後續維護的成本。 ","date":"2022-01-15","objectID":"/posts/go/go_note1/:0:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"Install go 我自己的開發環境是在 macos 底下，基本上透過 brew install go 就會安裝完成。如果網路沒問題的話? $ brew install go 在 Windows 環境下，可以透過 Chocolatey 進行安裝，此外官方網站有提供相關壓縮檔與安裝檔，挑選自己使用的平台下載相關檔案後，解壓縮或是進行安裝即可。 安裝完成後，可以透過 go version指令，確定是否安裝完成。 $ go version go version go1.15.2 darwin/amd64 ","date":"2022-01-15","objectID":"/posts/go/go_note1/:1:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"First program 建立一個檔案，通常第一支程式都會是設法在 Terminal 上顯示 Hello world!，故這程式碼的檔名先命名為 hello.go，並編輯該檔案。 $ touch hello.go $ vim hello.go 程式碼大致如下。 package main import \"fmt\" func main() { fmt.Println(\"Hello world!\") } 儲存該檔案後，在 Terminal 執行下列指令，此時應該能看到 Hello world! 顯示在Terminal上。 $ go run hello.go Hello world! go run 指令會將程式碼在臨時目錄中編譯成 binary 後執行，執行完成後刪除這個檔案，若要編譯成 binary 並使用，則使用 go build 。 $ go build hello.go 此時會產生一個hello的檔案，執行該檔案一樣會看到 Hello world! 顯示在Terminal上。 $ ./hello Hello world! ","date":"2022-01-15","objectID":"/posts/go/go_note1/:2:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"Format go 語言對於撰寫格式相當嚴格，須嚴格使用標準格式，雖然在開發上會稍有不適，但對於多人開發與維護時，固定格式的程式碼會使這些工作更加容易。 也因為格式有嚴格標準，go也提供一個開發工具，go fmt，這個工具會自動重新格式化程式碼使齊符合標準格式。且目前有 go fmt 的加強版 goimports，有新的且更好用的工具，那就用新的工具吧。喜新厭舊 嘗試一下，修改前面提到的 hello.go，將其改成下面的程式碼，改動不大，僅是刪除一行縮排。 package main import \"fmt\" func main() { fmt.Println(\"Hello world!\") } 安裝 goimports，在 Terminal 中使用下列指令下載 goimports。 $ go install golang.org/x/tools/cmd/goimports@latest 安裝完成後，使用以下指令，重新開啟該檔案會發現那行縮排被重新加了回去。代表在函式中，程式碼要縮排為嚴格標準格式的規範。 $ goimports -l -w . -l : 告訴goimports，將格式不正確的檔案顯示在 Terminal上。 -w : 告訴goimports，直接修改該文件。 . : 路徑的意思，這邊用 . 代表目前的目錄與所有子目錄的所有檔案。 注意，盡量在編譯前執行 go fmt 或 goimports ，確保程式碼的格式沒有問題。 ","date":"2022-01-15","objectID":"/posts/go/go_note1/:3:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"Linting and Veting goimports 能確保程式碼是大家慣用的格式，但在其他規範上則不會做檢查，像是變數命名規則，程式碼樣式與潛在錯誤等。高品質的程式碼請參考 Effective Go 與 Go Code Review Comments 兩個網站。當然，也有相關的工具能處理這些問題，目前常見的有 golint、go vet 工具。 golint，嘗試確保程式碼會依循文件，會建議更改像是變數名稱、public method 等，他的建議並不代表是錯誤，只是希望程式碼具有特定的格式並遵循特定的規則。 go vet，可以檢測一些有效的但有可能存在錯誤的程式碼。像是將錯誤數量的參數傳遞給 method，或使用不恰當的 Function。 除了這兩個工具以外，另外還有許多第三方的工具可以檢查程式碼樣式與潛在錯誤，然而愈多的工具，在進行檢查時就會花費愈多時間。其中，golangci-lint結合了上述兩項與其他相關的程式碼品質工具。golangci-lint 文件 且這個工具可以在開發目錄的根目錄中，透過一個 .golangci.yml 的檔案，根據需求設定啟用那些工具與檢查那些檔案。.golangci.yml 文件 $ golangci-lint run 注意，一樣盡量在編譯前執行 golangci-lint，或是其他相關的工具，盡可能在編譯前找出錯誤或有疑慮的部分，確保程式碼的品質。 ","date":"2022-01-15","objectID":"/posts/go/go_note1/:4:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"Makefile 也就是說，在寫完程式後要進行編譯，我需要經常做這些事情： $ goimport -l . $ golangci-lint run $ go run [targetPath] ### 或是 $ go build [targetPath] 太麻煩了 !!! 透過 Make、shellscript 或其他的腳本語言，可以省略掉許多手動的步驟，降低重複動作的時間。 但此篇文章說的是關於程式設計，我會傾向用 make 來設計： 建立一個檔案名為Makefile，並編輯該檔案： .DEFAULT_GOAL := build fmt: goimports -l -w . .PHONY:fmt lint: golangci-lint run *.go .PHONY:lint build: lint go build hello.go .PHONY:build 並使用根目錄下使用 make 指令。 $ make 若順利的話，則會依序進行 goimports、golangci-lint 與 go build，且不用再重複下多次指令，一個 Make 就足夠了，只是要做一些前置準備。(Makefile)，另外，因為這篇主要是說明 golang 的環境建置， Makefile 的說明以後有空會再另外寫一篇說明(?) ","date":"2022-01-15","objectID":"/posts/go/go_note1/:5:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go(書籍) Effective Go Go Code Review Comments goimports golangci-lint .golangci.yml ","date":"2022-01-15","objectID":"/posts/go/go_note1/:6:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":null,"content":"自己常用的 Linux 是 Debian，從 Debian 6(squeeze) 用到 Debian 10(buster)。Debian 在 2021.08.14 時釋出了 Debian 11(bullseye)，自己以往都是至官方連結下載新版的 ISO 重新安裝，這次則想說透過升級的方式進行更新，且這也是 Debian 著名的功能，故想於這次嘗試之。 (其實是有Service在運作並做一些測試，不想重弄) ","date":"2021-12-29","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:0:0","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":null,"content":"準備 備份你所有的資料。（文件、圖片、設定檔、驅動程式等） 關閉所有的應用程式與服務。 關閉或刪除任何的個人套件庫(Personal Package Archive, PPA)，更新完成後再開啟或新增即可。 盡可能確保網路是穩定的。 保留一些時間進行升級。 ","date":"2021-12-29","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:1:0","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":null,"content":"更新步驟 ","date":"2021-12-29","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:2:0","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":null,"content":"更新現有的 package 開啟terminal，輸入 apt update \u0026\u0026 apt upgrade 更新套件索引(package indexes)與套件（packges），需要先將更新目前的packages。 root@server:~# apt update \u0026\u0026 apt upgrade ### 注意使用者身份，不是root的話，請加上sudo ### user@server:~$ sudo apt update \u0026\u0026 sudo apt upgrade ","date":"2021-12-29","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:2:1","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":null,"content":"更新來源(source.list) 修改apt的source.list，將來源由buster更改為新的bullseye。修改 /etc/apt/source.list (注意編輯權限)，不一定要使用vim，用自己喜歡的編輯器即可(e.g. emacs, nano)，請記得編輯設定檔前記得備份！！！ user@server:~$ sudo cp /etc/apt/source.list /etc/apt/source.list.bak user@server:~$ sudo vim /etc/apt/source.list 修改前的檔案 修改前的檔案\" 修改前的檔案 修改後的檔案 修改後的檔案\" 修改後的檔案 這裡再補充介紹 main, contrib, non-free main: 主要為完全符合 Debian 自由軟體指南(Debian Free Software Guidelines, DFSG)的所有package。 contrib: 為開源但依賴於 non-free 的 package。 non-free: 為不符合 Debian 自由軟體指南的 package。 ","date":"2021-12-29","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:2:2","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":null,"content":"升級 先使用 apt update 確認第二步的編輯是否沒有問題，若無錯誤訊息再進行 apt full-upgrade。 user@server:~$ sudo apt update user@server:~$ sudo apt full-upgrade 途中會有一些訊息需要選擇。 顯示有關packages更新的新聞。按q退出。 Information about package update\" Information about package update Package configuration，請選擇 \u003cYes\u003e Package configuration\" Package configuration 相關package的configuration，請依據需求設定，建議用 N 保留設定。 Options description : Y or I : install the package maintainer’s version (安裝維護者版本的package，會覆蓋掉該檔案的設定。) N or O : keep your currently-installed verstion (保留目前安裝的版本。) D : show the differences between the versions (顯示版本之間的差異。) Z : start a shell to examine the situation (啟動一個shell檢查情況。) 完成升級後，重新啟動系統。 user@server:~$ sudo systemctl reboot ","date":"2021-12-29","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:2:3","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":null,"content":"確認 透過 lsb_release -a 指令進行確認，可以發現已經從 buster 升級至 bullseye了。 user@server:~$ lsb_release -a Distributor ID: Debian Description: Debian GNU/Linux 11 (bullseye) Release: 11 Codename: bullseye 確認完成後，使用 apt --purge autoremove 刪除不再需要且不必要的packages。 user@server:~$ sudo apt --purge autoremove ","date":"2021-12-29","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:2:4","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":null,"content":"結論 第一次自己升級 Debian ，坦白說並沒有想像中的困難，有做好備份可以降低升級上的壓力。基本上都是apt在負責，只要有依據文件設定 /etc/apt/source.list，應該不會構成太大的問題。 ","date":"2021-12-29","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:3:0","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":null,"content":"參考資料 man apt debian.org Debian管理者手冊 Debian自由軟體指南,DFSG main,contrib,nonfree解釋 ","date":"2021-12-29","objectID":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:4:0","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":null,"content":"一來是學過一些網路與系統服務的知識與技能，但一直都沒有做詳細的筆記，簡單來說這筆記只有自己看得懂，自己懂是一回事，要讓別人懂又是另一回事。 二來是以寫筆記或是技術文章的方式，可以促使自己學習好一點，深入一點，自己做開發或設定時，有些功能或參數可能就是把它 turn on turn off，而不會去想說這個是代表什麼，寫文章的話則必須要去解釋這個功能，進而讓自己深入學習。 三來是受大神同學影響，因為他真的很強，我也想跟他一樣強(? 有空會放上自己以前做過的服務或遇到的問題處理方式(troubleshooting)，往後學習新技能時或遇到新問題時，也盡量寫成文章記錄做出回饋。（主要是以技術文章寫筆記） 文筆不太好，若有問題請多指教。 ","date":"2021-12-28","objectID":"/posts/start/:0:0","tags":["Introduction"],"title":"Start","uri":"/posts/start/"},{"categories":null,"content":"Me 還想不到寫什麼呢😟😟😟 ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Log 2021/12/28 : 開始。 2022/02/13 : 從 vuepress 搬遷至 Docusaurus。 2022/02/14 : 從 Docusaurus 搬遷至 Hugo (theme:LoveIt)。 ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Link ","date":"0001-01-01","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"友站連結 國立臺北科技大學 資訊工程系 無線與寬頻網路實驗室 Oscar’s Pathways ","date":"0001-01-01","objectID":"/about/:3:1","tags":null,"title":"About","uri":"/about/"}]