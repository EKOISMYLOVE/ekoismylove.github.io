<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Java - Tag - Wei's Note</title><link>http://ekoismylove.github.io/tags/java/</link><description>Java - Tag - Wei's Note</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Wed, 31 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://ekoismylove.github.io/tags/java/" rel="self" type="application/rss+xml"/><item><title>寫給我自己看的資料結構筆記-平攤分析(Amortized Analysis)</title><link>http://ekoismylove.github.io/posts/structures/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E7%AD%86%E8%A8%98-amortized-analysis/</link><pubDate>Wed, 31 Jan 2024 00:00:00 +0000</pubDate><author>Author</author><guid>http://ekoismylove.github.io/posts/structures/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E7%AD%86%E8%A8%98-amortized-analysis/</guid><description>&lt;p>上一次我們提到演算法分析，有常數、線性與平方執行時間等等，但有時我們設計的程式直觀上看不出執行時間，又或者是執行時間看起來像常數，但其實是線性等，這時我們可以使用平攤分析法來得到執行時間。&lt;/p></description></item><item><title>寫給我自己看的資料結構筆記-演算法分析</title><link>http://ekoismylove.github.io/posts/structures/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E7%AD%86%E8%A8%98-%E6%BC%94%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</link><pubDate>Wed, 27 Dec 2023 00:00:00 +0000</pubDate><author>Author</author><guid>http://ekoismylove.github.io/posts/structures/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E7%AD%86%E8%A8%98-%E6%BC%94%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</guid><description>&lt;p>上篇提到了 ArrayList 與 LinkedList，不同的應用使用不同的 List interface 在執行速度上可能會有差異。這篇文章我們會簡單談一下，要如何知道程式適合使用哪種實作。&lt;/p></description></item><item><title>寫給我自己看的資料結構筆記-Interface</title><link>http://ekoismylove.github.io/posts/structures/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E7%AD%86%E8%A8%98-interface/</link><pubDate>Fri, 24 Nov 2023 00:00:00 +0000</pubDate><author>Author</author><guid>http://ekoismylove.github.io/posts/structures/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E7%AD%86%E8%A8%98-interface/</guid><description>&lt;p>這個主題，我會使用 Java 來說明資料結構，首先由 Interface 開始說起。&lt;/p></description></item></channel></rss>