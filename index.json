[{"categories":["Go"],"content":"本篇文章會說明如何使用 golang 撰寫函式，瞭解傳入值與返回值，介紹匿名函式與defer，並瞭解可以對函式所做的事情。 坦白說書對於這個章節寫的有點模糊，好啦其實是我自己理解能力差，這次看了不少 reference，若以後覺得還有要補充的地方會補上。 ","date":"2022-02-26","objectID":"/posts/go/go_note5/:0:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"宣告與使用函式 基本上宣告函式與其他程式語言幾乎相同，聲明會有四個部分： keyword, func 函數名稱 輸入參數 返回類型 func example(input int) int { fmt.Println(\"This is example.\") return 0 } 如果說這個函式沒有傳入參數，則小括號裡面則不需要填寫任何參數；如果說這個函式不會有任何的返回值，則宣告時也不需要寫返回類型。常使用的 main() 函式就是一個很好的例子。 func main(){ fmt.Println(\"Hello world\") } 若有許多傳入參數，且都為同一種類型時，可以稍微省略一些輸入參數的類型，但我是不建議就是了，每一個參數都寫清楚，後續維護會比較好處理一些。 func example(number1, number2 int) int { return number1+number2 } ","date":"2022-02-26","objectID":"/posts/go/go_note5/:1:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"具名與選擇性參數 (named and optional) 基本上許多程式語言都具有這兩個性質，但在 golang 中並沒有這兩個性質，基本上 golang 要求你宣告的輸入參數，全部都要使用（但也有例外）。 具名參數：用於識別傳入參數為何。許多情況下我們會傳入很類似的參數，透過具名參數的方式較容易識別。 選擇性參數：代表這個參數是選擇性傳入的，宣告函式時，選擇性參數必須擺在後面。若要選擇多個選擇性參數使用時，可以使用具名參數。 雖然 golang 無法使用這兩種參數，但可以用模擬的方式。 首先要訂一個 struct，代表這個函式會使用到的所有參數： type MyFuncOpt struct { FirstName string LastName string Age int } 接著，宣告函式時要使用前面宣告的 struct 作為傳入參數。使用時則傳入所需的數值即可。 func MyFunc(opts MyFuncOpt) error{ // do something } // 可以由外部傳入值 var i int = 55 // How to use. func main() { MyFunc(MyFuncOpts{ FirstName: \"Joe\", Age: i, }) } ","date":"2022-02-26","objectID":"/posts/go/go_note5/:2:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"可變參數 Golang 支援可變參數，可以允許任意數量的輸入參數。可變參數必須是函式聲明時的唯一一個參數，或是最後一個參數，並在類型前面加上 ...表示，這時會以這個類型的 slice 表示這個參數。 func number(base int, value ...int) int{ //do something. } 上述的例子中， value 已經是一個類型為 int 的 slice，所以也可以傳 slice 給他，只是說傳入時要在後面加上 ... 才能使用，否則會發生編譯錯誤。 number(1, []int{2,3,4,5}...) ","date":"2022-02-26","objectID":"/posts/go/go_note5/:3:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"多個返回值 Golang 的一個特色是，允許多個返回值。 func number(base int, value int)(int,int){ return base+value, base*value } 宣告函式時，多個返回值的類別需要以括號包起來，並以逗號隔開；函式內回傳值則是以逗號隔開即可。 多個回傳值則需要分配給多個變數，或是都被使用到，而不能像 python 一樣只分配給一個變數，因為 golang 多個回傳值就是回傳多個，不是像 python 一樣回傳一個數組。 numbers := number(1,2) // error number1, number2 := number(1,2) // success 返回值也是可以被具名的(named)，在宣告返回值類別時就都要加上括號，即便只有一個返回值也是，若只想命名部分的返回值，可以使用 _。另外具名的返回值可以分配在不同名稱的變數上，沒問題的。 func number(base int, value int)(ans1 int, ans2 int, _ int){ ans1, ans2 = base+value, base*value ans3 := 0 return ans1,ans2,ans3 } 不過，即使命名了返回值，也不代表一定要返回該值，golang 是允許不返回命名返回值的。使用上請小心，因為編譯器會將 return 的值分配給命名的返回值。 func number(base int, value int)(ans1 int, ans2 int, _ int){ ans1, ans2 = 1,2 ans3 := 0 return base+value,base*value,ans3 } func main(){ fmt.Println(number(5,2)) } // Output 7 10 0 ","date":"2022-02-26","objectID":"/posts/go/go_note5/:4:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"空白返回 (Blank returns) 空白返回適用在當我們命名了所有的返回值時，可以直接使用 return 而返回數值，不需要在 return 後面補上變數。 func number(base int, value int) (ans1 int, ans2 int) { ans1, ans2 = 1, 2 return } 雖然會節省許多時間，但維護上會很困擾。因為要去尋找返回值是從哪裡返回的，當函式一長，或是有多個 return，由判斷式決定的函式，看到都是 return，頭會很痛。 // 舉一個超超超簡單的例子。 func number(base int, value int) (ans1 int, ans2 int) { return // ???????? 哦哦回傳 zero value } func main(){ fmt.Println(number(5,2)) } // Output 0 0 ","date":"2022-02-26","objectID":"/posts/go/go_note5/:5:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"匿名函式 在函式中定義新函式，並將其分配給新的變數。而這些內部的新函式則是匿名函式。宣告方式基本上與一般函式相同，主要的差別在匿名函式不需要命名。使用時在後面用小括號傳入變數即可。 func main() { for i := 0; i \u003c 5; i++ { func(j int) { fmt.Println(\"printing\", j) }(i) } } //output printing 0 printing 1 printing 2 printing 3 printing 4 但我在 for loop 使用 fmt.Println() 就好了，直接使用內部的程式碼不是更好嗎？匿名函式的好處在哪裡呢？後續會在 defer 與 launching goroutines 這兩種情境中提到，匿名函式在這兩種情境中會是有用的。 ","date":"2022-02-26","objectID":"/posts/go/go_note5/:6:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"Closures ","date":"2022-02-26","objectID":"/posts/go/go_note5/:7:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"介紹 中文翻譯好像稱為閉包 (不喜歡)，Closures 可以限制函式的使用範圍，如果一個函式只會被另一個函式使用，但他會被多次使用，可以使用一個內部函式隱藏被使用的函式，正常函式呼叫完後內部的變數就會銷毀，但閉包卻能使本該銷毀的變數一直保留。 func intSeq() func() int { i := 0 return func() int { i++ return i } } func main() { nextInt := intSeq() fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) newInts := intSeq() fmt.Println(newInts()) } // Output 1 2 3 1 宣告一個 intSeq 的函式，返回值是函式，函式內第一個 return 使用了外部的 i，使得這個匿名函式成為了 Closures，而 i 則會被保留狀態並等待下次使用。 tips : 把函式想成一個數值會比較好理解，而運作方式也的確是如此。 ","date":"2022-02-26","objectID":"/posts/go/go_note5/:7:1","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"從函式返回函式 不只是能返回變數的狀態，也能夠返回函式的 closure： func makeMult(base int) func(int) int { return func(factor int) int { return base * factor } } func main() { twoBase := makeMult(2) for i := 0; i \u003c 3; i++ { fmt.Println(twoBase(i)) } } // Output 0 2 4 twoBase 的值是 makeMult(2) (記得函式也是一個數值的想法)，此時賦予 base 為 2。後面的 for loop 時，因為對於 twoBase 傳入了數值，故回傳內部的匿名函式。 ","date":"2022-02-26","objectID":"/posts/go/go_note5/:7:2","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"defer 通常使用 defer 是用來釋放資源，程式運作時需要常常釋放資源，例如開啟文件後要關閉，或是網路連線完成後，透過 defer 進行清理的工作。通常擺在函式的後面，與其他語言的 finally 相似。 func main() { f := createFile(\"/tmp/defer.txt\") defer closeFile(f) writeFile(f) } func createFile(p string) *os.File { fmt.Println(\"creating\") f, err := os.Create(p) if err != nil { panic(err) } return f } func writeFile(f *os.File) { fmt.Println(\"writing\") fmt.Fprintln(f, \"data\") } func closeFile(f *os.File) { fmt.Println(\"closing\") err := f.Close() if err != nil { fmt.Fprintf(os.Stderr, \"error: %v\\n\", err) os.Exit(1) } } // output creating writing closing 比方說要產生一個檔案，並寫入檔案後關閉對該檔案的存取，但我們在 main 中撰寫的順序是 createFile, closeFile，最後是 writeFile，但因為 defer 的關係， closeFile會在函數結束前執行。 補充一下 defer 的事情： 可以透過 defer 在函式中使用多個 closure，會以先入後出的方式進行，最後使用 defer 的會先運作。 defer 會是在 return 之後運行的。 defer 會造成延遲，若是要求速度至上的程式，請盡量減少使用。 defer 另一個好處是，可以用來檢查或修改返回值。且這也是前面提到命名返回值的理由。 // 書裡面的例子。 func DoSomeInserts(ctx context.Context, db *sql.DB, value1, value2 string) (err error) { tx, err := db.BeginTx(ctx, nil) if err != nil { return err } defer func() { if err == nil { err = tx.Commit() } if err != nil { tx.Rollback() } }() _, err = tx.ExecContext(ctx, \"INSERT INTO FOO (val) values $1\", value1) if err != nil { return err } // use tx to do more database inserts here return nil } 函式最後會回傳一個 error 類型的 err 變數，此時中間的 defer 會對這個數值進行判斷，如果沒有錯誤，則會提交，如果有錯誤的會則會 rollback。 ","date":"2022-02-26","objectID":"/posts/go/go_note5/:8:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"Call by Value 當我們傳遞變數至函數時， Golang 會將變數的值複製並傳遞進去。函式並不會改變該變數原本的數值。與其他語言不同的地方是，即使是傳遞一個 struct 至參數內，也不會改變在外部 struct 內的數值。 然而，傳遞 map 與 slice 進入參數時，函式進行修改是會影響到外部變數內的數值的，因為 map 與 slice 是用 pointer 實現的，對這個 pointer 所指的數值進行修改，就會影響到外部變數的數值。另外，傳遞至函式內的 slice，是無法延長的。 若我們需要像是 int, string 類型的變數進入函式進行修改時，要怎麼做呢？ pointer !! ","date":"2022-02-26","objectID":"/posts/go/go_note5/:9:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) 具名和選擇性引數 (C# 程式設計手冊) More on Functions 談談我所理解的閉包，js、php、golang裡的closure Go by Example: Closures Go初識-day10-閉包(closure) Go by Example: Defer ","date":"2022-02-26","objectID":"/posts/go/go_note5/:10:0","tags":["go","golang"],"title":"Golang - 函式(Functions)","uri":"/posts/go/go_note5/"},{"categories":["Go"],"content":"本篇文章將介紹 Block 與 Shadows，接著會說明控制結構（if、for、goto）等。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:0:0","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Code Blocks ","date":"2022-02-25","objectID":"/posts/go/go_note4/:1:0","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Types of blocks 其實用 blocks 作為關鍵字去尋找相關資訊並不太好找，反倒是以 Code Blocks 會比較容易些，基本上有聲明的地方，都會被稱為 blocks，在任何函數以外聲明的常數、變數、類型與函數都是放在 package block 內。而使用 import 內的時statement時，這些名稱則是放在 file block。 在 golang 中，有四種 blocks： universe block，包含了整個 project 的 source code。 package block，每一個 package 都有一個包含全部 code 的 block，但並不包含聲明。 file block，每一個 file 都有一個包含全部 code 的 block，也包含了聲明。 local blocks，基本上，在一個函數中，每一個大括弧 {} 都定義了一個 block。 local blocks 又分為 explicit local blocks 與 implicit local blocks，基本上要由 {} 與控制結構識別。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:1:1","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Hierarchies 透過圖片，會更了解 block 之間的層次結構。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:1:2","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Shadows 我們隨時可以從內部 block 訪問外部 block 的 identifer，如果內部與外部有相同的 identifer 時，會發生什麼事呢？ ","date":"2022-02-25","objectID":"/posts/go/go_note4/:2:0","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Shadowing variables func main() { x := 10 if x \u003e 5 { fmt.Println(x) x := 5 fmt.Println(x) } fmt.Println(x) } 可以先想一下這個函式的 blocks，再來想一下這個程式會印出什麼。在這個函式中發生了內部與外部的 identifer 相同的情況，此時外部的 identifer 會被隱藏。印出來的結果會是： 10 5 10 Shadowing Variable 是指在 package block 中的 variable 相同名稱的 variable，只要 Shadowsing variables 存在，就不能由外部訪問 Shadowing variables。該函式首先定義了 x 為 10，後來有一個 if statement，並遇到了大括號，記得前面說的每一個大括弧會是一個 block，這個 statement 內的 x 則是 shadowing variable，當離開這個 statement 時，這個 shadowing variable 就不能被訪問，故最後的 fmt.Println() 會是訪問頂部的 x 。 若善用 shadowing variables 在測試或是懶得想變數時會很方便，但記得使用的 identifer，若使用不慎可是會出問題的。 func main() { x := 10 fmt.Println(x) fmt := \"oops\" fmt.Println(fmt) } // Output fmt.Println undefined (type string has no field or method Println) 這個例子中，fmt 被聲明為 local variable，故會隱藏原先 fmt 所擁有的函式，也因此會有錯個錯誤發生。 個人認爲在測試內使用 shadowing variable 即可，開發的專案就不建議。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:2:1","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Detect 還記得在第一章提到的 vet 與 lint 可以做檢測用，但是 go vet 與 golangci-lint 是沒有檢測 shadow 的功能的(寫這篇文章時應該是沒有吧…)，但的確是有 shadow detect 工具可以使用的。 go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow@latest ","date":"2022-02-25","objectID":"/posts/go/go_note4/:2:2","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Control Structures Control Structures 其實跟許多語言的用法極為相似，但 golang 有一個與眾不同的 goto 可以使用。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:3:0","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"if if 的用法也與其他語言的用法相似 (很懶得寫)， if 的 condition 不用括號刮起來。 n := rand.Intn(10) if n == 0 { fmt.Println(\"That's too low\") } else if n \u003e 5 { fmt.Println(\"That's too big:\", n) } else { fmt.Println(\"That's a good number:\", n) } 主要提一點是，條件式內可以宣告變數的。 if n := rand.Intn(10); n == 0 { fmt.Println(\"That's too low\") } else if n \u003e 5 { fmt.Println(\"That's too big:\", n) } else { fmt.Println(\"That's a good number:\", n) } 在第一句的部分，我們新宣告了一個變數，後續的條件式則可以直接透過這個新的變數進行判斷。在某些場合會很好用。 但使用 if/else 時，請盡量將條件簡單化，另外是在 if statement 中宣告的變數，也是 shadowing variables，注意聲明的名稱與使用方式。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:3:1","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"for for 基本上也與其他語言一樣，作為循環使用，在 golang 中，for 有四種使用方式 標準型 for 條件型 for 無窮型 for for-range 標準型 for for i := 0; i \u003c 10; i++{ fmt.Println(i) } 這就像許多語言的用法一樣，有一個初始值，一個需要滿足的條件式，跟一個會遞增或遞減的行為，這個行為會在每一次的迴圈結束後進行。 條件型 for i := 0 for i \u003c 100 { fmt.Println(i) i = i + 1 } 條件型的 for 省略了初始值與行為，但仍須保留條件式。 無窮型 for for{ fmt.Println(\"Hello!\") } 取消了條件，亦同這個 for 會一直滿足且運作下去，當然也可以使用標準型或是條件型 for 達到相同的目的。如果要程式運作時需要結束這個無窮型迴圈，設計時可以使用條件式與 break 跳出這個 for。 i := 0 for{ i = i + 1 if i \u003e 10 { break } } for-range 通常像其他語言的迭代器(iterator) 我以前學不好的部分， for-range 常用在 string, array, slice 和 map 上。 evenVals := []int{2, 4, 6, 8, 10, 12} for i, v := range evenVals { fmt.Println(i, v) } // Output 0 2 1 4 2 6 3 8 4 10 5 12 用 for-range 會得到兩個變量，一個通常被稱為index或是key，我在這邊稱為位置，另一個則是該位置的數值。 如果不需要位置時，可以使用下底線進行隱藏。 evenVals := []int{2, 4, 6, 8, 10, 12} for _, v := range evenVals { fmt.Println(v) } // Output 2 4 6 8 10 12 如果需要位置而不需要值時，使用下底線嗎？也可以，但可以直接省略。 evenVals := []int{2, 4, 6, 8, 10, 12} for i := range evenVals { fmt.Println(i) } // Output 0 1 2 3 4 5 for-range 在遍歷 map 上會有特別的地方，會有每一次遍歷的順序結果不同的情形，這是 go 語言為了安全的設計，每一次的 for-range 迭代在遍歷 map 會有不同的結果。 for-range 所遍歷的會是一個副本而不是原變數的值，故在這個副本內修改的，並不會影響到原本的數值。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:3:2","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"Continue continue 是用來跳過剩餘的部分，並進行下一次的迭代。用起來也與其他語言相似，但有一個特別的用法，透過 OUTER 標籤進行的 for。 OUTER: for _, item := range list.Items { for _, reserved := range reserved.Items { if reserved.ID == item.ID { continue OUTER } ... do some other work ... } ... do some other work ... } 透過這種方式，可以跳出或跳過外部循環的迭代器。聽說這種方法很少用就是了 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:3:3","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"switch Nintendo Switch !! switch也是很常在其他語言中看到的 statement，用法也相似，很多人不喜歡使用 switch (我自己也是)，但 switch 在 go 語言中有一些令人驚訝的地方(?) words := []string{\"a\", \"cow\", \"smile\", \"gopher\",\"octopus\", \"anthropologist\"} for _, word := range words { switch size := len(word); size { case 1, 2, 3, 4: fmt.Println(word, \"is a short word!\") case 5: wordLen := len(word) fmt.Println(word, \"is exactly the right length:\", wordLen) case 6, 7, 8, 9: default: fmt.Println(word, \"is a long word!\") } } 多個 case 要進行相同的邏輯，可以在同一個 case 寫多個條件。 每一個 case 都會是一個 block，像是 case 5 的 wordLen 是一個新的 variable，只能在這邊使用。 不必再每個 case 後面加上 break， go 只會進行符合的 case。 如果沒有滿足 case，不會發生任何事。或是使用 default 決定沒有滿足 case 時需要做什麼。 通常使用 break 代表要跳出這次的 switch。但與其他語言不同，在 case 底下使用 break，go 只會認為你想跳出該 case 而不是 switch，若需要跳出 switch 需搭配 label 做使用。使用方式如下列的程式碼： loop: for i := 0; i \u003c 10; i++ { switch { case i%2 == 0: fmt.Println(i, \"is even\") case i%3 == 0: fmt.Println(i, \"is divisible by 3 but not 2\") case i%7 == 0: fmt.Println(\"exit the loop!\") break loop default: fmt.Println(i, \"is boring\") } } ","date":"2022-02-25","objectID":"/posts/go/go_note4/:3:4","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"goto 簡單介紹一下就好，如同字面上的意思，會去到程式的某個地方。但因為 goto 接近為所欲為，想去哪就去哪，在撰寫程式、運作與維護頗為麻煩 (自己廢就說)，通常會被用在要跳過程式某些部分或是跳出迴圈、switch 等，並執行程式後面的部分時使用。 func main() { a := rand.Intn(10) for a \u003c 100 { if a%5 == 0 { goto done } a = a*2 + 1 } fmt.Println(\"do something when the loop completes normally\") done: fmt.Println(\"do complicated stuff no matter why we left the loop\") fmt.Println(a) } tips : 非必要，盡量盡量不要使用 goto。 函式內可以提的內容應該都說明了，這章應該還有些東西可以補充，但可能之後想到比較容易解釋的方式，或是例子，再回來補充。 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:3:5","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) Code Blocks and Identifier Scopes Continue statements with Labels in Go (golang) Golang switch case 用法 ","date":"2022-02-25","objectID":"/posts/go/go_note4/:4:0","tags":["go","golang"],"title":"Golang - 代碼塊、陰影與控制結構(Code Blocks, Shadows, and Control Structures)","uri":"/posts/go/go_note4/"},{"categories":["blog"],"content":"本篇文章會簡單介紹 algolia search，並且說明如何在 LoveIt 上啟用 Algolia search。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:0:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Algolia search ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:1:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"介紹 Algolia search的宗旨是提供一個快速的搜尋體驗，並提供適用於多種不同 stack 的文件與工具，可以快速的建構搜尋功能，且搜尋功能只要利用 API 建立，不必花費太多時間建構。 另外可以分析搜尋結果，了解用戶到自己的網站搜尋了些甚麼，透過這些結果，可以自行定義，或是由 Algolia 自動生成較佳的搜尋規則。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:1:1","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"優點 速度非常快。Algolia Search 基本上是將網站建立索引(index)，並建立了分佈式搜尋網路(Distributed Search Network,DSN)，盡可能使搜尋要求送到最近的 DataCenter，降低延遲。 提供了自動建議字、自動糾正錯別字等搜尋功能，另外也支援多種語言的搜尋。 有免費的方案可以使用，雖然有些地方有所限制，但對於小型開發者而言，這個免費方案應能滿足需求。或是使用免費的 Docsearch，他是基於 algolia 的文件搜尋，不過他只能用在技術文件或是技術Blog，但我的 Blog 審核一直沒有通過，所以沒辦法使用…(應該是因為我寫的很差) ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:1:2","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"建置 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:2:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"註冊帳號 首先到 Algolia 的官方網站註冊帳號，基本上註冊的部分就不加以描述，而且我相信大家都有 Github account，algolia 也可以使用 Github 登入。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:2:1","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Key 註冊完成後，進到 Dashboard 並點選 API Keys，會獲得 Application ID，Search-Only API Key。 切記 : Admin API Key 絕對絕對絕對不要存放在任何地方。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:2:2","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Index 從 Dashboard 點選 Search，並建立一個新的 index，這個 index 可以自己任意取一個容易識別的名稱。 接下來的步驟，會用到前述提到的 Application ID、Search-Only API Key與index。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:2:3","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Algolia search config in LoveIt LoveIt 主題已經將 Algolia search 的功能製作完成，只需要輸入相對應的設定到 config.toml 中即可。 這邊附上官方的設定檔。 [params.search] enable = true # type of search engine (\"lunr\", \"algolia\") type = \"algolia\" # max index length of the chunked content contentLength = 4000 # placeholder of the search bar placeholder = \"\" # LoveIt NEW | 0.2.1 max number of results length maxResultLength = 10 # LoveIt NEW | 0.2.3 snippet length of the result snippetLength = 30 # LoveIt NEW | 0.2.1 HTML tag name of the highlight part in results highlightTag = \"em\" # LoveIt NEW | 0.2.4 whether to use the absolute URL based on the baseURL in search index absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 預設為 lunr 搜尋，請更換成 algolia。 在下方的部分，可以看到 index、appID 與 searchKey，請依據填入前述提到的數值。這裡的設定就完成，我們可以開始搜尋了。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:3:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Record 當完成設定之後，其實這個搜尋功能已經建立起來了，但是因為我們還沒上傳相關的記錄，所以 algolia search 會回傳 0 筆結果，那要如何上傳記錄呢? ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:4:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Create records 請在您的 config.toml 新增 output 屬性 : [outputs] home = [\"HTML\",\"RSS\",\"JSON\"] # Hugo 預設會生成 HTML 與 RSS，不建議刪除該兩參數，貌似會影響 Hugo 生成網頁的樣子。 設定完成後，我們執行 hugo，讓他重新建置並輸出 json，沒有意外的話會在 public 資料夾內產生一個 index.json，這個就是我們要的記錄檔，待會我們要上傳至 algolia search。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:4:1","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Upload records Dashboard -\u003e search -\u003e index -\u003e Add records 然後把剛剛產生的 json 上傳，上傳完成後應該幾秒內，你的 algolia search 就能夠搜尋到相關的結果了。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:4:2","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"Auto upload 因為這個方式，當我們的 blog 有更新時，就必須手動上傳新的記錄，那能不能使用程式上傳呢 ? Ans : 官方有提供API，當然可以。 官方文件 有詳細說明使用方式與一些 example code，基本上官方文件提供的程式碼就可以滿足我們的需求。因為都使用 Hugo 了，基本上 go 的環境應該是沒問題。我這邊就使用官方提供的 go 範例做使用。 tips : 記得要更改的參數與路徑。 package main import ( \"encoding/json\" \"io/ioutil\" \"github.com/algolia/algoliasearch-client-go/v3/algolia/search\" ) type Actor struct { Name string `json:\"name\"` Rating int `json:\"rating\"` ImagePath string `json:\"image_path\"` AlternativeName string `json:\"alternative_name\"` ObjectID string `json:\"objectID\"` } func main() { client := search.NewClient(\"appID\", \"Admin API Key\") index := client.InitIndex(\"index\") var actors []Actor data, _ := ioutil.ReadFile(\"public/index.json\") _ = json.Unmarshal(data, \u0026actors) // Batching is done automatically by the API client _, _ = index.SaveObjects(actors) } 之後在 push repo 時，一併記得要執行這個更新記錄的程式即可。 ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:4:3","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"參考資料(Reference) Algolia LoveIt Sending Records in Batches ","date":"2022-02-20","objectID":"/posts/blog/blog_algolia/:5:0","tags":["Hugo","blog","Web","algolia"],"title":"Hugo 部落格建置 - Algolia search","uri":"/posts/blog/blog_algolia/"},{"categories":["blog"],"content":"本篇文章基本上是介紹如何用 Hugo 建置 blog，並部署至 Github pages 上。 ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:0:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"前言 基本上建置這個部落格是為了紀錄自己的筆記，與自己遇到的問題和如何解決的方式，但從無到有建置一個非常麻煩，又不太想用像是 Medium 之類的網站，會少了一點自由，故想說使用框架產生靜態網頁的方式建置。 最一開始使用 Vuepress，使用了一陣子之後覺得用起來不是很順手，過了一陣子則有了換框架的想法，於是先換了 Docusaurus，因為小恐龍很可愛，沒想到 Docusaurus 對於自己來說，更難用！不到一天的使用時間，決定再次換框架，使用了 Hugo 建置，雖然搬遷很煩躁，但開始搬遷時第一個反應是： 哇塞，太快了吧！ 應該會有很長的一段時間，使用 Hugo，因此也想紀錄這些建置過程，作為自己的筆記，也希望可以分享給大家。 ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:1:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"安裝 Hugo 官方在 macOS 底下說明了使用 brew 與 port 兩種安裝方式，我會比較推薦使用 brew，如果環境是 Windows 或是 Linux 的使用者，官方文件有提到相關的安裝方式，這裡就不再加以說明。 $ brew install hugo 安裝後，可以使用 hugo version 確認是否安裝完成。 $ hugo version hugo v0.92.2+extended darwin/amd64 BuildDate=unknown 若安裝完成後，到自己的專案路徑底下建立站台專案。 ### hugo new site [sitename] $ hugo new site quickstart ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:2:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"安裝主題 (theme) Hugo 提供了許多種主題，或是到 Google 搜尋，基本上挑選自己喜歡的即可，我這邊選擇的是 LoveIt。 進入到站台專案，並使用 git 將 LoveIt 主題下載下來。 $ cd quickstart $ git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:3:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"增加內容 通常內容都會放置在專案內的 content 資料夾中，可以手動新增，也可以使用 hugo new 的方式新增，會自動在 frontmatter 補上標題與時間的資訊。 $ hugo new posts/first.md 產生檔案後，就用 markdown 語法寫文章即可，這邊要提醒一點是使用圖片的方式，要使用 HTML tag，而不能使用 ![name](url) 的方式。 \u003c!-- 請參考下面的程式碼，使用時請手動刪除 {{與\u003c 和 \u003e與}} 之間的空格。--\u003e {{ \u003cimage src=\"folder/filename\" caption=\"This is a image.\" \u003e }} ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:4:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"瀏覽 當內容新增完後，使用 hugo server -D，然後在瀏覽器輸入 http://localhost:1313/，就可以瀏覽了。 我自己會偏好使用 hugo serve -e production，使用生產環境的方式進行預覽，畢竟是要產生靜態網頁部署至 github page 做使用。只不過當directory 或是 path 更新時，會有一些問題發生，但基本上重新編譯即可。 $ hugo server -D ### Or $ hugo serve -e production ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:5:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"部署至 github 瀏覽網站並確認完畢後，首先先執行一次 hugo，這樣會在專案資料夾底下產生一個 /public，裡面的檔案就是 hugo 產生的靜態網頁內容，進入到 /public，將這些檔案 push 到自己的 username.github.io 的專案，稍等一下下後到 https://username.github.io，應該就可以看到網頁了。 cd public git init git add . git commit -m 'my first deploy' git remote add origin git@github.com:username/repo.git git push -u origin master 若對 git 不太熟悉的話 (像我)，git 與 github 的相關資訊，會附在參考資料作為參考。 基本上上傳完成且能看到網頁內容後，自己的部落格應該就完成了，往後新增或編輯文章後，就是再使用 hugo 重新產生靜態內容，並透過 git 將靜態內容上傳後即可。 後續有時間會再說明 theme 設定與一些功能的建置(SEO、algolia 與 disqus…等)。 ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:6:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["blog"],"content":"參考資料 Hugo 官方網站 Hugo quickstart Hugo themes Github pages Git 教學：如何 Push 上傳到 GitHub？ ","date":"2022-02-17","objectID":"/posts/blog/blog_build/:7:0","tags":["Hugo","blog","Web"],"title":"Hugo 部落格建置 - 安裝與部署","uri":"/posts/blog/blog_build/"},{"categories":["Go"],"content":"本篇文章基本上是介紹 Go 的複合類型（Array, Slice, Map）與內置函式，另外會簡單介紹 struct。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:0:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Arrays 如同其他程式語言，Go 也有 Array，Array 中的所有元素，都必須是指定的類型。 var x [3]int 此時會建立長度為 3 的 Array，但未指定初始值，上一章提到若未指定初始值，則預設值會是 Zero Value，在這個 Array 中，類型是 int，故初始值會是 0 。 若要指定初始值，則可以使用這個方式。 var x = [3]int{10,20,30} 也可以用 index 的方式指定初始值。 // index:value var x = [10]int{1,5:2} // [1,0,0,0,0,2,0,0,0,0] 若已經很明確知道，陣列內的所有數值，在宣告時則可以用 [...] 省略陣列的長度。 var x = [...]int{10,20,30} var y = [3]int{10,20,30} // 這兩個 Array 是一樣的。 在 Go 中只有一維陣列，但可以模擬出多維陣列。 var x [5][10]int 可以透過內置韓式 len() 得到 Array 的長度。 fmt.Println(len(x)) 但在 Go 中，很少使用 Array，因為 Array 的大小會被視為是 Array 類型的一部分，[3]int是一種類型，[4]int是另一種類型。 因此： 不能使用變數來指定 Array 的大小，因為類型必須在編譯前解析，而不是在運作時解析。 不能使用類型轉換，無法將不同大小的 Array 轉換成相同的類型。 最好是知道需要的長度，否則盡量不要使用 Array。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:1:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Slices 若資料的長度會變化，且不想受到 Array 的類型限制時，應該使用 Slices，宣告的方式與 Array 極為相似，但不指定大小。 這樣會宣告一個長度為 3 的 Slice。 var x = []int{10,20,30} 也可以用 index 的方式指定初始值。 // index:value var x = []int{1,5:2,88} // [1,0,0,0,0,2,88] Slice 也可以模擬出多維的 Slice。 var x [][]int 比較大的差別在於，Slice 的 Zero Value 並不會是宣告時之類型的 Zero Value，而會是 nil，它是一種標示符號，代表某些類型缺少數值。 nil 也沒有類型，因此可以賦予值或是與其他不同類型的數值進行比較。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:2:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Slice 內置函數 len 在前面的例子中有使用過了 len ，傳入 Array 會獲得該 Array 的長度，len 也適用於 Slice。若傳入 nil Slice 會獲得 0。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:2:1","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"append append 用於附加值至 Slice。最少要兩個傳入參數： 一個任意類型的 Slice 一個該類型的數值。 var x []int x = append(x,10)// [10] // 可以同時附加多個數值。 x = append(x,20,30,40) //[10,20,30,40] // 甚至是附加 Slice。但需要使用...這個運算符 y := []int{50,60,70} x = append(x,y...) //[10,20,30,40,50,60,70] cap (Capacity) Slice 是一系列連續的數值，每個元素被分配到連續的記憶體位置，這樣可以快速讀取或寫入這些數值。每個 Slice 都有一個 Capacity，即保留的連續記憶體位置的數量。 當使用 append 附加數值至 Slice 時，長度也會增加，當長度達到 Capacity，代表沒有空間存放資料了，若又使用 append 附加數值時，則會分配有更大 Capacity 的 Slice，並將原本 Slice 的數值複製到新的 Slice 後，將新的數值附加到 Slice 的最後，並返回新的 Slice。 cap() 可以獲得該 Slice 目前的 Capacity。 但 Capacity 增長，視 Go 語言的版本不同，基本上都會是增長原本大小的一倍，當已經知道某組數值的確切長度時，是否能指定 Capacity 的大小而不造成記憶體的浪費呢? 此時可以透過 make 內置函數建立確切 Capacity 的 Slice。 make make 可以聲明指定長度、類型與容量的 Slice。 這樣會建立一個類型為 int、長度與容量為5的slice，由於它的長度為5，故它的第0個至第4個元素是有效元素，會被初始化為 int 的 Zero Value，也就是 0 。 x := make([]int, 5) 若要指定容量，則在傳入參數內加入所需的容量大小。 x := make([]int, 5, 10) 甚至建立一個長度為 0 的 Slice 也是可行的。 x := make([]int, 0, 10) // 但後面使用，記得用 append 附加數值，長度為 0 是沒辦法做 index 的。 記住，絕對不要指定一個小於長度的 Capacity，也盡量不要使用變數指定 Capacity。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:2:2","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"宣告 Slice Slice 在宣告時有不同的方式，但最主要的目標是將 Slice 增長的次數最小化，若 Slice 不會增長，請使用 var 建立 nil slice。 var data []int 若有初始值，或是 Slice 的數值不會改變，會建議就是以賦值方式宣告。 data := []int(1, 2, 3, 4) 若很清楚 Slice 需要多大，但不清楚內部的數值會是甚麼，請使用 make 宣告 Slice。 若以 Slice 作為 buffer 使用，則指定一個非 0 長度的 Slice。 若確定 Slice 的大小，則可以指定 Slice 的長度。 在其他情況下，使用 make 宣告 0 長度與指定 Capacity 的 Slice，並使用 append 增加數值。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:2:3","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Slicing Slices Slice 的表達式由一個起始偏移量和一個結束偏移量組成，並用 : 分隔。若省略起始偏移量，則為0，若省略結束偏移量，則為結尾。 x := []int{1, 2, 3, 4} y := x[:2] z := x[1:] d := x[1:3] e := x[:] fmt.Println(\"x:\", x) fmt.Println(\"y:\", y) fmt.Println(\"z:\", z) fmt.Println(\"d:\", d) fmt.Println(\"e:\", e) // 輸出 x: [1 2 3 4] y: [1 2] z: [2 3 4] d: [2 3] e: [1 2 3 4] 另外以上述的 Slice 表達式，他們之間是共享記憶體的。使用上請小心。 x := []int{1, 2, 3, 4} y := x[:2] z := x[1:] x[1] = 20 y[0] = 10 z[1] = 30 fmt.Println(\"x:\", x) fmt.Println(\"y:\", y) fmt.Println(\"z:\", z) // 輸出 x：[10 20 30 4] y：[10 20] z：[20 30 4] Copy 若我想要建立一個 Slice，並使用原始 Slice 的數值，但不共享記憶體的獨立 Slice 時，請使用內置的 Copy 函式。 Copy 函式有兩個參數，第一個是目標 Slice，第二個是來源 Slice，並會盡量把數值複製到目標，並返回複製的 element 數量。 x := []int{1, 2, 3, 4} y := make([]int, 4) num := copy(y, x) fmt.Println(y, num) z := make([]int, 2) num := copy(z, x) fmt.Println(z, num) // 輸出 [1 2 3 4] 4 [1 2] 2 也可以透過 Slice 表達式，複製部分的數值。 x := []int{1, 2, 3, 4} y := make([]int, 2) copy(y, x[2:]) // 若不需要返回值，不用特地設一個變數然後執行 copy()。 copy 也可以用來把 Slice 的某部分覆蓋至別的部分。 x := []int{1, 2, 3, 4} num = copy(x[:3], x[1:]) fmt.Println(x, num) // 輸出 [2 3 4 4] 3 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:2:4","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Strings and Runes and Bytes Go 使用一個 Bytes 序列代表一個 String。 var s string = \"Hello there\" var b byte = s[6] // t 前述提到的 Slice 表達式，也可以用在 String。 但建議在 String 每一個字元都是一個 Byte 大小時再使用。(e.g. emoji是4個bytes) 單個 rune 或是 byte 可以使用類型轉換成 string。 但常使用的 int ，透過類型轉換的話，會變成 ascii 而不是直接轉換，若要單純的把 int 轉換成 string，請使用 strconv.Itoa()。 參考資料 字串也可以轉成 rune slice 或是 byte slice，使用方式也不困難，通常會使用 byte slice 做轉換。 var s string = \"Hello, world!\" var bs []byte = []byte(s) var rs []rune = []rune(s) ","date":"2022-02-16","objectID":"/posts/go/go_note3/:3:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Map ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"intro Map 其實與其他程式語言相似，將一個數值關聯到另一個數值的類型。Map 的 Zero Value 是 nil。 var nilMap map[string]int 但這種方式，在寫入 nil 時會導致恐慌，可以透過另一個方法建立映射變量。 myMap := map[string]int{} 若知道確切的數值，可以用賦值宣告的方式建立Map。 宣告方式為 key:value，每組數值都用 , 分隔，即使是最後一組也要加上逗號。 rank := map[string]int{ \"I\" : 1, \"you\" : 2, \"she\" : 3, } 若知道 Map 的確切大小但不清楚內部數值，可以使用 make 建立有默認大小的 map。 ages := make(map[int][]string, 10) Map 與 Slice 相似的地方： 增加 key:value pair 數據時，Map 會自動增長。 若知道會有多少筆數據，則可以使用 make 建立有初數大小的 Map。 將 Map 傳遞給 len ，可以獲得 key:value pair 的數量。 Map 的 Zero Value 是 nil。 Map 沒有可比性，只能檢查是否等於 nil，但無法檢查兩個 Map 是否有相同的 key:value pair。 另外有些要注意的點： key 必須是可以比較的類型，像是slice或是map這種無法比較，無可比性的類型就不能使用。 若數據要按照順序處理，建議使用 Slice，若數據不用嚴格按照順序處理，則可以使用 Map。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:1","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Read and Write myMap := map[string]int{} myMap[\"Taipei\"] = 1 fmt.Println(totalWins[\"Taipei\"]) fmt.Println(totalWins[\"I-lan\"]) myMap[\"I-lan\"]++ fmt.Println(totalWins[\"I-lan\"]) // 輸出 1 0 1 透過 key 的方式分配 value，這邊要注意是使用 = 而不能使用 :=，若要讀取未分配 value 的 key 之 value 時，則會返回 Zero Value。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:2","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"The comma ok Idiom 那要如何知道 Map 中，我所需要的 key:value pair 是否在 Map 中？可以使用 comma ok Idiom 的方式區分 key:value pair 是否在 Map。 m := map[string]int{ \"hello\": 5, \"world\": 0, } v, ok := m[\"hello\"] fmt.Println(v, ok) v, ok = m[\"world\"] fmt.Println(v, ok) v, ok = m[\"goodbye\"] fmt.Println(v, ok) // 輸出 5 true 0 true 0 false ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:3","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Deleting from Maps 刪除 key:value pair 的方式，透過內置函數 delete即可， m := map[string]int{ \"hello\": 5, \"world\": 10, } delete(m, \"hello\") 若 key 不存在於 map 內，或是說 map 是 nil，則甚麼都不會發生 !! ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:4","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"(補充 : Using Maps as Sets) 因為 Go 沒有 set 這個類型，但可以透過 Map 去實現。 intSet := map[int]bool{} vals := []int{5, 10, 2, 5, 8, 7, 3, 9, 1, 2, 10} for _, v := range vals { intSet[v] = true 透過 map 與迴圈，將設定的數值與 bool 連結，若有的數值則設定為 true，其他未在內的數值，因為 bool 的 Zero Value，都會是 false。這樣使用上就可以達到 set 的功能。 ","date":"2022-02-16","objectID":"/posts/go/go_note3/:4:5","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Struct 若有想要組合在一起的相關數據時，應該訂意一個 struct。 type person struct{ name string age int pet string } 一個 struct 透過關鍵字 type、結構類型的名稱與struct組成。struct 內部則是field，由變數名稱與變數類型。 聲明 struct 後，就可以定義該類型的變數。 基本上這兩種方式，都會將 struct 內的所有 field 設定為 Zero Value。 var renne person lapis := person{} 若有初始值的話則是依據 field 宣告，記得按照順序，依據類型宣告。 nadia := person{ \"Nadia\", \"18\", \"cat\", } 或者是以類似 key:value pair 的方式宣告。可以不必按照順序宣告，可以指定部分變數即可，沒被指定的會被設定為 Zero Value。(建議用這種 !!) Tio := person{ name: \"Tio\", age: \"18\", pet: \"cat\", } struct 內的 field 用 . 進行訪問。 Tio.name = \"Tio Plato\" fmt.Println(Tio.name) ","date":"2022-02-16","objectID":"/posts/go/go_note3/:5:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"Anonymous Structs(匿名結構) 簡單來說，就是實現一個 struct 但不需要先命名，稱為匿名結構。通常用在將外部數據轉換成 struct，或是將 struct 轉換成外部數據(e.g. json)，這被稱為unmarshaling and marshaling data。 pet := struct { name string kind string }{ name: \"Cute\", kind: \"cat\", } ","date":"2022-02-16","objectID":"/posts/go/go_note3/:5:1","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"比較與轉換結構 不同類型的結構之變數之間，是不能比較的，除非兩個struct的field具有相同的名稱、順序與類型，才允許進行比較與類型轉換。 在 struct 的比較中，若其中至少有一個匿名結構的話，若兩個結構的 field 有相同的名稱，則可以在不進行類型轉換的情況下進行比較，若兩個結構的 field 具有相同的名稱、順序與類型，還可以在兩個結構之間進行 assign。 type firstPerson struct { name string age int } f := firstPerson{ name: \"Bob\", age: 50, } var g struct { name string age int } // compiles -- can use = and == between identical named and anonymous structs g = f fmt.Println(f == g) ","date":"2022-02-16","objectID":"/posts/go/go_note3/:5:2","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go (書籍) How to convert an int value to string in go ","date":"2022-02-16","objectID":"/posts/go/go_note3/:6:0","tags":["go","golang"],"title":"Golang - 複合類型 (Composite Types)","uri":"/posts/go/go_note3/"},{"categories":["Go"],"content":"本篇文章將介紹類型與聲明，基本上接觸過程式語言的話，許多部份是相似的，僅有少處不同。 如同其他的程式語言，Golang 也有許多與相同的類型：Boolean、Integer、Float與String，後續會分別介紹不同的類型。 但我比較喜歡使用宣告，後面若看到宣告意同聲明。(Declarations) ","date":"2022-02-12","objectID":"/posts/go/go_note2/:0:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Zero Value 在 Golang 中，會默認 Zero Value分配給已經聲明，但未分配數值的任何變數，換句話說也可以被稱為預設值，不同的類型的 Zero Value 也有所不同。這裡列出了幾個常用的變數的 Zero Value。 【Zero Value 並不是代表為 0 !! 不同類型的變數有不同的 Zero Value !!】 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:1:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Literal Literal 簡單來說是在程式碼中賦予的數值、字元或是字串，例如： func main(){ fmt.Println(\"Hello World\") } 這裡的 \"Hello World\" 就是字串型態的 Literal。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Integer literal 若 Literal 為整數時，透過不同的前綴代表不同的進制方式。另外，當整數字串過長時，可以透過 underscore 將數字進行分組，提高閱讀的效能，但不能在該數字的開頭或結尾使用。 0b111 // 2進制 0o111 // 8進制 0x111 // 16進制 0111 // 這也是代表8進制，但容易搞混，不要使用這種方式!! //b,o,x可以用大寫B,O,X代替，會是一樣的作用。 a := 1111 b := 1_111 // 這兩組代表的是相同的數字。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:1","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Float literal 若 Literal 為 float 時，可以使用字母 e 和數字組合出要使用的指數數值。與 Integer Literal 一樣能使用 underscore 提高閱讀的效能。 1.11e2 // 111.0 0.111_111 // 0.111111 另外， Float Literal有一種十六進制的表示方式。以 0x 作為前綴，指數後面以字母 P 為開頭進行運算。 0x1p-2 // 1.0 * (2^-2) = 1.0/4 = 0.25 0x2.p10 // 2.0 * 2^10 = 2048.0 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:2","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Rune literal 通常代表字元，會用單引號包起來，常用來表示 Unicode 字元。 'a' // Unicode '\\141' // 8進制 '\\x61' // 16進制 // 另外還有一些較特別且常使用的符號。 '\\n' // newLine '\\t' // tab '\\'' // 單引號 '\\\"' // 雙引號 '\\\\' // 反斜線 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:3","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"String literal 如同前面所提到的 \"Hello world\"，會使用雙引號建立一個字串，並包含0個或多個字元，若要使用換行、反斜線與雙引號時，請記得透過反斜線進行轉義，使用方式與前面介紹 Rune literal 的符號是一樣的。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:4","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Boolean 透過 bool 表示布林變數，布林具有 true 或 false兩種數值，bool的 Zero Value 為 false。 var flag bool var status = true ","date":"2022-02-12","objectID":"/posts/go/go_note2/:2:5","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"Numeric Types (數值類型) 基本上可分為三類：整數、浮點數與一些不常使用的複雜類型。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:3:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"整數 (integer) 基本上有各種大小的有符號數與無符號數。所有整數類型的 Zero Value 為 0 ，整數類型如下表所示： 類型名稱 數值範圍 int8 –128 to 127 int16 –32768 to 32767 int32 –2147483648 to 2147483647 int64 –9223372036854775808 to 9223372036854775807 uint8 0 to 255 uint16 0 to 65536 uint32 0 to 4294967295 uint64 0 to 18446744073709551615 另外， int 與 uint 會因為開發環境的 CPU 而會是不同類型的整數，在32位元的CPU上會是 int32,uint32，在64位元的CPU上會是int64,uint64。 然而，這麼多種的整數類型，要如何知道在何時使用其中一個呢？可以透過下述的三條規則去決定： 若開發或使用在具有特定大小的整數之格式或協議，則使用相應的整數類型。 若是撰寫一個用在任何整數類型的函式庫之函式時，請盡可能寫兩個函式，一個用 int而另一個使用uint。更加嚴謹的狀況下能規定大小會更好。(e.g. int64,uint64) 其他情況下，使用 int 即可，除非因為效能或是特定目的，已知需要明確的整數大小與有無符號，否則請使用 int。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:3:1","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"浮點數 (float) 基本上分為兩種， float32與float64，浮點數類型的 Zero Value 為 0。 類型名稱 最大絕對值 最小(非零) float32 3.40282346638528859811704183484516925440e+38 1.401298464324817070923729583289916131280e-45 float64 1.797693134862315708145274237317043567981e+308 4.940656458412465441765687928682213723651e-324 除非是記憶體問題，否則請使用精度較好的 float64，但精度較好也不能明確的表示十進制數值，請不要使用浮點數代表金錢或是需要精確十進制表示的數值。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:3:2","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"複雜 (complex) 基本上用於複數，有complex64與complex128兩種。(想到電學的交流電計算(頭痛))。但因為複數很少使用，我認為僅要知道有這個內置的類型即可。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:3:3","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"運算子 常見的運算子 +, -, *, /, %，整數除法的結果仍會是整數，若需要有浮點數效果，則需使用類型轉換。 另外可以將任何運算子與 = 做結合修改變數：+=, -=, *=, /=, %=。 比較的運算子則有 ==, !=, \u003e=, \u003e, \u003c, \u003c= 操作運算符則有： \u003c\u003c // shift left \u003e\u003e // shift right \u0026 // logical AND | // logical OR ^ // logical XOR \u0026^ // logical AND NOT 一樣可以與 = 結合修改變數：\u0026=, |=, ^=, \u0026^=, \u003c\u003c=, \u003e\u003e= ","date":"2022-02-12","objectID":"/posts/go/go_note2/:4:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"類型轉換 許多語言也有許多數字類型，且會在需要時自動類型提升，但自動轉換時可能會發生複雜的問題，並會有意想不到的結果。Go 作為嚴謹性高的語言，不允許自動類型提升，需要時要使用類型轉換才行。 var x int32 = 10 var y int64 = 20 var z int64 = int64(x) + y var w float64 = float64(y) + float64(z) ","date":"2022-02-12","objectID":"/posts/go/go_note2/:5:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"聲明 (var, :=) 宣告變數有許多方法，而每一種方法都傳達了有關如何使用該變數的資訊。 最冗長的方法是使用 var、類型並賦予值。 var x int = 1 若等號右側的類型，是變數的預期類型，則可以省略等號左側的類型， var x = 1 // type is int. 若宣告變數並將其設為Zero Value，則將等號右側刪除。 var x int 並可以一次宣告多個變數，可以是相同的類型，或是不同的類型。 var x,y int = 1,2 var i,j int var a,b = 1,\"Hi\" 還可以使用宣告列表(declaration list)一次宣告多個變數，但適用在函式外。 var( x int y = 1 a,b = 1,\"Hi\" i,j string ) 在函數中時，可以使用 := 替換掉 var 使用類型推斷的聲明。 var x = 10 x := 10 // 這兩行程式碼的作用是相同的。 一樣可以同時聲明多個變數，但這種不帶類型的宣告方式只能在函數中使用。 a,b := 1,\"Hi\" := 可以允許為現有的變數賦值，只要 :=左側有一個新的變數，則任何其他變數都可以存在。 x := 1 x,y := 2, \"Hi\" 在package宣告變數的話，則必須使用 var 宣告，在函式外使用 :=是不允許的。 另外有些情況下，盡量不要使用:= 將變數初始化為 Zero Value 時，請使用 var 進行宣告，因為 Zero Value 是有意的。 賦值的預設類型與變數的類型不同時，請使用 var。 x := byte(20) // 這個不好，賦值的預設類型是int，但變數是 byte。雖然可以用類型轉換處理這個議題，但用 var 直接宣告清楚會好一點。 var x byte = 20 := 可以同時宣告新變數與現有變數，但使用上可能會有 shadow variable 的狀況發生，建議宣告新的變數時用var宣告，並用 = 賦予數值。 最後，盡量不在函式外宣告變數。會難以追蹤。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:6:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"const 簡單來說，就是宣告一個數值，且該數值是不可變的。 const x int64 = 1 const ( a = 1 b = 2 ) ","date":"2022-02-12","objectID":"/posts/go/go_note2/:7:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"變數命名 基本上沒有硬性規定，但還是建議遵循以下幾點。 當變數名稱為多個單字組成時，採用駝峰式大小寫命名。 var studentScore int = 100 變數名稱的第一個字母會確定是否能在 package 外被存取。 在函式中，盡量使用較短的變數名稱，當該變數的範圍愈小，名稱就應該愈短。(e.g.跑迴圈時常使用 i 為變數(integer)) Go 是強類型語言，是不需要在變數名稱中加入預期的變數類型，與其加入變數類型，最好是再想一個更完整的名稱來宣告這個變數代表甚麼。 ","date":"2022-02-12","objectID":"/posts/go/go_note2/:8:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"參考資料 Learning Go(書籍) Basic Types and Basic Value Literals ","date":"2022-02-12","objectID":"/posts/go/go_note2/:9:0","tags":["go","golang"],"title":"Golang - 類型與聲明 (Types and Declarations)","uri":"/posts/go/go_note2/"},{"categories":["Go"],"content":"本篇基本上是說明golang的環境建置，編譯，環境先建置好，後續才能進行開發。另外會再提到一些程式碼的品質工具等。基本上在開發時都希望程式碼能具有較好的品質與一致的規範，降低後續維護的成本。 ","date":"2022-01-15","objectID":"/posts/go/go_note1/:0:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"Install go 我自己的開發環境是在 macos 底下，基本上透過 brew install go 就會安裝完成。如果網路沒問題的話? $ brew install go 在 Windows 環境下，可以透過 Chocolatey 進行安裝，此外官方網站有提供相關壓縮檔與安裝檔，挑選自己使用的平台下載相關檔案後，解壓縮或是進行安裝即可。 安裝完成後，可以透過 go version指令，確定是否安裝完成。 $ go version go version go1.15.2 darwin/amd64 ","date":"2022-01-15","objectID":"/posts/go/go_note1/:1:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"First program 建立一個檔案，通常第一支程式都會是設法在 Terminal 上顯示 Hello world!，故這程式碼的檔名先命名為 hello.go，並編輯該檔案。 $ touch hello.go $ vim hello.go 程式碼大致如下。 package main import \"fmt\" func main() { fmt.Println(\"Hello world!\") } 儲存該檔案後，在 Terminal 執行下列指令，此時應該能看到 Hello world! 顯示在Terminal上。 $ go run hello.go Hello world! go run 指令會將程式碼在臨時目錄中編譯成 binary 後執行，執行完成後刪除這個檔案，若要編譯成 binary 並使用，則使用 go build 。 $ go build hello.go 此時會產生一個hello的檔案，執行該檔案一樣會看到 Hello world! 顯示在Terminal上。 $ ./hello Hello world! ","date":"2022-01-15","objectID":"/posts/go/go_note1/:2:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"Format go 語言對於撰寫格式相當嚴格，須嚴格使用標準格式，雖然在開發上會稍有不適，但對於多人開發與維護時，固定格式的程式碼會使這些工作更加容易。 也因為格式有嚴格標準，go也提供一個開發工具，go fmt，這個工具會自動重新格式化程式碼使齊符合標準格式。且目前有 go fmt 的加強版 goimports，有新的且更好用的工具，那就用新的工具吧。喜新厭舊 嘗試一下，修改前面提到的 hello.go，將其改成下面的程式碼，改動不大，僅是刪除一行縮排。 package main import \"fmt\" func main() { fmt.Println(\"Hello world!\") } 安裝 goimports，在 Terminal 中使用下列指令下載 goimports。 $ go install golang.org/x/tools/cmd/goimports@latest 安裝完成後，使用以下指令，重新開啟該檔案會發現那行縮排被重新加了回去。代表在函式中，程式碼要縮排為嚴格標準格式的規範。 $ goimports -l -w . -l : 告訴goimports，將格式不正確的檔案顯示在 Terminal上。 -w : 告訴goimports，直接修改該文件。 . : 路徑的意思，這邊用 . 代表目前的目錄與所有子目錄的所有檔案。 注意，盡量在編譯前執行 go fmt 或 goimports ，確保程式碼的格式沒有問題。 ","date":"2022-01-15","objectID":"/posts/go/go_note1/:3:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"Linting and Veting goimports 能確保程式碼是大家慣用的格式，但在其他規範上則不會做檢查，像是變數命名規則，程式碼樣式與潛在錯誤等。高品質的程式碼請參考 Effective Go 與 Go Code Review Comments 兩個網站。當然，也有相關的工具能處理這些問題，目前常見的有 golint、go vet 工具。 golint，嘗試確保程式碼會依循文件，會建議更改像是變數名稱、public method 等，他的建議並不代表是錯誤，只是希望程式碼具有特定的格式並遵循特定的規則。 go vet，可以檢測一些有效的但有可能存在錯誤的程式碼。像是將錯誤數量的參數傳遞給 method，或使用不恰當的 Function。 除了這兩個工具以外，另外還有許多第三方的工具可以檢查程式碼樣式與潛在錯誤，然而愈多的工具，在進行檢查時就會花費愈多時間。其中，golangci-lint結合了上述兩項與其他相關的程式碼品質工具。golangci-lint 文件 且這個工具可以在開發目錄的根目錄中，透過一個 .golangci.yml 的檔案，根據需求設定啟用那些工具與檢查那些檔案。.golangci.yml 文件 $ golangci-lint run 注意，一樣盡量在編譯前執行 golangci-lint，或是其他相關的工具，盡可能在編譯前找出錯誤或有疑慮的部分，確保程式碼的品質。 ","date":"2022-01-15","objectID":"/posts/go/go_note1/:4:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"Makefile 也就是說，在寫完程式後要進行編譯，我需要經常做這些事情： $ goimport -l . $ golangci-lint run $ go run [targetPath] ### 或是 $ go build [targetPath] 太麻煩了 !!! 透過 Make、shellscript 或其他的腳本語言，可以省略掉許多手動的步驟，降低重複動作的時間。 但此篇文章說的是關於程式設計，我會傾向用 make 來設計： 建立一個檔案名為Makefile，並編輯該檔案： .DEFAULT_GOAL := build fmt: goimports -l -w . .PHONY:fmt lint: golangci-lint run *.go .PHONY:lint build: lint go build hello.go .PHONY:build 並使用根目錄下使用 make 指令。 $ make 若順利的話，則會依序進行 goimports、golangci-lint 與 go build，且不用再重複下多次指令，一個 Make 就足夠了，只是要做一些前置準備。(Makefile)，另外，因為這篇主要是說明 golang 的環境建置， Makefile 的說明以後有空會再另外寫一篇說明(?) ","date":"2022-01-15","objectID":"/posts/go/go_note1/:5:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["Go"],"content":"參考資料(Reference) Learning Go(書籍) Effective Go Go Code Review Comments goimports golangci-lint .golangci.yml ","date":"2022-01-15","objectID":"/posts/go/go_note1/:6:0","tags":["go","golang"],"title":"Golang - 環境建置 (Environment)","uri":"/posts/go/go_note1/"},{"categories":["System"],"content":"自己常用的 Linux 是 Debian，從 Debian 6(squeeze) 用到 Debian 10(buster)。Debian 在 2021.08.14 時釋出了 Debian 11(bullseye)，自己以往都是至官方連結下載新版的 ISO 重新安裝，這次則想說透過升級的方式進行更新，且這也是 Debian 著名的功能，故想於這次嘗試之。 (其實是有Service在運作並做一些測試，不想重弄) ","date":"2021-12-29","objectID":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:0:0","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":["System"],"content":"準備 備份你所有的資料。（文件、圖片、設定檔、驅動程式等） 關閉所有的應用程式與服務。 關閉或刪除任何的個人套件庫(Personal Package Archive, PPA)，更新完成後再開啟或新增即可。 盡可能確保網路是穩定的。 保留一些時間進行升級。 ","date":"2021-12-29","objectID":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:1:0","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":["System"],"content":"更新步驟 ","date":"2021-12-29","objectID":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:2:0","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":["System"],"content":"更新現有的 package 開啟terminal，輸入 apt update \u0026\u0026 apt upgrade 更新套件索引(package indexes)與套件（packges），需要先將更新目前的packages。 root@server:~# apt update \u0026\u0026 apt upgrade ### 注意使用者身份，不是root的話，請加上sudo ### user@server:~$ sudo apt update \u0026\u0026 sudo apt upgrade ","date":"2021-12-29","objectID":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:2:1","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":["System"],"content":"更新來源(source.list) 修改apt的source.list，將來源由buster更改為新的bullseye。修改 /etc/apt/source.list (注意編輯權限)，不一定要使用vim，用自己喜歡的編輯器即可(e.g. emacs, nano)，請記得編輯設定檔前記得備份！！！ user@server:~$ sudo cp /etc/apt/source.list /etc/apt/source.list.bak user@server:~$ sudo vim /etc/apt/source.list 修改前的檔案 修改前的檔案\" 修改前的檔案 修改後的檔案 修改後的檔案\" 修改後的檔案 這裡再補充介紹 main, contrib, non-free main: 主要為完全符合 Debian 自由軟體指南(Debian Free Software Guidelines, DFSG)的所有package。 contrib: 為開源但依賴於 non-free 的 package。 non-free: 為不符合 Debian 自由軟體指南的 package。 ","date":"2021-12-29","objectID":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:2:2","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":["System"],"content":"升級 先使用 apt update 確認第二步的編輯是否沒有問題，若無錯誤訊息再進行 apt full-upgrade。 user@server:~$ sudo apt update user@server:~$ sudo apt full-upgrade 途中會有一些訊息需要選擇。 顯示有關packages更新的新聞。按q退出。 Information about package update\" Information about package update Package configuration，請選擇 \u003cYes\u003e Package configuration\" Package configuration 相關package的configuration，請依據需求設定，建議用 N 保留設定。 Options description : Y or I : install the package maintainer’s version (安裝維護者版本的package，會覆蓋掉該檔案的設定。) N or O : keep your currently-installed verstion (保留目前安裝的版本。) D : show the differences between the versions (顯示版本之間的差異。) Z : start a shell to examine the situation (啟動一個shell檢查情況。) 完成升級後，重新啟動系統。 user@server:~$ sudo systemctl reboot ","date":"2021-12-29","objectID":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:2:3","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":["System"],"content":"確認 透過 lsb_release -a 指令進行確認，可以發現已經從 buster 升級至 bullseye了。 user@server:~$ lsb_release -a Distributor ID: Debian Description: Debian GNU/Linux 11 (bullseye) Release: 11 Codename: bullseye 確認完成後，使用 apt --purge autoremove 刪除不再需要且不必要的packages。 user@server:~$ sudo apt --purge autoremove ","date":"2021-12-29","objectID":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:2:4","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":["System"],"content":"結論 第一次自己升級 Debian ，坦白說並沒有想像中的困難，有做好備份可以降低升級上的壓力。基本上都是apt在負責，只要有依據文件設定 /etc/apt/source.list，應該不會構成太大的問題。 ","date":"2021-12-29","objectID":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:3:0","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":["System"],"content":"參考資料 man apt debian.org Debian管理者手冊 Debian自由軟體指南,DFSG main,contrib,nonfree解釋 ","date":"2021-12-29","objectID":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/:4:0","tags":["Linux","Debian"],"title":"如何從 Debian 10 升級至 Debian 11","uri":"/posts/system/%E5%A6%82%E4%BD%95%E5%BE%9E-debian-10-%E5%8D%87%E7%B4%9A%E8%87%B3-debian-11/"},{"categories":null,"content":"一來是學過一些網路與系統服務的知識與技能，但一直都沒有做詳細的筆記，簡單來說這筆記只有自己看得懂，自己懂是一回事，要讓別人懂又是另一回事。 二來是以寫筆記或是技術文章的方式，可以促使自己學習好一點，深入一點，自己做開發或設定時，有些功能或參數可能就是把它 turn on turn off，而不會去想說這個是代表什麼，寫文章的話則必須要去解釋這個功能，進而讓自己深入學習。 三來是受大神同學影響，因為他真的很強，我也想跟他一樣強(? 有空會放上自己以前做過的服務或遇到的問題處理方式(troubleshooting)，往後學習新技能時或遇到新問題時，也盡量寫成文章記錄做出回饋。（主要是以技術文章寫筆記） 文筆不太好，若有問題請多指教。 ","date":"2021-12-28","objectID":"/posts/start/:0:0","tags":["Introduction"],"title":"Start","uri":"/posts/start/"},{"categories":null,"content":"Me 還想不到寫什麼呢😟😟😟 ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Log 2021/12/28 : 開始。 2022/02/13 : 從 vuepress 搬遷至 Docusaurus。 2022/02/14 : 從 Docusaurus 搬遷至 Hugo (theme:LoveIt)。 ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Link ","date":"0001-01-01","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"友站連結 國立臺北科技大學 資訊工程系 無線與寬頻網路實驗室 Oscar’s Pathways ","date":"0001-01-01","objectID":"/about/:3:1","tags":null,"title":"About","uri":"/about/"}]